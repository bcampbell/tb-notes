# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1687477183 -43200
#      Fri Jun 23 11:39:43 2023 +1200
# Node ID 3342d6517982ae3dccbc3b5aad52f85829a737be
# Parent  5905bd26b895fa0f763c6ca752bcea663c296843
Bug ??? - Simplify args for nsImapService::FetchMimePart() (the internal helper, not the nsIMsgMessageFetchPartService implementation).

diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -289,21 +289,18 @@ NS_IMETHODIMP nsImapService::FetchMimePa
       nsCOMPtr<nsIImapUrl> imapUrl = do_QueryInterface(aURI);
       nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(aURI, &rv));
       NS_ENSURE_SUCCESS(rv, rv);
 
       msgurl->SetMsgWindow(aMsgWindow);
       msgurl->RegisterListener(aUrlListener);
 
       if (!mimePart.IsEmpty()) {
-        nsAutoCString msgKey;
-        msgKey.AppendInt(key);
-        return FetchMimePart(imapUrl, nsIImapUrl::nsImapMsgFetch, folder,
-                             imapMessageSink, aURL, aDisplayConsumer, msgKey,
-                             mimePart);
+        return FetchMimePart(imapUrl, folder, imapMessageSink, aURL,
+                             aDisplayConsumer, key, mimePart);
       }
     }
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::LoadMessage(const nsACString& aMessageURI,
                                          nsISupports* aDisplayConsumer,
@@ -370,19 +367,19 @@ NS_IMETHODIMP nsImapService::LoadMessage
 
         nsAutoCString msgKey;
         msgKey.AppendInt(key);
         rv = AddImapFetchToUrl(mailnewsurl, folder, msgKey + mimePart,
                                EmptyCString());
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsIURI> dummyURI;
-        return FetchMimePart(imapUrl, nsIImapUrl::nsImapMsgFetch, folder,
-                             imapMessageSink, getter_AddRefs(dummyURI),
-                             aDisplayConsumer, msgKey, mimePart);
+        return FetchMimePart(imapUrl, folder, imapMessageSink,
+                             getter_AddRefs(dummyURI), aDisplayConsumer, key,
+                             mimePart);
       }
 
       nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(imapUrl));
       nsCOMPtr<nsIMsgI18NUrl> i18nurl(do_QueryInterface(imapUrl));
       i18nurl->SetAutodetectCharset(aAutodetectCharset);
 
       bool shouldStoreMsgOffline = false;
       bool hasMsgOffline = false;
@@ -425,55 +422,54 @@ NS_IMETHODIMP nsImapService::LoadMessage
                                   : nsIImapUrl::nsImapMsgFetch,
                         folder, imapMessageSink, aMsgWindow, aDisplayConsumer,
                         msgKey, false, getter_AddRefs(dummyURI));
     }
   }
   return rv;
 }
 
-nsresult nsImapService::FetchMimePart(
-    nsIImapUrl* aImapUrl, nsImapAction aImapAction,
-    nsIMsgFolder* aImapMailFolder, nsIImapMessageSink* aImapMessage,
-    nsIURI** aURL, nsISupports* aDisplayConsumer,
-    const nsACString& messageIdentifierList, const nsACString& mimePart) {
+nsresult nsImapService::FetchMimePart(nsIImapUrl* aImapUrl,
+                                      nsIMsgFolder* aImapMailFolder,
+                                      nsIImapMessageSink* aImapMessage,
+                                      nsIURI** aURL,
+                                      nsISupports* aDisplayConsumer,
+                                      nsMsgKey msgKey,
+                                      const nsACString& mimePart) {
   NS_ENSURE_ARG_POINTER(aImapUrl);
   NS_ENSURE_ARG_POINTER(aImapMailFolder);
   NS_ENSURE_ARG_POINTER(aImapMessage);
+  MOZ_ASSERT(msgKey != nsMsgKey_None);
 
   // create a protocol instance to handle the request.
   // NOTE: once we start working with multiple connections, this step will be
   // much more complicated...but for now just create a connection and process
   // the request.
   nsAutoCString urlSpec;
   nsresult rv = SetImapUrlSink(aImapMailFolder, aImapUrl);
-  nsImapAction actionToUse = aImapAction;
-  if (actionToUse == nsImapUrl::nsImapOpenMimePart)
-    actionToUse = nsIImapUrl::nsImapMsgFetch;
 
   nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(aImapUrl));
-  if (aImapMailFolder && msgurl && !messageIdentifierList.IsEmpty()) {
+  if (aImapMailFolder && msgurl) {
     bool useLocalCache = false;
-    aImapMailFolder->HasMsgOffline(
-        strtoul(PromiseFlatCString(messageIdentifierList).get(), nullptr, 10),
-        &useLocalCache);
+    rv = aImapMailFolder->HasMsgOffline(msgKey, &useLocalCache);
+    NS_ENSURE_SUCCESS(rv, rv);
     msgurl->SetMsgIsInLocalCache(useLocalCache);
   }
   rv = aImapUrl->SetImapMessageSink(aImapMessage);
   if (NS_SUCCEEDED(rv)) {
     nsCOMPtr<nsIURI> url = do_QueryInterface(aImapUrl);
     if (aURL) NS_IF_ADDREF(*aURL = url);
 
     rv = url->GetSpec(urlSpec);
     NS_ENSURE_SUCCESS(rv, rv);
 
     rv = msgurl->SetSpecInternal(urlSpec);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = aImapUrl->SetImapAction(actionToUse /* nsIImapUrl::nsImapMsgFetch */);
+    rv = aImapUrl->SetImapAction(nsIImapUrl::nsImapMsgFetch);
     if (aImapMailFolder && aDisplayConsumer) {
       nsCOMPtr<nsIMsgIncomingServer> aMsgIncomingServer;
       rv = aImapMailFolder->GetServer(getter_AddRefs(aMsgIncomingServer));
       if (NS_SUCCEEDED(rv) && aMsgIncomingServer) {
         bool interrupted;
         nsCOMPtr<nsIImapIncomingServer> aImapServer(
             do_QueryInterface(aMsgIncomingServer, &rv));
         if (NS_SUCCEEDED(rv) && aImapServer)
@@ -486,21 +482,17 @@ nsresult nsImapService::FetchMimePart(
     // using AsyncRead and the provided stream listener....
 
     nsCOMPtr<nsIDocShell> docShell(do_QueryInterface(aDisplayConsumer, &rv));
     if (NS_SUCCEEDED(rv) && docShell) {
       // DIRTY LITTLE HACK --> if we are opening an attachment we want the
       // docshell to treat this load as if it were a user click event. Then the
       // dispatching stuff will be much happier.
       RefPtr<nsDocShellLoadState> loadState = new nsDocShellLoadState(url);
-      loadState->SetLoadFlags(aImapAction == nsImapUrl::nsImapOpenMimePart
-                                  ? nsIWebNavigation::LOAD_FLAGS_IS_LINK
-                                  : nsIWebNavigation::LOAD_FLAGS_NONE);
-      if (aImapAction == nsImapUrl::nsImapOpenMimePart)
-        loadState->SetLoadType(LOAD_LINK);
+      loadState->SetLoadFlags(nsIWebNavigation::LOAD_FLAGS_NONE);
       loadState->SetFirstParty(false);
       loadState->SetTriggeringPrincipal(nsContentUtils::GetSystemPrincipal());
       rv = docShell->LoadURI(loadState, false);
     } else {
       nsCOMPtr<nsIStreamListener> aStreamListener =
           do_QueryInterface(aDisplayConsumer, &rv);
       if (NS_SUCCEEDED(rv) && aStreamListener) {
         nsCOMPtr<nsIChannel> aChannel;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1669077179 -46800
#      Tue Nov 22 13:32:59 2022 +1300
# Node ID daa970a5de7763b4efc5fa71491fd240f1e02a9f
# Parent  3342d6517982ae3dccbc3b5aad52f85829a737be
WIP: Bug 1802828 - C++/sqlite global msgdb.

Differential Revision: https://phabricator.services.mozilla.com/D163191

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -0,0 +1,597 @@
+#include "GlobalDB.h"
+
+#include "msgCore.h"
+#include "nsIFile.h"
+#include "mozIStorageService.h"
+#include "nsAppDirectoryServiceDefs.h"
+#include "nsDirectoryServiceUtils.h"
+#include "nsMsgHdr2.h"
+
+GlobalDB::GlobalDB() : mStmtCache(mConn) {}
+
+GlobalDB::~GlobalDB() {
+  if (mConn) {
+    mConn->Close();
+  }
+}
+
+nsresult GlobalDB::Init() {
+  nsCOMPtr<mozIStorageService> storage =
+      do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
+  NS_ENSURE_STATE(storage);
+
+  // Build up the filename.
+  nsCOMPtr<nsIFile> profileDir;
+  nsresult rv = NS_GetSpecialDirectory(NS_APP_USER_PROFILE_50_DIR,
+                                       getter_AddRefs(profileDir));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIFile> dbFile;
+  rv = profileDir->Clone(getter_AddRefs(dbFile));
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = dbFile->Append(u"globaldb.sqlite"_ns);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Open the db file, creating it if it doesn't exist.
+  // Currently just using a single connection, no fancy stuff.
+  rv = storage->OpenUnsharedDatabase(
+      dbFile, mozIStorageService::CONNECTION_DEFAULT, getter_AddRefs(mConn));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // TODO: set up connection (eg enable foreign key support)
+  // TODO: use "PRAGMA user_version" to hold schema version
+
+  // set journal mode to wal (if filesystem supports it)
+  {
+    nsCOMPtr<mozIStorageStatement> statement;
+    nsAutoCString query(MOZ_STORAGE_UNIQUIFY_QUERY_STR
+                        "PRAGMA journal_mode = wal");
+    mConn->CreateStatement(query, getter_AddRefs(statement));
+    NS_ENSURE_TRUE(statement, NS_ERROR_FAILURE);
+
+    bool hasResult = false;
+    nsAutoCString journalMode;
+    if (NS_SUCCEEDED(statement->ExecuteStep(&hasResult)) && hasResult &&
+        NS_SUCCEEDED(statement->GetUTF8String(0, journalMode))) {
+      printf("journal_mode: %s\n", journalMode.get());
+    }
+  }
+
+  rv = InitSchema();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+nsresult GlobalDB::InitSchema() {
+  const int32_t latestSchemaVersion = 1;
+  int32_t currentSchemaVersion;
+  nsresult rv = mConn->GetSchemaVersion(&currentSchemaVersion);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (currentSchemaVersion == latestSchemaVersion) {
+    printf("Schema is up to date.\n");
+    return NS_OK;  // All up to date.
+  }
+
+  if (currentSchemaVersion == 0) {
+    printf("Loading initial schema\n");
+    // NOTES:
+    // - we use the automatic rowid colum as our primary key
+    //   presenting it as nsMsgKey.
+    const nsLiteralCString create_msg(
+        "CREATE TABLE msg ( "
+        "messageID TEXT NOT NULL DEFAULT '', "
+        "refs TEXT NOT NULL DEFAULT '', "        // REFERENCES is reserved word
+        "date INTEGER NOT NULL DEFAULT 0, "      // use proper datetime type?
+        "received INTEGER NOT NULL DEFAULT 0, "  // ditto
+        "subject TEXT NOT NULL DEFAULT '', "
+        "sender TEXT NOT NULL DEFAULT '', "  // (NOTE: FROM is reserved word)
+        "recipients TEXT NOT NULL DEFAULT '', "
+        "ccList TEXT NOT NULL DEFAULT '', "
+        "replyTo TEXT NOT NULL DEFAULT '', "
+        "flags INTEGER NOT NULL DEFAULT 0, "
+        "priority INTEGER NOT NULL DEFAULT 0, "
+        "msgSize INTEGER NOT NULL DEFAULT 0, "  // SIZE is reserved word
+        "storeToken TEXT NOT NULL DEFAULT '', "
+        "offlineMsgSize INTEGER NOT NULL DEFAULT 0, "
+        "numLines INTEGER NOT NULL DEFAULT 0, "
+        "preview TEXT NOT NULL DEFAULT '', "
+        "junkscoreorigin TEXT NOT NULL DEFAULT '', "
+        "junkpercent TEXT NOT NULL DEFAULT '', "
+        "senderName TEXT NOT NULL DEFAULT '', "  // KILL?
+        "prevkeywords TEXT NOT NULL DEFAULT '', "
+        "keywords TEXT NOT NULL DEFAULT '', "
+        "remoteContentPolicy INTEGER NOT NULL DEFAULT 0, "
+        "protoThreadFlags INTEGER NOT NULL DEFAULT 0, "
+        //  "account TEXT NOT NULL DEFAULT '', "    // ACCOUNT is reserved word
+        "glodaId INTEGER NOT NULL DEFAULT 0, "
+        "xGmMsgId TEXT NOT NULL DEFAULT '', "
+        "xGmThrId TEXT NOT NULL DEFAULT '', "
+        "xGmLabels TEXT NOT NULL DEFAULT '', "
+        "pseudoHdr INTEGER NOT NULL DEFAULT 0, "  // KILL KILL KILL!
+        "enigmail INTEGER NOT NULL DEFAULT 0, "
+        "notAPhishMessage INTEGER NOT NULL DEFAULT 0 "
+        ")");
+
+    rv = mConn->ExecuteSimpleSQL(create_msg);
+    NS_ENSURE_SUCCESS(rv, rv);
+  } else {
+    // Migrations go here...
+  }
+
+  rv = mConn->SetSchemaVersion(latestSchemaVersion);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+nsresult GlobalDB::StashMsg(RawHdr const& msg) {
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "INSERT INTO msg "
+      "(messageID, refs, date, received, subject, sender, recipients, "
+      "ccList, replyto, flags, priority, msgSize, storeToken, "
+      "offlineMsgSize, "
+      "numLines, preview, junkscoreorigin, junkpercent, senderName, "
+      "prevkeywords, keywords, remoteContentPolicy, protoThreadFlags, "
+      "glodaId, xGmMsgId, xGmThrId, xGmLabels, pseudoHdr, enigmail, "
+      "notAPhishMessage"
+      ") "
+      "VALUES (:messageID, :refs, :date, :received, :subject, :sender, "
+      ":recipients, :ccList, :replyTo, :flags, :priority, :msgSize, "
+      ":storeToken, "
+      ":offlineMsgSize, "
+      ":numLines, :preview, :junkscoreorigin, :junkpercent, :senderName, "
+      ":prevkeywords, :keywords, :remoteContentPolicy, :protoThreadFlags, "
+      ":glodaId, :xGmMsgId, :xGmThrId, :xGmLabels, :pseudoHdr, :enigmail, "
+      ":notAPhishMessage"
+      ")");
+  NS_ENSURE_STATE(stmt);
+
+  nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, msg.messageID);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("refs"_ns, msg.references);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt64ByName("date"_ns, msg.date);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt64ByName("received"_ns, msg.received);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindUTF8StringByName("subject"_ns, msg.subject);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("sender"_ns, msg.sender);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("recipients"_ns, msg.recipients);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("ccList"_ns, msg.ccList);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("replyTo"_ns, msg.replyTo);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt32ByName("flags"_ns, msg.flags);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt32ByName("priority"_ns, msg.priority);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt64ByName("msgSize"_ns, msg.msgSize);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("storeToken"_ns, msg.storeToken);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt64ByName("offlineMsgSize"_ns, msg.offlineMsgSize);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt32ByName("numLines"_ns, msg.numLines);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindUTF8StringByName("preview"_ns, msg.preview);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("junkscoreorigin"_ns, msg.junkscoreorigin);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("junkpercent"_ns, msg.junkpercent);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindUTF8StringByName("senderName"_ns, msg.senderName);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindUTF8StringByName("prevkeywords"_ns, msg.prevkeywords);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("keywords"_ns, msg.keywords);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt32ByName("remoteContentPolicy"_ns, msg.remoteContentPolicy);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt32ByName("protoThreadFlags"_ns, msg.protoThreadFlags);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt32ByName("glodaId"_ns, msg.glodaId);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindUTF8StringByName("xGmMsgId"_ns, msg.xGmMsgId);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("xGmThrId"_ns, msg.xGmThrId);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindUTF8StringByName("xGmLabels"_ns, msg.xGmLabels);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->BindInt32ByName("pseudoHdr"_ns, msg.pseudoHdr);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt32ByName("enigmail"_ns, msg.enigmail);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt32ByName("notAPhishMessage"_ns, msg.notAPhishMessage);
+  if (NS_FAILED(rv)) return rv;
+
+  rv = stmt->Execute();
+  if (NS_FAILED(rv)) {
+    return rv;
+  }
+
+  return NS_OK;
+}
+
+nsresult GlobalDB::StashMsgs(nsTArray<RawHdr> const& msgs) {
+  mozStorageTransaction transaction(mConn, false);
+  nsresult rv = transaction.Start();
+  NS_ENSURE_SUCCESS(rv, rv);
+  for (RawHdr const& msg : msgs) {
+    rv = StashMsg(msg);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  return transaction.Commit();
+}
+
+nsCString GlobalDB::LastErr() {
+  nsCString err;
+  mConn->GetLastErrorString(err);
+  return err;
+}
+
+// Just use a shonky singleton for now.
+// static
+GlobalDB& GlobalDB::get() {
+  static GlobalDB instance;
+  if (!instance.mConn) {
+    nsresult rv = instance.Init();
+    MOZ_ASSERT(NS_SUCCEEDED(rv));
+  }
+  return instance;
+}
+
+already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(nsACString const& query) {
+  return mStmtCache.GetCachedStatement(query);
+}
+
+already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(const char* query) {
+  return Stmt(nsDependentCString(query));
+}
+
+// -------------- data access ---------------
+
+nsresult GlobalDB::FetchMsgFlags(nsMsgKey key, uint32_t* flags) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT flags FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt32(0, (int32_t*)flags);
+}
+
+nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT messageID FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, messageID);
+}
+
+nsresult GlobalDB::FetchMsgReferences(nsMsgKey key, nsACString& refs) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT refs FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, refs);
+}
+
+nsresult GlobalDB::FetchMsgSender(nsMsgKey key, nsACString& sender) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT sender FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, sender);
+}
+
+nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT subject FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, subject);
+}
+
+nsresult GlobalDB::FetchMsgRecipients(nsMsgKey key, nsACString& recipients) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT recipients FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, recipients);
+}
+
+nsresult GlobalDB::FetchMsgCCList(nsMsgKey key, nsACString& ccList) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT ccList FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, ccList);
+}
+
+nsresult GlobalDB::FetchMsgBCCList(nsMsgKey key, nsACString& bccList) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT bccList FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, bccList);
+}
+
+nsresult GlobalDB::FetchMsgSize(nsMsgKey key, uint64_t* size) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT msgSize FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt64(0, (int64_t*)size);
+}
+
+nsresult GlobalDB::FetchMsgOfflineSize(nsMsgKey key, uint64_t* size) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT offlineMsgSize FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt64(0, (int64_t*)size);
+}
+
+nsresult GlobalDB::FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT lineCount FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt32(0, (int32_t*)lineCount);
+}
+
+nsresult GlobalDB::FetchMsgDate(nsMsgKey key, uint32_t* seconds) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT date FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt32(0, (int32_t*)seconds);
+}
+
+nsresult GlobalDB::FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FetchMsgPriority(nsMsgKey key,
+                                    nsMsgPriorityValue* priority) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT priority FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetInt32(0, (int32_t*)priority);
+}
+
+nsresult GlobalDB::FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& author) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgReferences(nsMsgKey key,
+                                    nsACString const& references) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgSender(nsMsgKey key, nsACString const& sender) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
+                                    nsACString const& recipients) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgCCList(nsMsgKey key, nsACString const& ccList) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgBCCList(nsMsgKey key, nsACString const& bccList) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgSize(nsMsgKey key, uint64_t size) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgLineCount(nsMsgKey key, uint32_t lineCount) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgThreadID(nsMsgKey key, nsMsgKey threadID) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgAccountKey(nsMsgKey key,
+                                    nsACString const& accountKey) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// odd flag-twiddling ones
+nsresult GlobalDB::FetchMsgIsRead(nsMsgKey key, bool* isRead) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FetchMsgIsMarked(nsMsgKey key, bool* isMarked) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FetchMsgIsWatched(nsMsgKey key, bool* isWatched) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// nsresult GlobalDB::FetchMsgIsFlagged(nsMsgKey key, bool isFlagged) {
+//   return NS_ERROR_NOT_IMPLEMENTED;
+// }
+
+nsresult GlobalDB::FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgIsRead(nsMsgKey key, bool isRead) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgIsFlagged(nsMsgKey key, bool isFlagged) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// to support nsMsgDatabase2
+nsresult GlobalDB::FolderContainsKey(uint32_t folderID, nsMsgKey key,
+                                     bool* containsKey) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FolderGetMsgHdrForKey(uint32_t folderID, nsMsgKey key,
+                                         nsIMsgDBHdr** hdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FolderDeleteHeader(uint32_t folderID, nsMsgKey key,
+                                      nsIDBChangeListener* instigator,
+                                      bool commit, bool notify) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::FolderUndoDelete(uint32_t folderID, nsMsgKey key) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// oddities
+nsresult GlobalDB::MarkMsgRead(nsMsgKey key, bool isRead,
+                               nsIDBChangeListener* instigator) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::SetMsgFlag(nsMsgKey key, bool value,
+                              nsMsgMessageFlagType flag,
+                              nsIDBChangeListener* instigator) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult GlobalDB::GetMsgHdrForMessageID(nsACString const& messageID,
+                                         nsMsgHdr2** found) {
+  *found = nullptr;
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -0,0 +1,147 @@
+/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set ts=8 sts=2 et sw=2 tw=80: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef GlobalDB_h_
+#define GlobalDB_h_
+
+#include "mozilla/storage.h"
+#include "MailNewsTypes2.h"
+#include "nsMsgMessageFlags.h"
+#include "nsTArray.h"
+
+// Using toolkit/components/places/Database.h as rough guide
+
+struct RawHdr {
+  nsMsgKey id{0};
+  nsCString messageID;
+  nsCString references;
+  uint64_t date{0};
+  uint64_t received{0};
+  nsCString subject;
+  nsCString sender;
+  nsCString recipients;
+  nsCString ccList;
+  nsCString replyTo;
+  uint32_t flags{0};
+  int32_t priority{0};
+  uint64_t msgSize{0};
+  nsCString storeToken;
+  uint64_t offlineMsgSize{0};
+  uint32_t numLines{0};
+  nsCString preview;
+  nsCString junkscoreorigin;
+  nsCString junkpercent;
+  nsCString senderName;
+  nsCString prevkeywords;
+  nsCString keywords;
+  int remoteContentPolicy{0};
+  int protoThreadFlags{0};
+  int glodaId{0};
+  nsCString xGmMsgId;
+  nsCString xGmThrId;
+  nsCString xGmLabels;
+  int pseudoHdr{0};
+  int enigmail{0};
+  int notAPhishMessage{0};
+};
+
+class nsIMsgDBHdr;
+class nsIDBChangeListener;
+class nsMsgHdr2;
+
+class GlobalDB {
+ public:
+  static GlobalDB& get();
+
+  GlobalDB();
+  ~GlobalDB();
+  nsresult Init();
+
+  nsresult StashMsgs(nsTArray<RawHdr> const& msgs);
+
+  // Get the last DB error message.
+  nsCString LastErr();
+
+  // -------------- data access ---------------
+
+  // to support nsMsgHdr2
+  nsresult FetchMsgFlags(nsMsgKey key, uint32_t* flags);
+  nsresult FetchMsgMessageID(nsMsgKey key, nsACString& messageID);
+  nsresult FetchMsgReferences(nsMsgKey key, nsACString& refs);
+  nsresult FetchMsgSender(nsMsgKey key, nsACString& sender);
+  nsresult FetchMsgSubject(nsMsgKey key, nsACString& subject);
+  nsresult FetchMsgRecipients(nsMsgKey key, nsACString& recipients);
+  nsresult FetchMsgCCList(nsMsgKey key, nsACString& ccList);
+  nsresult FetchMsgBCCList(nsMsgKey key, nsACString& bccList);
+  nsresult FetchMsgSize(nsMsgKey key, uint64_t* size);
+  nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
+  nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
+  nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
+  nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID);
+  nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
+  nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
+
+  nsresult SetMsgFlags(nsMsgKey key, uint32_t flags);
+  nsresult SetMsgMessageID(nsMsgKey key, nsACString const& author);
+  nsresult SetMsgReferences(nsMsgKey key, nsACString const& references);
+  nsresult SetMsgSender(nsMsgKey key, nsACString const& sender);
+  nsresult SetMsgSubject(nsMsgKey key, nsACString const& subject);
+  nsresult SetMsgRecipients(nsMsgKey key, nsACString const& recipients);
+  nsresult SetMsgCCList(nsMsgKey key, nsACString const& ccList);
+  nsresult SetMsgBCCList(nsMsgKey key, nsACString const& bccList);
+  nsresult SetMsgSize(nsMsgKey key, uint64_t size);
+  nsresult SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize);
+  nsresult SetMsgLineCount(nsMsgKey key, uint32_t lineCount);
+  nsresult SetMsgDate(nsMsgKey key, uint32_t seconds);
+  nsresult SetMsgThreadID(nsMsgKey key, nsMsgKey threadID);
+  nsresult SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority);
+  nsresult SetMsgAccountKey(nsMsgKey key, nsACString const& accountKey);
+
+  // odd flag-twiddling ones
+  nsresult FetchMsgIsRead(nsMsgKey key, bool* isRead);
+  nsresult FetchMsgIsMarked(nsMsgKey key, bool* isMarked);
+  nsresult FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored);
+  nsresult FetchMsgIsWatched(nsMsgKey key, bool* isWatched);
+  // nsresult FetchMsgIsFlagged(nsMsgKey key, bool isFlagged);
+  nsresult FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments);
+
+  nsresult SetMsgIsRead(nsMsgKey key, bool isRead);
+  nsresult SetMsgIsFlagged(nsMsgKey key, bool isFlagged);
+  nsresult SetMsgHasAttachments(nsMsgKey key, bool hasAttachments);
+
+  // to support nsMsgDatabase2
+  nsresult FolderContainsKey(uint32_t folderID, nsMsgKey key,
+                             bool* containsKey);
+  nsresult FolderGetMsgHdrForKey(uint32_t folderID, nsMsgKey key,
+                                 nsIMsgDBHdr** hdr);
+  nsresult FolderDeleteHeader(uint32_t folderID, nsMsgKey key,
+                              nsIDBChangeListener* instigator, bool commit,
+                              bool notify);
+
+  nsresult FolderUndoDelete(uint32_t folderID, nsMsgKey key);
+
+  // oddities
+  nsresult MarkMsgRead(nsMsgKey key, bool isRead,
+                       nsIDBChangeListener* instigator);
+  nsresult SetMsgFlag(nsMsgKey key, bool value, nsMsgMessageFlagType flag,
+                      nsIDBChangeListener* instigator);
+
+  nsresult GetMsgHdrForMessageID(nsACString const& messageID,
+                                 nsMsgHdr2** found);
+
+ private:
+  nsresult InitSchema();
+  nsresult StashMsg(RawHdr const& msg);
+  already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
+  // TODO: Add a templated version to speed up for literals?
+  already_AddRefed<mozIStorageStatement> Stmt(const char* query);
+  already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
+                                                    const char* query);
+  nsCOMPtr<mozIStorageConnection> mConn;
+  mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
+};
+
+#endif  // GlobalDB_h_
diff --git a/mailnews/db/msgdb/src/MSFSlurp.cpp b/mailnews/db/msgdb/src/MSFSlurp.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/MSFSlurp.cpp
@@ -0,0 +1,499 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "msgCore.h"
+#include "nsNetUtil.h"
+#include "nsStreamUtils.h"
+#include "nsIFile.h"
+#include "MailNewsTypes2.h"
+//  Mork-related includes.
+#include "prtime.h"
+#include "nsIMdbFactoryFactory.h"
+#include "mdb.h"
+
+#include "GlobalDB.h"
+
+using namespace mozilla;
+
+// Noddy little test class to slurp all the messages out of an msf file
+// and dump them into GlobalDB.
+class MSFSlurper {
+ public:
+  MSFSlurper() {}
+
+  ~MSFSlurper() {
+    if (mAllMsgHeadersTable) mAllMsgHeadersTable->Release();
+    if (mAllThreadsTable) mAllThreadsTable->Release();
+    if (mPort) {
+      mPort = nullptr;
+      mPort->Release();
+    }
+    if (mEnv) {
+      mEnv->Release();
+      mEnv = nullptr;
+    }
+  }
+
+  nsresult Open(PathString const& msfPath);
+
+  nsresult dumpum();
+
+ private:
+  //  nsIMdbEnv* GetEnv() { return mEnv; }
+  //  nsIMdbPort* GetStore() { return mPort; }
+  nsresult InitTokens();
+
+  nsIMdbEnv* mEnv{nullptr};  // to be used in all the db calls.
+  nsIMdbPort* mPort{nullptr};
+  nsIMdbTable* mAllMsgHeadersTable{nullptr};
+  nsIMdbTable* mAllThreadsTable{nullptr};
+
+  mdb_token m_hdrRowScopeToken;
+  mdb_token m_threadRowScopeToken;
+  mdb_token m_hdrTableKindToken;
+  mdb_token m_threadTableKindToken;
+  mdb_token m_allThreadsTableKindToken;
+  mdb_token m_subjectColumnToken;
+  mdb_token m_senderColumnToken;
+  mdb_token m_messageIdColumnToken;
+  mdb_token m_referencesColumnToken;
+  mdb_token m_recipientsColumnToken;
+  mdb_token m_dateColumnToken;
+  mdb_token m_messageSizeColumnToken;
+  mdb_token m_flagsColumnToken;
+  mdb_token m_priorityColumnToken;
+  mdb_token m_labelColumnToken;
+  mdb_token m_numLinesColumnToken;
+  mdb_token m_ccListColumnToken;
+  mdb_token m_bccListColumnToken;
+  mdb_token m_threadFlagsColumnToken;
+  mdb_token m_threadIdColumnToken;
+  mdb_token m_threadChildrenColumnToken;
+  mdb_token m_threadUnreadChildrenColumnToken;
+  mdb_token m_messageThreadIdColumnToken;
+  mdb_token m_threadSubjectColumnToken;
+  mdb_token m_messageCharSetColumnToken;
+  mdb_token m_threadParentColumnToken;
+  mdb_token m_threadRootKeyColumnToken;
+  mdb_token m_threadNewestMsgDateColumnToken;
+  mdb_token m_offlineMsgOffsetColumnToken;
+  mdb_token m_offlineMessageSizeColumnToken;
+};
+
+nsresult MSFSlurper::Open(PathString const& msfPath) {
+  nsresult rv;
+  PRTime start = PR_Now();
+
+  nsCOMPtr<nsIMdbFactoryService> factoryService =
+      do_GetService("@mozilla.org/db/mork;1", &rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIMdbFactory> factory;
+  rv = factoryService->GetMdbFactory(getter_AddRefs(factory));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = factory->MakeEnv(nullptr, &mEnv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  mEnv->SetAutoClear(true);
+
+  // Open the file (read-only)
+  nsCOMPtr<nsIMdbFile> dbFile;
+  rv = factory->OpenOldFile(mEnv,
+                            nullptr,  // Use default heap alloc fns.
+                            msfPath.get(),
+                            mdbBool_kTrue,  // Frozen (read only).
+                            getter_AddRefs(dbFile));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Unsure if we actually need this...
+  mdb_bool canOpen;
+  mdbYarn outFormatVersion;
+  rv = factory->CanOpenFilePort(mEnv, dbFile, &canOpen, &outFormatVersion);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!canOpen) {
+    return NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE;
+  }
+
+  mdbOpenPolicy inOpenPolicy;
+  inOpenPolicy.mOpenPolicy_ScopePlan.mScopeStringSet_Count = 0;
+  inOpenPolicy.mOpenPolicy_MinMemory = 0;
+  inOpenPolicy.mOpenPolicy_MaxLazy = 0;
+
+  // Unsure what this is doing. Applying appended-but-unapplied writes?
+  nsCOMPtr<nsIMdbThumb> thumb;
+  rv = factory->OpenFileStore(mEnv, nullptr, dbFile, &inOpenPolicy,
+                              getter_AddRefs(thumb));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (!thumb) {
+    return NS_ERROR_FAILURE;
+  }
+  {
+    mdb_count outTotal;    // total somethings to do in operation
+    mdb_count outCurrent;  // subportion of total completed so far
+    mdb_bool outDone;      // is operation finished?
+    mdb_bool outBroken;    // is operation irreparably dead and broken?
+    do {
+      rv = thumb->DoMore(mEnv, &outTotal, &outCurrent, &outDone, &outBroken);
+      NS_ENSURE_SUCCESS(rv, rv);
+      if (outBroken) {
+        // TODO: some cleanup?
+        return NS_ERROR_FAILURE;
+      }
+    } while (!outDone);
+  }
+
+  // Finally.
+  rv = factory->ThumbToOpenPort(mEnv, thumb, &mPort);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = InitTokens();
+  PRInt64 elapsed = PR_Now() - start;
+  printf("OPEN complete in %.3f ms\n", (double)elapsed / 1000.0);
+
+  return rv;
+}
+
+// initialize the various tokens and tables in our db's env
+nsresult MSFSlurper::InitTokens() {
+  // special keys
+  static const nsMsgKey kAllMsgHdrsTableKey = 1;
+  // static const nsMsgKey kTableKeyForThreadOne = 0xfffffffe;
+  static const nsMsgKey kAllThreadsTableKey = 0xfffffffd;
+  // static const nsMsgKey kFirstPseudoKey = 0xfffffff0;
+  // static const nsMsgKey kIdStartOfFake = 0xffffff80;
+  // static const nsMsgKey kForceReparseKey = 0xfffffff0;
+
+  const char* kMsgHdrsScope =
+      "ns:msg:db:row:scope:msgs:all";  // scope for all headers table
+  const char* kMsgHdrsTableKind = "ns:msg:db:table:kind:msgs";
+  const char* kThreadTableKind = "ns:msg:db:table:kind:thread";
+  const char* kThreadHdrsScope =
+      "ns:msg:db:row:scope:threads:all";  // scope for all threads table
+  const char* kAllThreadsTableKind =
+      "ns:msg:db:table:kind:allthreads";  // kind for table of all threads
+  const char* kSubjectColumnName = "subject";
+  const char* kSenderColumnName = "sender";
+  const char* kMessageIdColumnName = "message-id";
+  const char* kReferencesColumnName = "references";
+  const char* kRecipientsColumnName = "recipients";
+  const char* kDateColumnName = "date";
+  const char* kMessageSizeColumnName = "size";
+  const char* kFlagsColumnName = "flags";
+  const char* kPriorityColumnName = "priority";
+  const char* kLabelColumnName = "label";
+  const char* kNumLinesColumnName = "numLines";
+  const char* kCCListColumnName = "ccList";
+  const char* kBCCListColumnName = "bccList";
+  const char* kMessageThreadIdColumnName = "msgThreadId";
+  const char* kThreadFlagsColumnName = "threadFlags";
+  const char* kThreadIdColumnName = "threadId";
+  const char* kThreadChildrenColumnName = "children";
+  const char* kThreadUnreadChildrenColumnName = "unreadChildren";
+  const char* kThreadSubjectColumnName = "threadSubject";
+  const char* kMessageCharSetColumnName = "msgCharSet";
+  const char* kThreadParentColumnName = "threadParent";
+  const char* kThreadRootColumnName = "threadRoot";
+  const char* kThreadNewestMsgDateColumnName = "threadNewestMsgDate";
+  const char* kOfflineMsgOffsetColumnName = "msgOffset";
+  const char* kOfflineMsgSizeColumnName = "offlineMsgSize";
+  //  const char* kFixedBadRefThreadingProp = "fixedBadRefThreading";
+
+  struct {
+    const char* name;
+    mdb_token* tok;
+  } lookups[] = {
+      {kMsgHdrsScope, &m_hdrRowScopeToken},
+      {kSubjectColumnName, &m_subjectColumnToken},
+      {kSenderColumnName, &m_senderColumnToken},
+      {kMessageIdColumnName, &m_messageIdColumnToken},
+      {kReferencesColumnName, &m_referencesColumnToken},
+      {kRecipientsColumnName, &m_recipientsColumnToken},
+      {kDateColumnName, &m_dateColumnToken},
+      {kMessageSizeColumnName, &m_messageSizeColumnToken},
+      {kFlagsColumnName, &m_flagsColumnToken},
+      {kPriorityColumnName, &m_priorityColumnToken},
+      {kLabelColumnName, &m_labelColumnToken},
+      {kNumLinesColumnName, &m_numLinesColumnToken},
+      {kCCListColumnName, &m_ccListColumnToken},
+      {kBCCListColumnName, &m_bccListColumnToken},
+      {kMessageThreadIdColumnName, &m_messageThreadIdColumnToken},
+      {kThreadIdColumnName, &m_threadIdColumnToken},
+      {kThreadFlagsColumnName, &m_threadFlagsColumnToken},
+      {kThreadNewestMsgDateColumnName, &m_threadNewestMsgDateColumnToken},
+      {kThreadChildrenColumnName, &m_threadChildrenColumnToken},
+      {kThreadUnreadChildrenColumnName, &m_threadUnreadChildrenColumnToken},
+      {kThreadSubjectColumnName, &m_threadSubjectColumnToken},
+      {kMessageCharSetColumnName, &m_messageCharSetColumnToken},
+      {kMsgHdrsTableKind, &m_hdrTableKindToken},
+      {kThreadTableKind, &m_threadTableKindToken},
+      {kAllThreadsTableKind, &m_allThreadsTableKindToken},
+      {kThreadHdrsScope, &m_threadRowScopeToken},
+      {kThreadParentColumnName, &m_threadParentColumnToken},
+      {kThreadRootColumnName, &m_threadRootKeyColumnToken},
+      {kOfflineMsgOffsetColumnName, &m_offlineMsgOffsetColumnToken},
+      {kOfflineMsgSizeColumnName, &m_offlineMessageSizeColumnToken},
+  };
+
+  for (auto const& t : lookups) {
+    nsresult rv = mPort->StringToToken(mEnv, t.name, t.tok);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  // The table of all message hdrs will have table id 1.
+  struct mdbOid MsgHdrsTableOID;
+  MsgHdrsTableOID.mOid_Scope = m_hdrRowScopeToken;
+  MsgHdrsTableOID.mOid_Id = kAllMsgHdrsTableKey;
+  struct mdbOid ThreadsTableOID;
+  ThreadsTableOID.mOid_Scope = m_threadRowScopeToken;
+  ThreadsTableOID.mOid_Id = kAllThreadsTableKey;
+
+  {
+    nsresult rv = mPort->GetTable(mEnv, &MsgHdrsTableOID, &mAllMsgHeadersTable);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!mAllMsgHeadersTable) {
+      return NS_ERROR_NULL_POINTER;
+    }
+  }
+  return NS_OK;
+}
+
+static uint32_t hexToU32(nsACString const& val) {
+  uint32_t i;
+  if (PR_sscanf(PromiseFlatCString(val).get(), "%" PRIx32, &i) != 1) {
+    return 0;
+  }
+  return i;
+}
+static uint64_t hexToU64(nsACString const& val) {
+  int32_t i;
+  if (PR_sscanf(PromiseFlatCString(val).get(), "%" PRIx64, &i) != 1) {
+    return 0;
+  }
+  return i;
+}
+
+nsresult MSFSlurper::dumpum() {
+  PRTime start = PR_Now();
+
+  GlobalDB db;
+  nsresult rv = db.Init();
+  if (NS_FAILED(rv)) {
+    NS_WARNING("GlobalDB failed");
+  }
+
+  mdb_count nRows;
+  rv = mAllMsgHeadersTable->GetCount(mEnv, &nRows);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsTArray<RawHdr> batch;
+  auto flushBatch = [&]() -> nsresult {
+    if (batch.IsEmpty()) {
+      return NS_OK;
+    }
+    nsresult rv = db.StashMsgs(batch);
+    if (NS_FAILED(rv)) {
+      printf("Stash failed: %s\n", db.LastErr().get());
+    }
+    batch.Clear();
+    return rv;
+  };
+
+  for (mdb_pos rowpos = 0; rowpos < (mdb_pos)nRows; ++rowpos) {
+    nsCOMPtr<nsIMdbRow> row;
+    rv = mAllMsgHeadersTable->PosToRow(mEnv, rowpos, getter_AddRefs(row));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    mdb_count nCells;
+    rv = row->GetCount(mEnv, &nCells);
+    RawHdr msg;
+    for (mdb_pos cellpos = 0; cellpos < (mdb_pos)nCells; ++cellpos) {
+      mdb_token col;
+      rv = row->SeekCellYarn(mEnv, cellpos, &col, nullptr);
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      // Get the value
+      mdbYarn yarn;
+      rv = row->AliasCellYarn(mEnv, col, &yarn);
+      NS_ENSURE_SUCCESS(rv, rv);
+      auto v = Substring((const char*)yarn.mYarn_Buf,
+                         (const char*)yarn.mYarn_Buf + yarn.mYarn_Fill);
+
+      // column name
+      char columnName[100];
+      mdbYarn nameYarn = {columnName, 0, sizeof(columnName), 0, 0, nullptr};
+      mPort->TokenToString(mEnv, col, &nameYarn);
+      auto name =
+          Substring((const char*)nameYarn.mYarn_Buf,
+                    (const char*)nameYarn.mYarn_Buf + nameYarn.mYarn_Fill);
+
+      //      printf("  %d (%s): '%s'\n", (int)col,
+      //      PromiseFlatCString(name).get(),
+      //             PromiseFlatCString(v).get());
+
+      /*
+  136 (flags): '10'
+  130 (sender): 'brenda@example.com'
+  129 (subject): 'Triple-buffered non-volatile policy'
+  131 (message-id): '1669233094589031126'
+  132 (references): '<1669233094588824184>'
+  174 (dateReceived): '2b04662d'
+  134 (date): '2b04662d'
+  137 (priority): '1'
+  135 (size): '200'
+  139 (numLines): '6'
+  175 (storeToken): '2494920'
+  156 (msgOffset): '2611c8'
+  154 (threadParent): '177c'
+  142 (msgThreadId): '177c'
+  176 (ProtoThreadFlags): '0'
+      */
+      /*
+  136 (flags): '81'
+  194 (replyTo): '"Thunderbird Team" <team@discuss.thunderbird.net>'
+  130 (sender): 'Ping Chen <ping@thunderbird.net>'
+  133 (recipients): 'team@discuss.thunderbird.net'
+  129 (subject): '[tb-team] Re: Draft notes for Thunderbird 96.0 beta 1'
+  131 (message-id): '35e08091-f686-f6f3-7afb-155449078452@thunderbird.net'
+  132 (references): '<679c9492-76ac-b1c4-a527-dfaffd7ecb7b@thunderbird.net>'
+  190 (dateReceived): '61ae9ebb'
+  134 (date): '61ae9ebb'
+  137 (priority): '1'
+  135 (size): '7712'
+  191 (keywords): '$x-me-annot-2 nonjunk $ismailinglist'
+  155 (threadParent): '4334'
+  143 (msgThreadId): '4334'
+  192 (ProtoThreadFlags): '0'
+  197 (sender_name): '11|Ping Chen'
+  157 (msgOffset): 'bdbebb2'
+  199 (storeToken): '198962098'
+  158 (offlineMsgSize): '7719'
+  140 (numLines): '1f2'
+  196 (junkscore): '0'
+  212 (junkscoreorigin): 'plugin'
+  220 (junkpercent): '0'
+  138 (label): '0'
+  201 (gloda-dirty): '0'
+  200 (gloda-id): '4968'
+*/
+
+      if (name.EqualsLiteral("flags")) {
+        msg.flags = hexToU32(v);
+      } else if (name.EqualsLiteral("replyTo")) {
+        msg.replyTo = v;
+      } else if (name.EqualsLiteral("sender")) {
+        msg.sender = v;
+      } else if (name.EqualsLiteral("recipients")) {
+        msg.recipients = v;
+      } else if (name.EqualsLiteral("subject")) {
+        msg.subject = v;
+      } else if (name.EqualsLiteral("message-id")) {
+        msg.messageID = v;
+      } else if (name.EqualsLiteral("references")) {
+        msg.references = v;
+      } else if (name.EqualsLiteral("dateReceived")) {
+        msg.received = hexToU64(v);
+      } else if (name.EqualsLiteral("date")) {
+        msg.date = hexToU64(v);
+      } else if (name.EqualsLiteral("priority")) {
+        msg.priority = (int32_t)hexToU32(v);
+      } else if (name.EqualsLiteral("size")) {
+        msg.msgSize = hexToU64(v);
+      } else if (name.EqualsLiteral("keywords")) {
+        msg.keywords = v;
+      } else if (name.EqualsLiteral("threadParent")) {
+        // TODO
+      } else if (name.EqualsLiteral("msgThreadID")) {
+        // TODO
+      } else if (name.EqualsLiteral("ProtoThreadFlags")) {
+        msg.protoThreadFlags = (int)hexToU32(v);
+      } else if (name.EqualsLiteral("sender_name")) {
+        msg.senderName = v;
+      } else if (name.EqualsLiteral("msgOffset")) {
+        // IGNORE
+      } else if (name.EqualsLiteral("storeToken")) {
+        msg.storeToken = v;
+      } else if (name.EqualsLiteral("offlineMsgSize")) {
+        msg.offlineMsgSize = hexToU64(v);
+      } else if (name.EqualsLiteral("numLines")) {
+        msg.numLines = hexToU32(v);
+      } else if (name.EqualsLiteral("junkscore")) {
+        // ?
+      } else if (name.EqualsLiteral("junkscoreorigin")) {
+        msg.junkscoreorigin = v;
+      } else if (name.EqualsLiteral("junkpercent")) {
+        msg.junkpercent = v;
+      } else if (name.EqualsLiteral("label")) {
+        // ?
+      } else if (name.EqualsLiteral("gloda-dirty")) {
+        // ?
+      } else if (name.EqualsLiteral("gloda-id")) {
+        msg.glodaId = (int)hexToU32(v);
+      }
+
+      /*
+            if (col == m_subjectColumnToken) {
+              msg.subject = v;
+            } else if (col == m_senderColumnToken) {
+              msg.from = v;  // TODO: check
+            } else if (col == m_messageIdColumnToken) {
+              msg.messageID = v;
+            } else if (col == m_referencesColumnToken) {
+              msg.references = v;
+            } else if (col == m_recipientsColumnToken) {
+              msg.recipients = v;
+            } else if (col == m_dateColumnToken) {
+              // TODO
+            } else if (col == m_messageSizeColumnToken) {
+              // TODO        msg.msgSize = ;
+            } else if (col == m_flagsColumnToken) {
+              // TODO        msg.flags = ;
+            } else if (col == m_priorityColumnToken) {
+              // TODO
+            } else if (col == m_labelColumnToken) {
+              // TODO
+            } else if (col == m_numLinesColumnToken) {
+              // TODO
+            } else if (col == m_ccListColumnToken) {
+              msg.ccList = v;
+            } else if (col == m_bccListColumnToken) {
+              // TODO
+            } else if (col == m_messageThreadIdColumnToken) {
+              // TODO
+            } else if (col == m_offlineMessageSizeColumnToken) {
+              // TODO
+            }
+      */
+    }
+    batch.AppendElement(msg);
+    if ((batch.Length() >= 10000)) {
+      printf("flush (after row %d/%d)\n", (int)rowpos, (int)nRows);
+      rv = flushBatch();
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+  }
+
+  // Stash anything left over.
+  rv = flushBatch();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  PRInt64 elapsed = PR_Now() - start;
+  printf("DUMP complete: %d msgs in %.3f ms (%.3fus/msg)\n", (int)nRows,
+         (double)elapsed / 1000.0, (double)elapsed / (double)nRows);
+  return NS_OK;
+}
+
+nsresult msfDump(PathString msfPath) {
+  printf("+++++++++msfDump(%s)+++++++++++++++++\n", msfPath.get());
+
+  MSFSlurper slurper;
+  nsresult rv = slurper.Open(msfPath);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = slurper.dumpum();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  printf("++++++++++++++++++++++++++++++++++++++++++++\n");
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/moz.build b/mailnews/db/msgdb/src/moz.build
--- a/mailnews/db/msgdb/src/moz.build
+++ b/mailnews/db/msgdb/src/moz.build
@@ -1,20 +1,25 @@
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 SOURCES += [
+    "GlobalDB.cpp",
+    "MSFSlurp.cpp",
     "nsDBFolderInfo.cpp",
+    "nsDBFolderInfo2.cpp",
     "nsImapMailDatabase.cpp",
     "nsMailDatabase.cpp",
     "nsMsgDatabase.cpp",
+    "nsMsgDatabase2.cpp",
     "nsMsgDatabaseEnumerators.cpp",
     "nsMsgHdr.cpp",
+    "nsMsgHdr2.cpp",
     "nsMsgOfflineImapOperation.cpp",
     "nsMsgThread.cpp",
     "nsNewsDatabase.cpp",
 ]
 
 FINAL_LIBRARY = "mail"
 
 XPCOM_MANIFESTS += [
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
@@ -0,0 +1,343 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "msgCore.h"
+#include "nsDBFolderInfo2.h"
+#include "nsMsgDatabase2.h"
+#include "nsMsgFolderFlags.h"
+// #include "nsIPrefService.h"
+// #include "nsIPrefBranch.h"
+// #include "nsIPrefLocalizedString.h"
+// #include "nsIObserver.h"
+// #include "nsIObserverService.h"
+// #include "nsIMsgDBView.h"
+#include "nsServiceManagerUtils.h"
+#include "nsImapCore.h"
+
+NS_IMPL_ADDREF(nsDBFolderInfo2)
+NS_IMPL_RELEASE(nsDBFolderInfo2)
+
+NS_IMETHODIMP
+nsDBFolderInfo2::QueryInterface(REFNSIID iid, void** result) {
+  if (!result) return NS_ERROR_NULL_POINTER;
+
+  *result = nullptr;
+  if (iid.Equals(NS_GET_IID(nsIDBFolderInfo)) ||
+      iid.Equals(NS_GET_IID(nsISupports))) {
+    *result = static_cast<nsIDBFolderInfo*>(this);
+    AddRef();
+    return NS_OK;
+  }
+  return NS_NOINTERFACE;
+}
+
+nsDBFolderInfo2::nsDBFolderInfo2(nsMsgDatabase2* mdb)
+    : m_flags(0), m_expiredMark(0) {
+  m_version = 1;                 // for upgrading...
+  m_IMAPHierarchySeparator = 0;  // imap path separator
+  // mail only (for now)
+  m_folderSize = 0;
+  m_folderDate = 0;
+  m_expungedBytes = 0;  // sum of size of deleted messages in folder
+  m_highWaterMessageKey = 0;
+
+  m_numUnreadMessages = 0;
+  m_numMessages = 0;
+  // IMAP only
+  m_ImapUidValidity = kUidUnknown;
+  m_totalPendingMessages = 0;
+  m_unreadPendingMessages = 0;
+
+  m_mdb = mdb;
+}
+
+nsDBFolderInfo2::~nsDBFolderInfo2() {}
+
+nsresult nsDBFolderInfo2::InitFromExistingDB() {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetVersion(uint32_t version) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetVersion(uint32_t* version) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult nsDBFolderInfo2::AdjustHighWater(nsMsgKey highWater, bool force) {
+  if (force || m_highWaterMessageKey < highWater) {
+    m_highWaterMessageKey = highWater;
+    return NS_ERROR_NOT_IMPLEMENTED;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetHighWater(nsMsgKey highWater) {
+  return AdjustHighWater(highWater, true);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::OnKeyAdded(nsMsgKey aNewKey) {
+  return AdjustHighWater(aNewKey, false);
+}
+
+NS_IMETHODIMP
+nsDBFolderInfo2::GetFolderSize(int64_t* size) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetFolderSize(int64_t size) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsDBFolderInfo2::GetFolderDate(uint32_t* folderDate) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetFolderDate(uint32_t folderDate) {
+  m_folderDate = folderDate;
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetHighWater(nsMsgKey* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetExpiredMark(nsMsgKey expiredKey) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetExpiredMark(nsMsgKey* result) {
+  return NS_OK;
+}
+
+// The size of the argument depends on the maximum size of a single message
+NS_IMETHODIMP nsDBFolderInfo2::ChangeExpungedBytes(int32_t delta) {
+  return SetExpungedBytes(m_expungedBytes + delta);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetMailboxName(const nsAString& newBoxName) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetMailboxName(nsAString& boxName) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::ChangeNumUnreadMessages(int32_t delta) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::ChangeNumMessages(int32_t delta) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetNumUnreadMessages(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetNumUnreadMessages(int32_t numUnreadMessages) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetNumMessages(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetNumMessages(int32_t numMessages) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetExpungedBytes(int64_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetExpungedBytes(int64_t expungedBytes) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetFlags(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetFlags(int32_t flags) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::OrFlags(int32_t flags, int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::AndFlags(int32_t flags, int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetImapUidValidity(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetImapUidValidity(int32_t uidValidity) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+bool nsDBFolderInfo2::TestFlag(int32_t flags) { return (m_flags & flags) != 0; }
+
+NS_IMETHODIMP
+nsDBFolderInfo2::GetLocale(nsAString& result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetLocale(const nsAString& locale) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsDBFolderInfo2::GetImapTotalPendingMessages(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void nsDBFolderInfo2::ChangeImapTotalPendingMessages(int32_t delta) {
+  MOZ_ASSERT(false);
+}
+
+NS_IMETHODIMP
+nsDBFolderInfo2::GetImapUnreadPendingMessages(int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetImapUnreadPendingMessages(
+    int32_t numUnreadPendingMessages) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetImapTotalPendingMessages(
+    int32_t numTotalPendingMessages) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+void nsDBFolderInfo2::ChangeImapUnreadPendingMessages(int32_t delta) {
+  MOZ_ASSERT(false);
+}
+
+/* attribute nsMsgViewTypeValue viewType; */
+NS_IMETHODIMP nsDBFolderInfo2::GetViewType(nsMsgViewTypeValue* aViewType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP nsDBFolderInfo2::SetViewType(nsMsgViewTypeValue aViewType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute nsMsgViewFlagsTypeValue viewFlags; */
+NS_IMETHODIMP nsDBFolderInfo2::GetViewFlags(
+    nsMsgViewFlagsTypeValue* aViewFlags) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetViewFlags(
+    nsMsgViewFlagsTypeValue aViewFlags) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute nsMsgViewSortTypeValue sortType; */
+NS_IMETHODIMP nsDBFolderInfo2::GetSortType(nsMsgViewSortTypeValue* aSortType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetSortType(nsMsgViewSortTypeValue aSortType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute nsMsgViewSortOrderValue sortOrder; */
+NS_IMETHODIMP nsDBFolderInfo2::GetSortOrder(
+    nsMsgViewSortOrderValue* aSortOrder) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetSortOrder(
+    nsMsgViewSortOrderValue aSortOrder) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetKnownArtsSet(const char* newsArtSet) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetKnownArtsSet(char** newsArtSet) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetProperty(const char* propertyName,
+                                           const nsAString& propertyStr) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetProperty(const char* propertyName,
+                                           nsAString& resultProperty) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetCharProperty(
+    const char* aPropertyName, const nsACString& aPropertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetCharProperty(const char* propertyName,
+                                               nsACString& resultProperty) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetUint32Property(const char* propertyName,
+                                                 uint32_t propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetInt64Property(const char* propertyName,
+                                                int64_t propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetUint32Property(const char* propertyName,
+                                                 uint32_t defaultValue,
+                                                 uint32_t* propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetInt64Property(const char* propertyName,
+                                                int64_t defaultValue,
+                                                int64_t* propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetBooleanProperty(const char* propertyName,
+                                                  bool defaultValue,
+                                                  bool* propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetBooleanProperty(const char* propertyName,
+                                                  bool propertyValue) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetFolderName(nsACString& folderName) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetFolderName(const nsACString& folderName) {
+  return SetCharProperty("folderName", folderName);
+}
+
+/* void GetTransferInfo (out nsIDBFolderInfo transferInfo); */
+NS_IMETHODIMP nsDBFolderInfo2::GetTransferInfo(nsIDBFolderInfo** transferInfo) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* void InitFromTransferInfo (in nsIDBFolderInfo transferInfo); */
+NS_IMETHODIMP nsDBFolderInfo2::InitFromTransferInfo(
+    nsIDBFolderInfo* aTransferInfo) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.h b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
@@ -0,0 +1,84 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/* This class encapsulates the global information about a folder stored in the
+   summary file.
+*/
+#ifndef _nsDBFolderInfo2_H
+#define _nsDBFolderInfo2_H
+
+#include "nsString.h"
+#include "MailNewsTypes.h"
+#include "nsTArray.h"
+#include "nsIDBFolderInfo.h"
+#include <time.h>
+
+class nsMsgDatabase2;
+
+// again, this could inherit from nsISupports, but I don't see the need as of
+// yet. I'm not sure it needs to be ref-counted (but I think it does).
+
+class nsDBFolderInfo2 : public nsIDBFolderInfo {
+ public:
+  friend class nsMsgDatabase2;
+
+  explicit nsDBFolderInfo2(nsMsgDatabase2* mdb);
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDBFOLDERINFO
+
+  bool TestFlag(int32_t flags);
+  int16_t GetIMAPHierarchySeparator();
+  void SetIMAPHierarchySeparator(int16_t hierarchyDelimiter);
+  void ChangeImapTotalPendingMessages(int32_t delta);
+  void ChangeImapUnreadPendingMessages(int32_t delta);
+
+  nsresult InitFromExistingDB();
+
+  nsTArray<nsMsgKey> m_lateredKeys;  // list of latered messages
+
+ protected:
+  virtual ~nsDBFolderInfo2();
+
+  // initialize from appropriate table and row in existing db.
+  nsresult InitMDBInfo();
+  nsresult LoadMemberVariables();
+
+  nsresult AdjustHighWater(nsMsgKey highWater, bool force);
+
+  nsMsgDatabase2* m_mdb;
+
+  int64_t m_folderSize;
+  int64_t m_expungedBytes;  // sum of size of deleted messages in folder
+  uint32_t m_folderDate;
+  nsMsgKey m_highWaterMessageKey;  // largest news article number or imap uid
+                                   // whose header we've seen
+
+  //  m_numUnreadMessages and m_numMessages can never be negative. 0 means 'no
+  //  msgs'.
+  int32_t m_numUnreadMessages;
+  int32_t m_numMessages;  // includes expunged and ignored messages
+
+  int32_t m_flags;  // folder specific flags. This holds things like re-use
+                    // thread pane,
+  // configured for off-line use, use default retrieval, purge article/header
+  // options
+
+  uint16_t m_version;                // for upgrading...
+  int16_t m_IMAPHierarchySeparator;  // imap path separator
+
+  // mail only (for now)
+
+  // IMAP only
+  int32_t m_ImapUidValidity;
+  int32_t m_totalPendingMessages;
+  int32_t m_unreadPendingMessages;
+
+  // news only (for now)
+  // Highest invalid article number in group - for expiring
+  nsMsgKey m_expiredMark;
+};
+
+#endif
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -1130,16 +1130,25 @@ nsresult nsMsgDatabase::CheckForErrors(n
 }
 
 /**
  * Open the MDB database synchronously or async based on sync argument.
  * If successful, this routine will set up the m_mdbStore and m_mdbEnv of
  * the database object so other database calls can work.
  */
 nsresult nsMsgDatabase::OpenMDB(nsIFile* dbFile, bool create, bool sync) {
+  {
+    bool exists = false;
+    dbFile->Exists(&exists);
+    if (exists) {
+      extern nsresult msfDump(PathString msfPath);
+      msfDump(dbFile->NativePath());
+    }
+  }
+
   nsCOMPtr<nsIMdbFactory> mdbFactory;
   nsresult ret = GetMDBFactory(getter_AddRefs(mdbFactory));
   NS_ENSURE_SUCCESS(ret, ret);
 
   ret = mdbFactory->MakeEnv(NULL, &m_mdbEnv);
   if (NS_SUCCEEDED(ret)) {
     nsIMdbHeap* dbHeap = nullptr;
 
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -0,0 +1,1010 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+// this file implements the nsMsgDatabase2 interface using the MDB Interface.
+
+#include "nscore.h"
+#include "msgCore.h"
+#include "nsMsgDatabase2.h"
+#include "GlobalDB.h"
+// #include "nsIFile.h"
+// #include "nsMailDatabase.h"
+#include "nsDBFolderInfo2.h"
+// #include "nsIMsgNewsFolder.h"
+#include "nsMsgThread.h"
+#include "nsIMsgSearchTerm.h"
+#include "nsIDBChangeListener.h"
+// #include "nsIMdbFactoryFactory.h"
+#include "mozilla/Logging.h"
+#include "mozilla/Telemetry.h"
+#include "prprf.h"
+#include "nsMsgFolderFlags.h"
+// #include "nsIMsgAccountManager.h"
+#include "nsIMsgDBView.h"  // for nsMsgViewFlagsType
+// #include "nsIMsgFolderCache.h"
+// #include "nsIMsgFolderCacheElement.h"
+#include "MailNewsTypes2.h"
+#include "nsMsgUtils.h"
+// #include "nsComponentManagerUtils.h"
+// #include "nsServiceManagerUtils.h"
+#include "nsMemory.h"
+#include "nsIPrefService.h"
+#include "nsIPrefBranch.h"
+// #include "nsMsgDatabaseEnumerators.h"
+// #include "nsIMemoryReporter.h"
+// #include "nsIWeakReferenceUtils.h"
+// #include "nsMailDirServiceDefs.h"
+#include "mozilla/Components.h"
+#include "mozilla/mailnews/MimeHeaderParser.h"
+#include "mozilla/intl/LocaleService.h"
+
+using namespace mozilla::mailnews;
+using namespace mozilla;
+
+#if defined(DEBUG_sspitzer_) || defined(DEBUG_seth_)
+#  define DEBUG_MSGKEYSET 1
+#endif
+
+// special keys
+// static const nsMsgKey kAllMsgHdrsTableKey = 1;
+// static const nsMsgKey kTableKeyForThreadOne = 0xfffffffe;
+// static const nsMsgKey kAllThreadsTableKey = 0xfffffffd;
+static const nsMsgKey kFirstPseudoKey = 0xfffffff0;
+// static const nsMsgKey kIdStartOfFake = 0xffffff80;
+// static const nsMsgKey kForceReparseKey = 0xfffffff0;
+
+// LazyLogModule DBLog("MsgDB"); // just use original one for now...
+
+static bool gGotGlobalPrefs = false;
+static bool gThreadWithoutRe = true;
+static bool gStrictThreading = false;
+static bool gCorrectThreading = false;
+
+// static
+PRTime nsMsgDatabase2::sLastUseTime;
+
+void nsMsgDatabase2::GetGlobalPrefs() {
+  if (!gGotGlobalPrefs) {
+    GetBoolPref("mail.thread_without_re", &gThreadWithoutRe);
+    GetBoolPref("mail.strict_threading", &gStrictThreading);
+    GetBoolPref("mail.correct_threading", &gCorrectThreading);
+    gGotGlobalPrefs = true;
+  }
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ForceClosed() { return NS_ERROR_NOT_IMPLEMENTED; }
+
+NS_IMETHODIMP nsMsgDatabase2::ClearCachedHdrs() {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetMsgHdrCacheSize(uint32_t aSize) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrCacheSize(uint32_t* aSize) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetLastUseTime(PRTime* aTime) {
+  NS_ENSURE_ARG_POINTER(aTime);
+  *aTime = m_lastUseTime;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetLastUseTime(PRTime aTime) {
+  sLastUseTime = m_lastUseTime = aTime;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetDatabaseSize(int64_t* _retval) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
+  NS_ENSURE_ARG_POINTER(result);
+
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
+  msgHdr.forget(result);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::AddListener(nsIDBChangeListener* aListener) {
+  NS_ENSURE_ARG_POINTER(aListener);
+  m_ChangeListeners.AppendElementUnlessExists(aListener);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::RemoveListener(nsIDBChangeListener* aListener) {
+  NS_ENSURE_ARG_POINTER(aListener);
+  m_ChangeListeners.RemoveElement(aListener);
+  return NS_OK;
+}
+
+// XXX should we return rv for listener->propertyfunc_?
+#define NOTIFY_LISTENERS(propertyfunc_, params_)                         \
+  PR_BEGIN_MACRO                                                         \
+  nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator iter( \
+      m_ChangeListeners);                                                \
+  nsCOMPtr<nsIDBChangeListener> listener;                                \
+  while (iter.HasMore()) {                                               \
+    listener = iter.GetNext();                                           \
+    listener->propertyfunc_ params_;                                     \
+  }                                                                      \
+  PR_END_MACRO
+
+// change announcer methods - just broadcast to all listeners.
+NS_IMETHODIMP nsMsgDatabase2::NotifyHdrChangeAll(
+    nsIMsgDBHdr* aHdrChanged, uint32_t aOldFlags, uint32_t aNewFlags,
+    nsIDBChangeListener* aInstigator) {
+  // We will only notify the change if the header exists in the database.
+  // This allows database functions to be usable in both the case where the
+  // header is in the db, or the header is not so no notifications should be
+  // given.
+  nsMsgKey key;
+  bool inDb = false;
+  if (aHdrChanged) {
+    aHdrChanged->GetMessageKey(&key);
+    ContainsKey(key, &inDb);
+  }
+  if (inDb)
+    NOTIFY_LISTENERS(OnHdrFlagsChanged,
+                     (aHdrChanged, aOldFlags, aNewFlags, aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyReadChanged(
+    nsIDBChangeListener* aInstigator) {
+  NOTIFY_LISTENERS(OnReadChanged, (aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyJunkScoreChanged(
+    nsIDBChangeListener* aInstigator) {
+  NOTIFY_LISTENERS(OnJunkScoreChanged, (aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyHdrDeletedAll(
+    nsIMsgDBHdr* aHdrDeleted, nsMsgKey aParentKey, int32_t aFlags,
+    nsIDBChangeListener* aInstigator) {
+  NOTIFY_LISTENERS(OnHdrDeleted,
+                   (aHdrDeleted, aParentKey, aFlags, aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyHdrAddedAll(
+    nsIMsgDBHdr* aHdrAdded, nsMsgKey aParentKey, int32_t aFlags,
+    nsIDBChangeListener* aInstigator) {
+#ifdef DEBUG_bienvenu1
+  printf("notifying add of %ld parent %ld\n", keyAdded, parentKey);
+#endif
+  NOTIFY_LISTENERS(OnHdrAdded, (aHdrAdded, aParentKey, aFlags, aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyParentChangedAll(
+    nsMsgKey aKeyReparented, nsMsgKey aOldParent, nsMsgKey aNewParent,
+    nsIDBChangeListener* aInstigator) {
+  NOTIFY_LISTENERS(OnParentChanged,
+                   (aKeyReparented, aOldParent, aNewParent, aInstigator));
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::NotifyAnnouncerGoingAway(void) {
+  NOTIFY_LISTENERS(OnAnnouncerGoingAway, (this));
+  return NS_OK;
+}
+
+nsMsgDatabase2::nsMsgDatabase2()
+    : m_dbFolderInfo(nullptr), m_nextPseudoMsgKey(kFirstPseudoKey) {}
+
+nsMsgDatabase2::~nsMsgDatabase2() {
+  m_dbFolderInfo = nullptr;
+  m_ChangeListeners.Clear();
+}
+
+NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIDBChangeAnnouncer)
+
+NS_IMETHODIMP nsMsgDatabase2::GetDBFolderInfo(nsIDBFolderInfo** result) {
+  if (!m_dbFolderInfo) {
+    NS_ERROR("db must be corrupt");
+    return NS_ERROR_NULL_POINTER;
+  }
+  NS_ADDREF(*result = m_dbFolderInfo);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetFolder(nsIMsgFolder** aFolder) {
+  NS_ENSURE_ARG_POINTER(aFolder);
+  NS_IF_ADDREF(*aFolder = m_folder);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::Commit(nsMsgDBCommit commitType) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::Close(bool forceCommit /* = TRUE */) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// Returns if the db contains this key
+NS_IMETHODIMP nsMsgDatabase2::ContainsKey(nsMsgKey key, bool* containsKey) {
+  return DB().FolderContainsKey(mFolderID, key, containsKey);
+}
+
+// get a message header for the given key. Caller must release()!
+NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForKey(nsMsgKey key,
+                                              nsIMsgDBHdr** pmsgHdr) {
+  // NOTE: old version creates row in DB if it doesn't exist...
+  // That seems like a no-no now.
+  return DB().FolderGetMsgHdrForKey(mFolderID, key, pmsgHdr);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::DeleteMessage(nsMsgKey key,
+                                            nsIDBChangeListener* instigator,
+                                            bool commit) {
+  nsCOMPtr<nsIMsgDBHdr> msgHdr;
+
+  nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
+  if (!msgHdr) return NS_MSG_MESSAGE_NOT_FOUND;
+
+  rv = DeleteHeader(msgHdr, instigator, commit, true);
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::DeleteMessages(
+    nsTArray<nsMsgKey> const& nsMsgKeys, nsIDBChangeListener* instigator) {
+  nsresult err = NS_OK;
+
+  uint32_t kindex;
+  for (kindex = 0; kindex < nsMsgKeys.Length(); kindex++) {
+    nsMsgKey key = nsMsgKeys[kindex];
+    nsCOMPtr<nsIMsgDBHdr> msgHdr;
+
+    bool hasKey;
+
+    if (NS_SUCCEEDED(ContainsKey(key, &hasKey)) && hasKey) {
+      err = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
+      if (NS_FAILED(err)) {
+        err = NS_MSG_MESSAGE_NOT_FOUND;
+        break;
+      }
+      if (msgHdr)
+        err = DeleteHeader(msgHdr, instigator, kindex % 300 == 0, true);
+      if (NS_FAILED(err)) break;
+    }
+  }
+  return err;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::DeleteHeader(nsIMsgDBHdr* msg,
+                                           nsIDBChangeListener* instigator,
+                                           bool commit, bool notify) {
+  nsMsgKey key;
+  nsresult rv = msg->GetMessageKey(&key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return DB().FolderDeleteHeader(mFolderID, key, instigator, commit, notify);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::UndoDelete(nsIMsgDBHdr* aMsgHdr) {
+  nsMsgKey key;
+  nsresult rv = aMsgHdr->GetMessageKey(&key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return DB().FolderUndoDelete(mFolderID, key);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::RemoveHeaderMdbRow(nsIMsgDBHdr* msg) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::IsRead(nsMsgKey key, bool* isRead) {
+  return DB().FetchMsgIsRead(key, isRead);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::IsMarked(nsMsgKey key, bool* isMarked) {
+  return DB().FetchMsgIsRead(key, isMarked);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::IsIgnored(nsMsgKey key, bool* isIgnored) {
+  return DB().FetchMsgIsRead(key, isIgnored);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::IsWatched(nsMsgKey key, bool* isWatched) {
+  return DB().FetchMsgIsWatched(key, isWatched);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::HasAttachments(nsMsgKey key,
+                                             bool* hasAttachments) {
+  return DB().FetchMsgHasAttachments(key, hasAttachments);
+}
+
+nsresult nsMsgDatabase2::MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool isRead,
+                                         nsIDBChangeListener* instigator) {
+  nsMsgKey key;
+  nsresult rv = msgHdr->GetMessageKey(&key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return DB().MarkMsgRead(key, isRead, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkRead(nsMsgKey key, bool isRead,
+                                       nsIDBChangeListener* instigator) {
+  return DB().MarkMsgRead(key, isRead, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkReplied(
+    nsMsgKey key, bool bReplied, nsIDBChangeListener* instigator /* = NULL */) {
+  return DB().SetMsgFlag(key, bReplied, nsMsgMessageFlags::Replied, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkForwarded(
+    nsMsgKey key, bool bForwarded,
+    nsIDBChangeListener* instigator /* = NULL */) {
+  return DB().SetMsgFlag(key, bForwarded, nsMsgMessageFlags::Forwarded,
+                         instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkRedirected(
+    nsMsgKey key, bool bRedirected,
+    nsIDBChangeListener* instigator /* = NULL */) {
+  return DB().SetMsgFlag(key, bRedirected, nsMsgMessageFlags::Redirected,
+                         instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkHasAttachments(
+    nsMsgKey key, bool bHasAttachments, nsIDBChangeListener* instigator) {
+  return DB().SetMsgFlag(key, bHasAttachments, nsMsgMessageFlags::Attachment,
+                         instigator);
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::MarkThreadRead(nsIMsgThread* thread,
+                               nsIDBChangeListener* instigator,
+                               nsTArray<nsMsgKey>& aThoseMarkedRead) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::MarkThreadIgnored(nsIMsgThread* thread, nsMsgKey threadKey,
+                                  bool bIgnored,
+                                  nsIDBChangeListener* instigator) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::MarkHeaderKilled(nsIMsgDBHdr* msg, bool bIgnored,
+                                 nsIDBChangeListener* instigator) {
+  uint32_t msgFlags;
+  msg->GetFlags(&msgFlags);
+  uint32_t oldFlags = msgFlags;
+  if (bIgnored)
+    msgFlags |= nsMsgMessageFlags::Ignored;
+  else
+    msgFlags &= ~nsMsgMessageFlags::Ignored;
+  msg->SetFlags(msgFlags);
+
+  return NotifyHdrChangeAll(msg, oldFlags, msgFlags, instigator);
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::MarkThreadWatched(nsIMsgThread* thread, nsMsgKey threadKey,
+                                  bool bWatched,
+                                  nsIDBChangeListener* instigator) {
+  NS_ENSURE_ARG(thread);
+  uint32_t threadFlags;
+  thread->GetFlags(&threadFlags);
+  uint32_t oldThreadFlags =
+      threadFlags;  // not quite right, since we probably want msg hdr flags.
+  if (bWatched) {
+    threadFlags |= nsMsgMessageFlags::Watched;
+    threadFlags &= ~nsMsgMessageFlags::Ignored;  // watch is implicit un-ignore
+  } else
+    threadFlags &= ~nsMsgMessageFlags::Watched;
+
+  nsCOMPtr<nsIMsgDBHdr> msg;
+  GetMsgHdrForKey(threadKey, getter_AddRefs(msg));
+
+  nsresult rv =
+      NotifyHdrChangeAll(msg, oldThreadFlags, threadFlags, instigator);
+  thread->SetFlags(threadFlags);
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkMarked(nsMsgKey key, bool mark,
+                                         nsIDBChangeListener* instigator) {
+  return DB().SetMsgFlag(key, mark, nsMsgMessageFlags::Marked, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkOffline(nsMsgKey key, bool offline,
+                                          nsIDBChangeListener* instigator) {
+  return DB().SetMsgFlag(key, offline, nsMsgMessageFlags::Offline, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetStringProperty(nsMsgKey aKey,
+                                                const char* aProperty,
+                                                const char* aValue) {
+  nsCOMPtr<nsIMsgDBHdr> msgHdr;
+  nsresult rv = GetMsgHdrForKey(aKey, getter_AddRefs(msgHdr));
+  if (NS_FAILED(rv) || !msgHdr)
+    return NS_MSG_MESSAGE_NOT_FOUND;  // XXX return rv?
+  return SetStringPropertyByHdr(msgHdr, aProperty, aValue);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetStringPropertyByHdr(nsIMsgDBHdr* msgHdr,
+                                                     const char* aProperty,
+                                                     const char* aValue) {
+  // don't do notifications if message not yet added to database.
+  // Ignore errors (consequences of failure are minor).
+  bool notify = true;
+  nsMsgKey key = nsMsgKey_None;
+  msgHdr->GetMessageKey(&key);
+  ContainsKey(key, &notify);
+
+  nsCString oldValue;
+  nsresult rv = msgHdr->GetStringProperty(aProperty, getter_Copies(oldValue));
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // if no change to this string property, bail out
+  if (oldValue.Equals(aValue)) return NS_OK;
+
+  // Precall OnHdrPropertyChanged to store prechange status
+  nsTArray<uint32_t> statusArray(m_ChangeListeners.Length());
+  nsCOMPtr<nsIDBChangeListener> listener;
+  if (notify) {
+    nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator listeners(
+        m_ChangeListeners);
+    while (listeners.HasMore()) {
+      listener = listeners.GetNext();
+      // initialize |status| because some implementations of
+      // OnHdrPropertyChanged does not set the value.
+      uint32_t status = 0;
+      (void)listener->OnHdrPropertyChanged(msgHdr, nsCString(aProperty), true,
+                                           &status, nullptr);
+      // ignore errors, but append element to keep arrays in sync
+      statusArray.AppendElement(status);
+    }
+  }
+
+  rv = msgHdr->SetStringProperty(aProperty, aValue);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Postcall OnHdrPropertyChanged to process the change
+  if (notify) {
+    // if this is the junk score property notify, as long as we're not going
+    // from no value to non junk
+    if (!strcmp(aProperty, "junkscore") &&
+        !(oldValue.IsEmpty() && !strcmp(aValue, "0")))
+      NotifyJunkScoreChanged(nullptr);
+
+    nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator listeners(
+        m_ChangeListeners);
+    for (uint32_t i = 0; listeners.HasMore(); i++) {
+      listener = listeners.GetNext();
+      uint32_t status = statusArray[i];
+      (void)listener->OnHdrPropertyChanged(msgHdr, nsCString(aProperty), false,
+                                           &status, nullptr);
+      // ignore errors
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::SetUint32PropertyByHdr(nsIMsgDBHdr* aMsgHdr,
+                                       const char* aProperty, uint32_t aValue) {
+  // If no change to this property, bail out.
+  uint32_t oldValue;
+  nsresult rv = aMsgHdr->GetUint32Property(aProperty, &oldValue);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (oldValue == aValue) return NS_OK;
+
+  // Don't do notifications if message not yet added to database.
+  bool notify = true;
+  nsMsgKey key = nsMsgKey_None;
+  aMsgHdr->GetMessageKey(&key);
+  ContainsKey(key, &notify);
+
+  // Precall OnHdrPropertyChanged to store prechange status.
+  nsTArray<uint32_t> statusArray(m_ChangeListeners.Length());
+  nsCOMPtr<nsIDBChangeListener> listener;
+  if (notify) {
+    nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator listeners(
+        m_ChangeListeners);
+    while (listeners.HasMore()) {
+      listener = listeners.GetNext();
+      // initialize |status| because some implementations of
+      // OnHdrPropertyChanged does not set the value.
+      uint32_t status = 0;
+      (void)listener->OnHdrPropertyChanged(aMsgHdr, nsCString(aProperty), true,
+                                           &status, nullptr);
+      // Ignore errors, but append element to keep arrays in sync.
+      statusArray.AppendElement(status);
+    }
+  }
+
+  rv = aMsgHdr->SetUint32Property(aProperty, aValue);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Postcall OnHdrPropertyChanged to process the change.
+  if (notify) {
+    nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator listeners(
+        m_ChangeListeners);
+    for (uint32_t i = 0; listeners.HasMore(); i++) {
+      listener = listeners.GetNext();
+      uint32_t status = statusArray[i];
+      (void)listener->OnHdrPropertyChanged(aMsgHdr, nsCString(aProperty), false,
+                                           &status, nullptr);
+      // Ignore errors.
+    }
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkImapDeleted(nsMsgKey key, bool deleted,
+                                              nsIDBChangeListener* instigator) {
+  return DB().SetMsgFlag(key, deleted, nsMsgMessageFlags::IMAPDeleted,
+                         instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkMDNNeeded(
+    nsMsgKey key, bool bNeeded, nsIDBChangeListener* instigator /* = NULL */) {
+  return DB().SetMsgFlag(key, bNeeded, nsMsgMessageFlags::MDNReportNeeded,
+                         instigator);
+}
+
+nsresult nsMsgDatabase2::MarkMDNSent(
+    nsMsgKey key, bool bSent, nsIDBChangeListener* instigator /* = NULL */) {
+  return DB().SetMsgFlag(key, bSent, nsMsgMessageFlags::MDNReportSent,
+                         instigator);
+}
+
+nsresult nsMsgDatabase2::IsMDNSent(nsMsgKey key, bool* pSent) {
+  nsCOMPtr<nsIMsgDBHdr> msgHdr;
+
+  nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
+  if (NS_FAILED(rv) || !msgHdr)
+    return NS_MSG_MESSAGE_NOT_FOUND;  // XXX return rv?
+
+  uint32_t flags;
+  (void)msgHdr->GetFlags(&flags);
+  *pSent = !!(flags & nsMsgMessageFlags::MDNReportSent);
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkHdrRead(nsIMsgDBHdr* msgHdr, bool bRead,
+                                          nsIDBChangeListener* instigator) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkHdrReplied(nsIMsgDBHdr* msgHdr, bool bReplied,
+                                             nsIDBChangeListener* instigator) {
+  nsMsgKey key;
+  msgHdr->GetMessageKey(&key);
+  return DB().SetMsgFlag(key, bReplied, nsMsgMessageFlags::Replied, instigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkHdrMarked(nsIMsgDBHdr* msgHdr, bool mark,
+                                            nsIDBChangeListener* instigator) {
+  nsMsgKey key;
+  msgHdr->GetMessageKey(&key);
+  return DB().SetMsgFlag(key, mark, nsMsgMessageFlags::Marked, instigator);
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::MarkHdrNotNew(nsIMsgDBHdr* msgHdr,
+                              nsIDBChangeListener* aInstigator) {
+  nsMsgKey key;
+  msgHdr->GetMessageKey(&key);
+  return DB().SetMsgFlag(key, false, nsMsgMessageFlags::New, aInstigator);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::MarkAllRead(nsTArray<nsMsgKey>& aThoseMarked) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::AddToNewList(nsMsgKey key) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ClearNewList(bool notify /* = FALSE */) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+}
+
+NS_IMETHODIMP nsMsgDatabase2::HasNew(bool* _retval) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetFirstNew(nsMsgKey* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::EnumerateMessages(nsIMsgEnumerator** result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::ReverseEnumerateMessages(nsIMsgEnumerator** result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::GetFilterEnumerator(
+    const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
+    nsIMsgEnumerator** aResult) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::SyncCounts() {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
+                                                   uint32_t* pFlag) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key,
+                                           nsIMsgDBHdr** pnewHdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::CopyHdrFromExistingHdr(nsMsgKey key,
+                                                     nsIMsgDBHdr* existingHdr,
+                                                     bool addHdrToDB,
+                                                     nsIMsgDBHdr** newHdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::CompareCollationKeys(const nsTArray<uint8_t>& key1,
+                                     const nsTArray<uint8_t>& key2,
+                                     int32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::CreateCollationKey(const nsAString& sourceString,
+                                   nsTArray<uint8_t>& key) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+uint32_t nsMsgDatabase2::GetCurVersion() { return kMsgDBVersion; }
+
+NS_IMETHODIMP nsMsgDatabase2::SetSummaryValid(bool valid /* = true */) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetSummaryValid(bool* aResult) {
+  NS_ENSURE_ARG_POINTER(aResult);
+  *aResult = true;
+  return NS_OK;
+}
+
+// protected routines
+
+// should we thread messages with common subjects that don't start with Re:
+// together? I imagine we might have separate preferences for mail and news, so
+// this is a virtual method.
+bool nsMsgDatabase2::ThreadBySubjectWithoutRe() {
+  GetGlobalPrefs();
+  return gThreadWithoutRe;
+}
+
+bool nsMsgDatabase2::UseStrictThreading() {
+  GetGlobalPrefs();
+  return gStrictThreading;
+}
+
+// Should we make sure messages are always threaded correctly (see bug 181446)
+bool nsMsgDatabase2::UseCorrectThreading() {
+  GetGlobalPrefs();
+  return gCorrectThreading;
+}
+
+nsresult nsMsgDatabase2::CreateNewThread(nsMsgKey threadId, const char* subject,
+                                         nsMsgThread** pnewThread) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+nsIMsgThread* nsMsgDatabase2::GetThreadForSubject(nsCString& subject) {
+  MOZ_ASSERT(false);
+  return nullptr;  // TODO
+}
+
+// Returns thread that contains a message that references the passed message ID
+nsIMsgThread* nsMsgDatabase2::GetThreadForMessageId(nsCString& msgId) {
+  MOZ_ASSERT(false);
+  return nullptr;
+}
+
+nsMsgHdr2* nsMsgDatabase2::GetMsgHdrForReference(nsCString& reference) {
+  MOZ_ASSERT(false);
+  return nullptr;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForMessageID(const char* aMsgID,
+                                                    nsIMsgDBHdr** aHdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForGMMsgID(const char* aGMMsgId,
+                                                  nsIMsgDBHdr** aHdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetThreadContainingMsgHdr(nsIMsgDBHdr* msgHdr,
+                                                        nsIMsgThread** result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult nsMsgDatabase2::GetThreadForMsgKey(nsMsgKey msgKey,
+                                            nsIMsgThread** aResult) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+// caller needs to unrefer.
+nsIMsgThread* nsMsgDatabase2::GetThreadForThreadId(nsMsgKey threadId) {
+  MOZ_ASSERT(false);
+  return nullptr;
+}
+
+nsresult nsMsgDatabase2::GetBoolPref(const char* prefName, bool* result) {
+  bool prefValue = false;
+  nsresult rv;
+  nsCOMPtr<nsIPrefBranch> pPrefBranch(
+      do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
+  if (pPrefBranch) {
+    rv = pPrefBranch->GetBoolPref(prefName, &prefValue);
+    *result = prefValue;
+  }
+  return rv;
+}
+
+nsresult nsMsgDatabase2::GetIntPref(const char* prefName, int32_t* result) {
+  int32_t prefValue = 0;
+  nsresult rv;
+  nsCOMPtr<nsIPrefBranch> pPrefBranch(
+      do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
+  if (pPrefBranch) {
+    rv = pPrefBranch->GetIntPref(prefName, &prefValue);
+    *result = prefValue;
+  }
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetAttributeOnPendingHdr(
+    nsIMsgDBHdr* pendingHdr, const char* property, const char* propertyVal) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetUint32AttributeOnPendingHdr(
+    nsIMsgDBHdr* pendingHdr, const char* property, uint32_t propertyVal) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::SetUint64AttributeOnPendingHdr(nsIMsgDBHdr* aPendingHdr,
+                                               const char* aProperty,
+                                               uint64_t aPropertyVal) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::UpdatePendingAttributes(nsIMsgDBHdr* aNewHdr) { return NS_OK; }
+
+NS_IMETHODIMP nsMsgDatabase2::ListAllOfflineMsgs(nsTArray<nsMsgKey>& keys) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetHighWaterArticleNum(nsMsgKey* key) {
+  if (!m_dbFolderInfo) return NS_ERROR_NULL_POINTER;
+  return m_dbFolderInfo->GetHighWater(key);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetLowWaterArticleNum(nsMsgKey* key) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* attribute nsMsgKey NextPseudoMsgKey */
+
+NS_IMETHODIMP nsMsgDatabase2::GetNextPseudoMsgKey(nsMsgKey* nextPseudoMsgKey) {
+  NS_ENSURE_ARG_POINTER(nextPseudoMsgKey);
+  *nextPseudoMsgKey = m_nextPseudoMsgKey--;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetNextPseudoMsgKey(nsMsgKey nextPseudoMsgKey) {
+  m_nextPseudoMsgKey = nextPseudoMsgKey;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetNextFakeOfflineMsgKey(
+    nsMsgKey* nextFakeOfflineMsgKey) {
+  // TODO: Don't think we should be encouraging this kind of thing...
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+#ifdef DEBUG
+nsresult nsMsgDatabase2::DumpContents() {
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = ListAllKeys(keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  for (nsMsgKey key : keys) {
+    nsCOMPtr<nsIMsgDBHdr> msgHdr;
+    rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
+    if (NS_SUCCEEDED(rv)) {
+      nsCString author;
+      nsCString subject;
+
+      msgHdr->GetMessageKey(&key);
+      msgHdr->GetAuthor(getter_Copies(author));
+      msgHdr->GetSubject(getter_Copies(subject));
+      printf("hdr key = %u, author = %s subject = %s\n", key, author.get(),
+             subject.get());
+    }
+  }
+#  if 0
+  nsCOMPtr<nsIMsgThreadEnumerator> threads;
+  rv = EnumerateThreads(getter_AddRefs(threads));
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool hasMore = false;
+  while (NS_SUCCEEDED(rv = threads->HasMoreElements(&hasMore)) && hasMore) {
+    nsCOMPtr<nsIMsgThread> thread;
+    rv = threads->GetNext(getter_AddRefs(thread));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    nsMsgKey key;
+    thread->GetThreadKey(&key);
+    printf("thread key = %u\n", key);
+    // DumpThread(key);
+  }
+#  endif
+  return NS_OK;
+}
+#endif /* DEBUG */
+
+NS_IMETHODIMP nsMsgDatabase2::SetMsgRetentionSettings(
+    nsIMsgRetentionSettings* retentionSettings) {
+  m_retentionSettings = retentionSettings;
+  if (retentionSettings && m_dbFolderInfo) {
+    nsresult rv;
+
+    nsMsgRetainByPreference retainByPreference;
+    uint32_t daysToKeepHdrs;
+    uint32_t numHeadersToKeep;
+    uint32_t daysToKeepBodies;
+    bool cleanupBodiesByDays;
+    bool useServerDefaults;
+    bool applyToFlaggedMessages;
+
+    rv = retentionSettings->GetRetainByPreference(&retainByPreference);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = retentionSettings->GetDaysToKeepHdrs(&daysToKeepHdrs);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = retentionSettings->GetNumHeadersToKeep(&numHeadersToKeep);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = retentionSettings->GetDaysToKeepBodies(&daysToKeepBodies);
+    NS_ENSURE_SUCCESS(rv, rv);
+    (void)retentionSettings->GetCleanupBodiesByDays(&cleanupBodiesByDays);
+    (void)retentionSettings->GetUseServerDefaults(&useServerDefaults);
+    rv = retentionSettings->GetApplyToFlaggedMessages(&applyToFlaggedMessages);
+    NS_ENSURE_SUCCESS(rv, rv);
+    // need to write this to the db. We'll just use the dbfolderinfo to write
+    // properties.
+    m_dbFolderInfo->SetUint32Property("retainBy", retainByPreference);
+    m_dbFolderInfo->SetUint32Property("daysToKeepHdrs", daysToKeepHdrs);
+    m_dbFolderInfo->SetUint32Property("numHdrsToKeep", numHeadersToKeep);
+    m_dbFolderInfo->SetUint32Property("daysToKeepBodies", daysToKeepBodies);
+    m_dbFolderInfo->SetBooleanProperty("cleanupBodies", cleanupBodiesByDays);
+    m_dbFolderInfo->SetBooleanProperty("useServerDefaults", useServerDefaults);
+    m_dbFolderInfo->SetBooleanProperty("applyToFlaggedMessages",
+                                       applyToFlaggedMessages);
+  }
+  Commit(nsMsgDBCommitType::kLargeCommit);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgRetentionSettings(
+    nsIMsgRetentionSettings** retentionSettings) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::SetMsgDownloadSettings(
+    nsIMsgDownloadSettings* downloadSettings) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgDownloadSettings(
+    nsIMsgDownloadSettings** downloadSettings) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ApplyRetentionSettings(
+    nsIMsgRetentionSettings* aMsgRetentionSettings, bool aDeleteViaFolder) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetDefaultViewFlags(
+    nsMsgViewFlagsTypeValue* aDefaultViewFlags) {
+  NS_ENSURE_ARG_POINTER(aDefaultViewFlags);
+  GetIntPref("mailnews.default_view_flags", aDefaultViewFlags);
+  if (*aDefaultViewFlags < nsMsgViewFlagsType::kNone ||
+      *aDefaultViewFlags >
+          (nsMsgViewFlagsType::kThreadedDisplay |
+           nsMsgViewFlagsType::kShowIgnored | nsMsgViewFlagsType::kUnreadOnly |
+           nsMsgViewFlagsType::kExpandAll | nsMsgViewFlagsType::kGroupBySort))
+    *aDefaultViewFlags = nsMsgViewFlagsType::kNone;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetDefaultSortType(
+    nsMsgViewSortTypeValue* aDefaultSortType) {
+  NS_ENSURE_ARG_POINTER(aDefaultSortType);
+  GetIntPref("mailnews.default_sort_type", aDefaultSortType);
+  if (*aDefaultSortType < nsMsgViewSortType::byDate ||
+      *aDefaultSortType > nsMsgViewSortType::byAccount)
+    *aDefaultSortType = nsMsgViewSortType::byDate;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetDefaultSortOrder(
+    nsMsgViewSortOrderValue* aDefaultSortOrder) {
+  NS_ENSURE_ARG_POINTER(aDefaultSortOrder);
+  GetIntPref("mailnews.default_sort_order", aDefaultSortOrder);
+  if (*aDefaultSortOrder != nsMsgViewSortOrder::descending)
+    *aDefaultSortOrder = nsMsgViewSortOrder::ascending;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ResetHdrCacheSize(uint32_t aSize) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::GetNewList(nsTArray<nsMsgKey>& aNewKeys) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::GetCachedHits(const nsACString& aSearchFolderUri,
+                              nsIMsgEnumerator** aEnumerator) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::RefreshCache(const nsACString& aSearchFolderUri,
+                                           nsTArray<nsMsgKey> const& aNewHits,
+                                           nsTArray<nsMsgKey>& aStaleHits) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::UpdateHdrInCache(const nsACString& aSearchFolderUri,
+                                 nsIMsgDBHdr* aHdr, bool aAdd) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::HdrIsInCache(const nsACString& aSearchFolderUri,
+                             nsIMsgDBHdr* aHdr, bool* aResult) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -0,0 +1,126 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _nsMsgDatabase2_H_
+#define _nsMsgDatabase2_H_
+
+#include "mozilla/Attributes.h"
+// #include "mozilla/MemoryReporting.h"
+#include "mozilla/Path.h"
+// #include "nsIFile.h"
+#include "nsIMsgDatabase.h"
+#include "nsMsgHdr2.h"
+#include "nsString.h"
+#include "nsIDBChangeAnnouncer.h"
+#include "nsMsgMessageFlags.h"
+#include "nsIMsgFolder.h"
+#include "nsDBFolderInfo2.h"
+#include "mozilla/intl/Collator.h"
+#include "nsIMimeConverter.h"
+#include "nsCOMPtr.h"
+#include "nsCOMArray.h"
+#include "nsTArray.h"
+#include "nsTObserverArray.h"
+
+using mozilla::intl::Collator;
+
+class nsMsgThread;
+class nsMsgDatabase2;
+class nsIMsgThread;
+
+const int32_t kMsgDBVersion = 1;
+
+class nsMsgDatabase2 : public nsIMsgDatabase {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIDBCHANGEANNOUNCER
+  NS_DECL_NSIMSGDATABASE
+
+  virtual nsresult MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool bRead,
+                                   nsIDBChangeListener* instigator);
+  virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
+  virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
+  virtual nsresult EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
+                                             uint32_t* pFlag);
+
+  //////////////////////////////////////////////////////////////////////////////
+  // nsMsgDatabase2 methods:
+  nsMsgDatabase2();
+
+  virtual uint32_t GetCurVersion();
+  nsresult GetCollationKeyGenerator();
+  nsIMimeConverter* GetMimeConverter();
+
+#ifdef DEBUG
+  virtual nsresult DumpContents();
+#endif
+
+  friend class nsMsgHdr2;    // use this to get access to cached tokens for hdr
+                             // fields
+  friend class nsMsgThread;  // use this to get access to cached tokens for hdr
+                             // fields
+
+ protected:
+  virtual ~nsMsgDatabase2();
+
+  // prefs stuff - in future, we might want to cache the prefs interface
+  nsresult GetBoolPref(const char* prefName, bool* result);
+  nsresult GetIntPref(const char* prefName, int32_t* result);
+  virtual void GetGlobalPrefs();
+  // retrieval methods
+  nsIMsgThread* GetThreadForReference(nsCString& msgID, nsIMsgDBHdr** pMsgHdr);
+  nsIMsgThread* GetThreadForSubject(nsCString& subject);
+  nsIMsgThread* GetThreadForMessageId(nsCString& msgId);
+  nsIMsgThread* GetThreadForThreadId(nsMsgKey threadId);
+  nsMsgHdr2* GetMsgHdrForReference(nsCString& reference);
+  // threading interfaces
+  virtual nsresult CreateNewThread(nsMsgKey key, const char* subject,
+                                   nsMsgThread** newThread);
+  virtual bool ThreadBySubjectWithoutRe();
+  virtual bool UseStrictThreading();
+  virtual bool UseCorrectThreading();
+
+  static PRTime sLastUseTime;  // global last use time
+  PRTime m_lastUseTime;        // last use time for this db
+  // inline to make instrumentation as cheap as possible
+  inline void RememberLastUseTime() { sLastUseTime = m_lastUseTime = PR_Now(); }
+
+  // Flag handling routines
+
+  //  virtual bool SetHdrFlag(nsIMsgDBHdr*, bool bSet, nsMsgMessageFlagType
+  //  flag); virtual bool SetHdrReadFlag(nsIMsgDBHdr*, bool pRead); virtual
+  //  uint32_t GetStatusFlags(nsIMsgDBHdr* msgHdr,
+  //                                  nsMsgMessageFlagType origFlags);
+  // helper function which doesn't involve thread object
+
+  mozilla::UniquePtr<mozilla::intl::Collator> m_collationKeyGenerator = nullptr;
+  nsCOMPtr<nsIMimeConverter> m_mimeConverter;
+  nsCOMPtr<nsIMsgRetentionSettings> m_retentionSettings;
+  nsCOMPtr<nsIMsgDownloadSettings> m_downloadSettings;
+
+  nsresult FindMessagesOlderThan(uint32_t daysToKeepHdrs,
+                                 bool applyToFlaggedMessages,
+                                 nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
+  nsresult FindExcessMessages(uint32_t numHeadersToKeep,
+                              bool applyToFlaggedMessages,
+                              nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
+
+  // not sure how we'll manage global DB yet, so use DB() to access.
+  GlobalDB* mGlobalDB;
+  GlobalDB& DB() { return *mGlobalDB; }
+  uint32_t mFolderID;  // TODO :-)
+
+  nsCOMPtr<nsIMsgFolder> m_folder;
+  RefPtr<nsDBFolderInfo2> m_dbFolderInfo;
+  nsMsgKey m_nextPseudoMsgKey;
+
+  // used to remember the args to Open for async open.
+  nsTObserverArray<nsCOMPtr<nsIDBChangeListener>> m_ChangeListeners;
+
+ public:
+ private:
+};
+
+#endif
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -0,0 +1,544 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "msgCore.h"
+// #include "mozilla/mailnews/MimeHeaderParser.h"
+#include "nsMsgHdr2.h"
+#include "nsMsgUtils.h"
+#include "nsMsgMessageFlags.h"
+// #include "mozilla/Attributes.h"
+#include "nsStringEnumerator.h"
+// #ifdef DEBUG
+// #  include "nsPrintfCString.h"
+// #endif
+#include "GlobalDB.h"
+
+NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
+
+#define FLAGS_INITED 0x1
+#define CACHED_VALUES_INITED 0x2
+#define REFERENCES_INITED 0x4
+#define THREAD_PARENT_INITED 0x8
+
+nsMsgHdr2::nsMsgHdr2(GlobalDB* globaldb, nsMsgKey key)
+    : mDB(globaldb), mKey(key), m_initedValues(0) {}
+
+nsMsgHdr2::~nsMsgHdr2() {}
+
+nsresult nsMsgHdr2::InitCachedValues() {
+  nsresult rv = NS_OK;
+
+  if (!(m_initedValues & CACHED_VALUES_INITED)) {
+    rv = DB().FetchMsgSize(mKey, &m_messageSize);
+    if (NS_SUCCEEDED(rv)) {
+      uint32_t dt;
+      rv = DB().FetchMsgDate(mKey, &dt);
+      Seconds2PRTime(dt, &m_date);
+    }
+    if (NS_SUCCEEDED(rv)) {
+      rv = DB().FetchMsgThreadID(mKey, &m_threadId);
+    }
+
+    if (NS_SUCCEEDED(rv)) {
+      m_initedValues |= CACHED_VALUES_INITED;
+    }
+  }
+  return rv;
+}
+
+nsresult nsMsgHdr2::InitFlags() {
+  nsresult rv = NS_OK;
+  if (!(m_initedValues & FLAGS_INITED)) {
+    rv = DB().FetchMsgFlags(mKey, &m_flags);
+    // TODO: re-evaluate this behaviour:
+    m_flags &= ~nsMsgMessageFlags::New;  // don't get new flag from DB
+    if (NS_SUCCEEDED(rv)) {
+      m_initedValues |= FLAGS_INITED;
+    }
+  }
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMessageKey(nsMsgKey* result) {
+  *result = mKey;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetThreadId(nsMsgKey* result) {
+  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
+
+  if (result) {
+    *result = m_threadId;
+    return NS_OK;
+  }
+  return NS_ERROR_NULL_POINTER;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetThreadId(nsMsgKey threadID) {
+  m_threadId = threadID;
+  return DB().SetMsgThreadID(mKey, threadID);
+}
+
+// TODO: should be read-only?
+NS_IMETHODIMP nsMsgHdr2::SetMessageKey(nsMsgKey value) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+nsresult nsMsgHdr2::GetRawFlags(uint32_t* result) {
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  *result = m_flags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetFlags(uint32_t* result) {
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  // TODO: Whatever GetStatusFlags() was doing to massage the flags.
+  *result = m_flags;
+#ifdef DEBUG_bienvenu
+  NS_ASSERTION(!(*result & (nsMsgMessageFlags::Elided)),
+               "shouldn't be set in db");
+#endif
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetFlags(uint32_t flags) {
+#ifdef DEBUG_bienvenu
+  NS_ASSERTION(!(flags & (nsMsgMessageFlags::Elided)),
+               "shouldn't set this flag on db");
+#endif
+  m_initedValues |= FLAGS_INITED;
+  m_flags = flags;
+  // don't write out nsMsgMessageFlags::New to MDB.
+  return DB().SetMsgFlags(mKey, m_flags & ~nsMsgMessageFlags::New);
+}
+
+NS_IMETHODIMP nsMsgHdr2::OrFlags(uint32_t flags, uint32_t* result) {
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  if ((m_flags & flags) != flags) SetFlags(m_flags | flags);
+  *result = m_flags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::AndFlags(uint32_t flags, uint32_t* result) {
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  if ((m_flags & flags) != m_flags) SetFlags(m_flags & flags);
+  *result = m_flags;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::MarkHasAttachments(bool bHasAttachments) {
+  return DB().SetMsgHasAttachments(mKey, bHasAttachments);
+}
+
+NS_IMETHODIMP nsMsgHdr2::MarkRead(bool bRead) {
+  return DB().SetMsgIsRead(mKey, bRead);
+}
+
+NS_IMETHODIMP nsMsgHdr2::MarkFlagged(bool bFlagged) {
+  return DB().SetMsgIsFlagged(mKey, bFlagged);
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetNumReferences(uint16_t* result) {
+  if (!(m_initedValues & REFERENCES_INITED)) {
+    nsCString refs;
+    nsresult rv = DB().FetchMsgReferences(mKey, refs);
+    NS_ENSURE_SUCCESS(rv, rv);
+    ParseReferences(refs.get());
+    m_initedValues |= REFERENCES_INITED;
+  }
+
+  if (result) *result = m_references.Length();
+  // there is no real failure here; if there are no references, there are no
+  //  references.
+  return NS_OK;
+}
+
+nsresult nsMsgHdr2::ParseReferences(const char* references) {
+  const char* startNextRef = references;
+  nsAutoCString resultReference;
+  nsCString messageId;
+  GetMessageId(getter_Copies(messageId));
+
+  while (startNextRef && *startNextRef) {
+    startNextRef = GetNextReference(startNextRef, resultReference,
+                                    startNextRef == references);
+    // Don't add self-references.
+    if (!resultReference.IsEmpty() && !resultReference.Equals(messageId))
+      m_references.AppendElement(resultReference);
+  }
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetStringReference(int32_t refNum,
+                                            nsACString& resultReference) {
+  nsresult err = NS_OK;
+
+  if (!(m_initedValues & REFERENCES_INITED))
+    GetNumReferences(nullptr);  // it can handle the null
+
+  if ((uint32_t)refNum < m_references.Length())
+    resultReference = m_references.ElementAt(refNum);
+  else
+    err = NS_ERROR_ILLEGAL_VALUE;
+  return err;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetDate(PRTime* result) {
+  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
+  *result = m_date;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetDateInSeconds(uint32_t* seconds) {
+  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
+  *seconds = m_date / PR_USEC_PER_SEC;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetMessageId(const char* messageID) {
+  if (messageID && *messageID == '<') {
+    nsAutoCString tempMessageID(messageID + 1);
+    if (tempMessageID.CharAt(tempMessageID.Length() - 1) == '>')
+      tempMessageID.SetLength(tempMessageID.Length() - 1);
+    return DB().SetMsgMessageID(mKey, tempMessageID);
+  }
+  return DB().SetMsgMessageID(mKey, nsDependentCString(messageID));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetSubject(const char* subject) {
+  return DB().SetMsgSubject(mKey, nsDependentCString(subject));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetAuthor(const char* author) {
+  return DB().SetMsgSender(mKey, nsDependentCString(author));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetReferences(const nsACString& references) {
+  m_references.Clear();
+  ParseReferences(PromiseFlatCString(references).get());
+
+  m_initedValues |= REFERENCES_INITED;
+
+  return DB().SetMsgReferences(mKey, references);
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetRecipients(const char* recipients) {
+  // need to put in rfc822 address parsing code here (or make caller do it...)
+  return DB().SetMsgRecipients(mKey, nsDependentCString(recipients));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetCcList(const char* ccList) {
+  return DB().SetMsgCCList(mKey, nsDependentCString(ccList));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetBccList(const char* bccList) {
+  return DB().SetMsgBCCList(mKey, nsDependentCString(bccList));
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetMessageSize(uint32_t messageSize) {
+  m_messageSize = messageSize;
+  return DB().SetMsgSize(mKey, (uint64_t)messageSize);
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetOfflineMessageSize(uint32_t* offlineSize) {
+  uint64_t tmp;
+  nsresult rv = DB().FetchMsgOfflineSize(mKey, &tmp);
+  if (NS_SUCCEEDED(rv)) {
+    *offlineSize = (uint32_t)tmp;
+  }
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetOfflineMessageSize(uint32_t offlineSize) {
+  return DB().SetMsgOfflineSize(mKey, (uint64_t)offlineSize);
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetLineCount(uint32_t lineCount) {
+  return DB().SetMsgLineCount(mKey, lineCount);
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetDate(PRTime date) {
+  m_date = date;
+  uint32_t seconds;
+  PRTime2Seconds(date, &seconds);
+  return DB().SetMsgDate(mKey, seconds);
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetPriority(nsMsgPriorityValue priority) {
+  return DB().SetMsgPriority(mKey, priority);
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetPriority(nsMsgPriorityValue* priority) {
+  return DB().FetchMsgPriority(mKey, priority);
+}
+
+// I'd like to not store the account key, if the msg is in
+// the same account as it was received in, to save disk space and memory.
+// This might be problematic when a message gets moved...
+// And I'm not sure if we should short circuit it here,
+// or at a higher level where it might be more efficient.
+NS_IMETHODIMP nsMsgHdr2::SetAccountKey(const char* aAccountKey) {
+  return DB().SetMsgAccountKey(mKey, nsDependentCString(aAccountKey));
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetAccountKey(char** accountKey) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgAccountKey(mKey, tmp);
+  *accountKey = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMessageOffset(uint64_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetMessageOffset(uint64_t offset) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMessageSize(uint32_t* size) {
+  uint64_t tmp;
+  nsresult rv = DB().FetchMsgSize(mKey, &tmp);
+  if (NS_SUCCEEDED(rv)) {
+    *size = (uint32_t)tmp;
+  }
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetLineCount(uint32_t* lineCount) {
+  return DB().FetchMsgLineCount(mKey, lineCount);
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetAuthor(char** sender) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgSender(mKey, tmp);
+  *sender = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetSubject(char** subject) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgSubject(mKey, tmp);
+  *subject = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetRecipients(char** recipients) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgRecipients(mKey, tmp);
+  *recipients = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetCcList(char** ccList) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgCCList(mKey, tmp);
+  *ccList = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetBccList(char** bccList) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgBCCList(mKey, tmp);
+  *bccList = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMessageId(char** messageID) {
+  nsAutoCString tmp;
+  nsresult rv = DB().FetchMsgMessageID(mKey, tmp);
+  *messageID = moz_xstrdup(tmp.get());
+  return rv;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedAuthor(nsAString& author) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedSubject(nsAString& resultSubject) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedRecipients(
+    nsAString& resultRecipients) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetAuthorCollationKey(
+    nsTArray<uint8_t>& resultAuthor) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetSubjectCollationKey(
+    nsTArray<uint8_t>& resultSubject) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetRecipientsCollationKey(
+    nsTArray<uint8_t>& resultRecipients) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetCharset(char** aCharset) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetCharset(const char* aCharset) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetEffectiveCharset(nsACString& resultCharset) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetThreadParent(nsMsgKey inKey) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetThreadParent(nsMsgKey* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetFolder(nsIMsgFolder** result) {
+  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+}
+
+/**
+ * Roughly speaking, get the next message-id (starts with a '<' ends with a
+ *  '>').  Except, we also try to handle the case where your reference is of
+ *  a prehistoric vintage that just stuck any old random junk in there.  Our
+ *  old logic would (unintentionally?) just trim the whitespace off the front
+ *  and hand you everything after that.  We change things at all because that
+ *  same behaviour does not make sense if we have already seen a proper message
+ *  id.  We keep the old behaviour at all because it would seem to have
+ *  benefits.  (See jwz's non-zero stats: http://www.jwz.org/doc/threading.html)
+ * So, to re-state, if there is a valid message-id in there at all, we only
+ *  return valid message-id's (sans bracketing '<' and '>').  If there isn't,
+ *  our result (via "references") is a left-trimmed copy of the string.  If
+ *  there is nothing in there, our result is an empty string.)  We do require
+ *  that you pass allowNonDelimitedReferences what it demands, though.
+ * For example: "<valid@stuff> this stuff is invalid" would net you
+ *  "valid@stuff" and "this stuff is invalid" as results.  We now only would
+ *  provide "valid-stuff" and an empty string (which you should ignore) as
+ *  results.  However "this stuff is invalid" would return itself, allowing
+ *  anything relying on that behaviour to keep working.
+ *
+ * Note: We accept anything inside the '<' and '>'; technically, we should want
+ *  at least a '@' in there (per rfc 2822).  But since we're going out of our
+ *  way to support weird things...
+ *
+ * @param startNextRef The position to start at; this should either be the start
+ *     of your references string or our return value from a previous call.
+ * @param reference You pass a nsCString by reference, we put the reference we
+ *     find in it, if we find one.  It may be empty!  Beware!
+ * @param allowNonDelimitedReferences Should we support the
+ *     pre-reasonable-standards form of In-Reply-To where it could be any
+ *     arbitrary string and our behaviour was just to take off leading
+ *     whitespace.  It only makes sense to pass true for your first call to this
+ *     function, as if you are around to make a second call, it means we found
+ *     a properly formatted message-id and so we should only look for more
+ *     properly formatted message-ids.
+ *     NOTE: this option will also strip off a single leading '<' if there is
+ *     one. Some examples:
+ *        "   foo" => "foo"
+ *        "  <bar" => "bar"
+ *        "<<<foo" => "<<foo"
+ *        "<foo@bar>" => "foo@bar"  (completed message-id)
+ * @returns The next starting position of this routine, which may be pointing at
+ *     a nul '\0' character to indicate termination.
+ */
+const char* nsMsgHdr2::GetNextReference(const char* startNextRef,
+                                        nsCString& reference,
+                                        bool acceptNonDelimitedReferences) {
+  const char* ptr = startNextRef;
+  const char* whitespaceEndedAt = nullptr;
+  const char* firstMessageIdChar = nullptr;
+
+  // make the reference result string empty by default; we will set it to
+  //  something valid if the time comes.
+  reference.Truncate();
+
+  // walk until we find a '<', but keep track of the first point we found that
+  //  was not whitespace (as defined by previous versions of this code.)
+  for (bool foundLessThan = false; !foundLessThan; ptr++) {
+    switch (*ptr) {
+      case '\0':
+        // if we are at the end of the string, we found some non-whitespace, and
+        //  the caller requested that we accept non-delimited whitespace,
+        //  give them that as their reference.  (otherwise, leave it empty)
+        if (acceptNonDelimitedReferences && whitespaceEndedAt)
+          reference = whitespaceEndedAt;
+        return ptr;
+      case ' ':
+      case '\r':
+      case '\n':
+      case '\t':
+        // do nothing, make default case mean you didn't get whitespace
+        break;
+      case '<':
+        firstMessageIdChar = ptr + 1;  // skip over the '<'
+        foundLessThan = true;          // (flag to stop)
+        // Ensure whitespaceEndedAt skips the leading '<' and is set to
+        //  a non-NULL value, just in case the message-id is not valid (no '>')
+        //  and the old-school support is desired.
+        if (!whitespaceEndedAt) whitespaceEndedAt = ptr + 1;
+        break;
+      default:
+        if (!whitespaceEndedAt) whitespaceEndedAt = ptr;
+        break;
+    }
+  }
+
+  // keep going until we hit a '>' or hit the end of the string
+  for (; *ptr; ptr++) {
+    if (*ptr == '>') {
+      // it's valid, update reference, making sure to stop before the '>'
+      reference.Assign(firstMessageIdChar, ptr - firstMessageIdChar);
+      // and return a start point just after the '>'
+      return ++ptr;
+    }
+  }
+
+  // we did not have a fully-formed, valid message-id, so consider falling back
+  if (acceptNonDelimitedReferences && whitespaceEndedAt)
+    reference = whitespaceEndedAt;
+  return ptr;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetIsRead(bool* isRead) {
+  NS_ENSURE_ARG_POINTER(isRead);
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  *isRead = !!(m_flags & nsMsgMessageFlags::Read);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetIsFlagged(bool* isFlagged) {
+  NS_ENSURE_ARG_POINTER(isFlagged);
+  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  *isFlagged = !!(m_flags & nsMsgMessageFlags::Marked);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetIsKilled(bool* isKilled) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const*, char const*) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const*, char**) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const*, unsigned int*) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+NS_IMETHODIMP nsMsgHdr2::SetUint32Property(char const*, unsigned int) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr2::GetProperties(nsTArray<nsTString<char>>&) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.h b/mailnews/db/msgdb/src/nsMsgHdr2.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.h
@@ -0,0 +1,56 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _nsMsgHdr2_H
+#define _nsMsgHdr2_H
+
+#include "mozilla/MemoryReporting.h"
+#include "nsIMsgHdr.h"
+#include "nsString.h"
+#include "MailNewsTypes.h"
+#include "nsTArray.h"
+
+class nsIMsgThread;
+class GlobalDB;
+
+class nsMsgHdr2 : public nsIMsgDBHdr {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIMSGDBHDR
+
+  nsMsgHdr2() = delete;
+  nsMsgHdr2(GlobalDB* db, nsMsgKey key);
+
+ protected:
+  virtual ~nsMsgHdr2();
+  void ClearCachedValues() { m_initedValues = 0; }
+  nsresult GetRawFlags(uint32_t* result);
+
+ private:
+  nsresult InitFlags();
+  nsresult InitCachedValues();
+
+  nsresult ParseReferences(const char* references);
+  const char* GetNextReference(const char* startNextRef, nsCString& reference,
+                               bool acceptNonDelimitedReferences);
+
+  GlobalDB& DB() { return *mDB; }
+  GlobalDB* mDB;  // We might remove this in favour of a singleton or
+                  // something... (so access via DB() for now).
+  nsMsgKey mKey;  // news: article number, local mail: key, imap: uid...
+
+  // Everything else here is just caching...
+  nsMsgKey m_threadId;
+  // nsMsgKey m_threadParent;  // message this is a reply to, in thread.
+  PRTime m_date;
+  uint64_t m_messageSize;  // lines for news articles, bytes for mail messages
+  uint32_t m_flags;
+  // avoid parsing references every time we want one
+  nsTArray<nsCString> m_references;
+
+  uint32_t m_initedValues;
+};
+
+#endif
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670305842 -46800
#      Tue Dec 06 18:50:42 2022 +1300
# Node ID 25c91846589bdad2518e779a2f982a606eb49c56
# Parent  daa970a5de7763b4efc5fa71491fd240f1e02a9f
WIP: add folder table

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -5,16 +5,17 @@
 #include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
 GlobalDB::~GlobalDB() {
+  mStmtCache.FinalizeStatements();
   if (mConn) {
     mConn->Close();
   }
 }
 
 nsresult GlobalDB::Init() {
   nsCOMPtr<mozIStorageService> storage =
       do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
@@ -108,30 +109,45 @@ nsresult GlobalDB::InitSchema() {
         "glodaId INTEGER NOT NULL DEFAULT 0, "
         "xGmMsgId TEXT NOT NULL DEFAULT '', "
         "xGmThrId TEXT NOT NULL DEFAULT '', "
         "xGmLabels TEXT NOT NULL DEFAULT '', "
         "pseudoHdr INTEGER NOT NULL DEFAULT 0, "  // KILL KILL KILL!
         "enigmail INTEGER NOT NULL DEFAULT 0, "
         "notAPhishMessage INTEGER NOT NULL DEFAULT 0 "
         ")");
-
     rv = mConn->ExecuteSimpleSQL(create_msg);
     NS_ENSURE_SUCCESS(rv, rv);
+
+    const nsLiteralCString create_folder(
+        "CREATE TABLE folder ( "
+        "uri TEXT NOT NULL DEFAULT '' "
+        ")");
+    rv = mConn->ExecuteSimpleSQL(create_folder);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    const nsLiteralCString create_msg_folder(
+        "CREATE TABLE msg_folder ( "
+        "msg_id INTEGER NOT NULL, "
+        "folder_id INTEGER NOT NULL "
+        ")");
+    rv = mConn->ExecuteSimpleSQL(create_msg_folder);
+    NS_ENSURE_SUCCESS(rv, rv);
+
   } else {
     // Migrations go here...
   }
 
   rv = mConn->SetSchemaVersion(latestSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
 }
 
-nsresult GlobalDB::StashMsg(RawHdr const& msg) {
+nsresult GlobalDB::StashMsg(RawHdr const& msg, nsMsgKey* newKey) {
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO msg "
       "(messageID, refs, date, received, subject, sender, recipients, "
       "ccList, replyto, flags, priority, msgSize, storeToken, "
       "offlineMsgSize, "
       "numLines, preview, junkscoreorigin, junkpercent, senderName, "
       "prevkeywords, keywords, remoteContentPolicy, protoThreadFlags, "
       "glodaId, xGmMsgId, xGmThrId, xGmLabels, pseudoHdr, enigmail, "
@@ -142,16 +158,17 @@ nsresult GlobalDB::StashMsg(RawHdr const
       ":storeToken, "
       ":offlineMsgSize, "
       ":numLines, :preview, :junkscoreorigin, :junkpercent, :senderName, "
       ":prevkeywords, :keywords, :remoteContentPolicy, :protoThreadFlags, "
       ":glodaId, :xGmMsgId, :xGmThrId, :xGmLabels, :pseudoHdr, :enigmail, "
       ":notAPhishMessage"
       ")");
   NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
 
   nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, msg.messageID);
   if (NS_FAILED(rv)) return rv;
   rv = stmt->BindUTF8StringByName("refs"_ns, msg.references);
   if (NS_FAILED(rv)) return rv;
 
   rv = stmt->BindInt64ByName("date"_ns, msg.date);
   if (NS_FAILED(rv)) return rv;
@@ -220,25 +237,48 @@ nsresult GlobalDB::StashMsg(RawHdr const
   rv = stmt->BindInt32ByName("notAPhishMessage"_ns, msg.notAPhishMessage);
   if (NS_FAILED(rv)) return rv;
 
   rv = stmt->Execute();
   if (NS_FAILED(rv)) {
     return rv;
   }
 
+  int64_t rowid;
+  rv = mConn->GetLastInsertRowID(&rowid);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *newKey = (nsMsgKey)rowid;
   return NS_OK;
 }
 
-nsresult GlobalDB::StashMsgs(nsTArray<RawHdr> const& msgs) {
+nsresult GlobalDB::AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID) {
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "INSERT INTO msg_folder (msg_id, folder_id) VALUES (:msgID, :folderID)");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("msgID"_ns, (int64_t)msgKey);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->Execute();
+  if (NS_FAILED(rv)) return rv;
+  return NS_OK;
+}
+
+nsresult GlobalDB::StashMsgs(nsTArray<RawHdr> const& msgs,
+                             nsFolderKey folderID) {
   mozStorageTransaction transaction(mConn, false);
   nsresult rv = transaction.Start();
   NS_ENSURE_SUCCESS(rv, rv);
   for (RawHdr const& msg : msgs) {
-    rv = StashMsg(msg);
+    nsMsgKey newKey;
+    rv = StashMsg(msg, &newKey);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = AddMsgToFolder(newKey, folderID);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return transaction.Commit();
 }
 
 nsCString GlobalDB::LastErr() {
   nsCString err;
   mConn->GetLastErrorString(err);
@@ -569,17 +609,17 @@ nsresult GlobalDB::FolderGetMsgHdrForKey
 }
 
 nsresult GlobalDB::FolderDeleteHeader(uint32_t folderID, nsMsgKey key,
                                       nsIDBChangeListener* instigator,
                                       bool commit, bool notify) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-nsresult GlobalDB::FolderUndoDelete(uint32_t folderID, nsMsgKey key) {
+nsresult GlobalDB::FolderUndoDelete(nsFolderKey folderID, nsMsgKey key) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 // oddities
 nsresult GlobalDB::MarkMsgRead(nsMsgKey key, bool isRead,
                                nsIDBChangeListener* instigator) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
@@ -590,8 +630,55 @@ nsresult GlobalDB::SetMsgFlag(nsMsgKey k
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::GetMsgHdrForMessageID(nsACString const& messageID,
                                          nsMsgHdr2** found) {
   *found = nullptr;
   return NS_ERROR_NOT_IMPLEMENTED;
 }
+
+nsresult GlobalDB::FolderFindOrCreate(nsACString const& folderURI,
+                                      nsFolderKey* folderID) {
+  MOZ_ASSERT(folderID);
+
+  {
+    nsCOMPtr<mozIStorageStatement> stmt =
+        Stmt("SELECT rowid FROM folder WHERE uri=:uri");
+    NS_ENSURE_STATE(stmt);
+    mozStorageStatementScoper scoper(stmt);
+
+    nsresult rv = stmt->BindUTF8StringByName("uri"_ns, folderURI);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    bool exists;
+    rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (exists) {
+      int64_t rowid;
+      rv = stmt->GetInt64(0, &rowid);
+      NS_ENSURE_SUCCESS(rv, rv);
+      *folderID = (nsFolderKey)rowid;
+      printf("Found existing folder (key='%d' uri='%s')\n", (int)(*folderID),
+             nsPromiseFlatCString(folderURI).get());
+      return NS_OK;
+    }
+  }
+
+  // need to create it.
+  {
+    nsCOMPtr<mozIStorageStatement> stmt =
+        Stmt("INSERT INTO folder (uri) VALUES (:uri)");
+    NS_ENSURE_STATE(stmt);
+    mozStorageStatementScoper scoper(stmt);
+    nsresult rv = stmt->BindUTF8StringByName("uri"_ns, folderURI);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->Execute();
+    NS_ENSURE_SUCCESS(rv, rv);
+    int64_t rowid;
+    rv = mConn->GetLastInsertRowID(&rowid);
+    NS_ENSURE_SUCCESS(rv, rv);
+    *folderID = (nsFolderKey)rowid;
+    printf("Created Folder (key='%d' uri='%s')\n", (int)(*folderID),
+           nsPromiseFlatCString(folderURI).get());
+  }
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -9,16 +9,18 @@
 
 #include "mozilla/storage.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 
 // Using toolkit/components/places/Database.h as rough guide
 
+typedef uint32_t nsFolderKey;
+
 struct RawHdr {
   nsMsgKey id{0};
   nsCString messageID;
   nsCString references;
   uint64_t date{0};
   uint64_t received{0};
   nsCString subject;
   nsCString sender;
@@ -55,17 +57,17 @@ class nsMsgHdr2;
 class GlobalDB {
  public:
   static GlobalDB& get();
 
   GlobalDB();
   ~GlobalDB();
   nsresult Init();
 
-  nsresult StashMsgs(nsTArray<RawHdr> const& msgs);
+  nsresult StashMsgs(nsTArray<RawHdr> const& msgs, nsFolderKey folderID);
 
   // Get the last DB error message.
   nsCString LastErr();
 
   // -------------- data access ---------------
 
   // to support nsMsgHdr2
   nsresult FetchMsgFlags(nsMsgKey key, uint32_t* flags);
@@ -107,39 +109,47 @@ class GlobalDB {
   nsresult FetchMsgIsWatched(nsMsgKey key, bool* isWatched);
   // nsresult FetchMsgIsFlagged(nsMsgKey key, bool isFlagged);
   nsresult FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments);
 
   nsresult SetMsgIsRead(nsMsgKey key, bool isRead);
   nsresult SetMsgIsFlagged(nsMsgKey key, bool isFlagged);
   nsresult SetMsgHasAttachments(nsMsgKey key, bool hasAttachments);
 
-  // to support nsMsgDatabase2
-  nsresult FolderContainsKey(uint32_t folderID, nsMsgKey key,
-                             bool* containsKey);
-  nsresult FolderGetMsgHdrForKey(uint32_t folderID, nsMsgKey key,
-                                 nsIMsgDBHdr** hdr);
-  nsresult FolderDeleteHeader(uint32_t folderID, nsMsgKey key,
-                              nsIDBChangeListener* instigator, bool commit,
-                              bool notify);
-
-  nsresult FolderUndoDelete(uint32_t folderID, nsMsgKey key);
-
   // oddities
   nsresult MarkMsgRead(nsMsgKey key, bool isRead,
                        nsIDBChangeListener* instigator);
   nsresult SetMsgFlag(nsMsgKey key, bool value, nsMsgMessageFlagType flag,
                       nsIDBChangeListener* instigator);
 
   nsresult GetMsgHdrForMessageID(nsACString const& messageID,
                                  nsMsgHdr2** found);
 
+  // Folder functions
+
+  // Find a folderID, given a URI. Create folder if it doesn't already exist.
+  nsresult FolderFindOrCreate(nsACString const& folderURI,
+                              nsFolderKey* folderID);
+
+  // Ones to evalutate:
+  nsresult FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
+                             bool* containsKey);
+  nsresult FolderGetMsgHdrForKey(nsFolderKey folderID, nsMsgKey key,
+                                 nsIMsgDBHdr** hdr);
+  nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
+                              nsIDBChangeListener* instigator, bool commit,
+                              bool notify);
+
+  nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
+
  private:
   nsresult InitSchema();
-  nsresult StashMsg(RawHdr const& msg);
+  nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
+  nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
+
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
   mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
 };
diff --git a/mailnews/db/msgdb/src/MSFSlurp.cpp b/mailnews/db/msgdb/src/MSFSlurp.cpp
--- a/mailnews/db/msgdb/src/MSFSlurp.cpp
+++ b/mailnews/db/msgdb/src/MSFSlurp.cpp
@@ -33,17 +33,17 @@ class MSFSlurper {
     if (mEnv) {
       mEnv->Release();
       mEnv = nullptr;
     }
   }
 
   nsresult Open(PathString const& msfPath);
 
-  nsresult dumpum();
+  nsresult dumpum(nsACString const& folderURI);
 
  private:
   //  nsIMdbEnv* GetEnv() { return mEnv; }
   //  nsIMdbPort* GetStore() { return mPort; }
   nsresult InitTokens();
 
   nsIMdbEnv* mEnv{nullptr};  // to be used in all the db calls.
   nsIMdbPort* mPort{nullptr};
@@ -270,35 +270,39 @@ static uint32_t hexToU32(nsACString cons
 static uint64_t hexToU64(nsACString const& val) {
   int32_t i;
   if (PR_sscanf(PromiseFlatCString(val).get(), "%" PRIx64, &i) != 1) {
     return 0;
   }
   return i;
 }
 
-nsresult MSFSlurper::dumpum() {
+nsresult MSFSlurper::dumpum(nsACString const& folderURI) {
   PRTime start = PR_Now();
 
   GlobalDB db;
   nsresult rv = db.Init();
   if (NS_FAILED(rv)) {
     NS_WARNING("GlobalDB failed");
   }
 
+  nsFolderKey folderID;
+  rv = db.FolderFindOrCreate(folderURI, &folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   mdb_count nRows;
   rv = mAllMsgHeadersTable->GetCount(mEnv, &nRows);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsTArray<RawHdr> batch;
   auto flushBatch = [&]() -> nsresult {
     if (batch.IsEmpty()) {
       return NS_OK;
     }
-    nsresult rv = db.StashMsgs(batch);
+    nsresult rv = db.StashMsgs(batch, folderID);
     if (NS_FAILED(rv)) {
       printf("Stash failed: %s\n", db.LastErr().get());
     }
     batch.Clear();
     return rv;
   };
 
   for (mdb_pos rowpos = 0; rowpos < (mdb_pos)nRows; ++rowpos) {
@@ -480,20 +484,21 @@ nsresult MSFSlurper::dumpum() {
   NS_ENSURE_SUCCESS(rv, rv);
 
   PRInt64 elapsed = PR_Now() - start;
   printf("DUMP complete: %d msgs in %.3f ms (%.3fus/msg)\n", (int)nRows,
          (double)elapsed / 1000.0, (double)elapsed / (double)nRows);
   return NS_OK;
 }
 
-nsresult msfDump(PathString msfPath) {
-  printf("+++++++++msfDump(%s)+++++++++++++++++\n", msfPath.get());
+nsresult msfDump(PathString msfPath, nsACString const& folderURI) {
+  printf("+++++++++msfDump(%s  uri=%s)+++++++++++++++++\n", msfPath.get(),
+         nsPromiseFlatCString(folderURI).get());
 
   MSFSlurper slurper;
   nsresult rv = slurper.Open(msfPath);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = slurper.dumpum();
+  rv = slurper.dumpum(folderURI);
   NS_ENSURE_SUCCESS(rv, rv);
 
   printf("++++++++++++++++++++++++++++++++++++++++++++\n");
   return NS_OK;
 }
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -1131,21 +1131,27 @@ nsresult nsMsgDatabase::CheckForErrors(n
 
 /**
  * Open the MDB database synchronously or async based on sync argument.
  * If successful, this routine will set up the m_mdbStore and m_mdbEnv of
  * the database object so other database calls can work.
  */
 nsresult nsMsgDatabase::OpenMDB(nsIFile* dbFile, bool create, bool sync) {
   {
+    extern nsresult msfDump(PathString msfPath, nsACString const& folderURI);
     bool exists = false;
     dbFile->Exists(&exists);
     if (exists) {
-      extern nsresult msfDump(PathString msfPath);
-      msfDump(dbFile->NativePath());
+      nsAutoCString folderURI;
+      if (m_folder) {
+        m_folder->GetURI(folderURI);
+        msfDump(dbFile->NativePath(), folderURI);
+      } else {
+        printf("WARN: null m_folder (%s)\n", folderURI.get());
+      }
     }
   }
 
   nsCOMPtr<nsIMdbFactory> mdbFactory;
   nsresult ret = GetMDBFactory(getter_AddRefs(mdbFactory));
   NS_ENSURE_SUCCESS(ret, ret);
 
   ret = mdbFactory->MakeEnv(NULL, &m_mdbEnv);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670373455 -46800
#      Wed Dec 07 13:37:35 2022 +1300
# Node ID 40a4378474837011c04481a09312536bd06aa511
# Parent  25c91846589bdad2518e779a2f982a606eb49c56
WIP: add support for setting some msgHdr fields

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -493,63 +493,189 @@ nsresult GlobalDB::FetchMsgPriority(nsMs
   return stmt->GetInt32(0, (int32_t*)priority);
 }
 
 nsresult GlobalDB::FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  MOZ_ASSERT(flags < INT32_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET flags=:flags WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
-nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& author) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET messageID=:messageID WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgReferences(nsMsgKey key,
                                     nsACString const& references) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET refs=:refs WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("refs"_ns, references);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSender(nsMsgKey key, nsACString const& sender) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET sender=:sender WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("sender"_ns, sender);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET subject=:subject WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("subject"_ns, subject);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
                                     nsACString const& recipients) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET recipients=:recipients WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("recipients"_ns, recipients);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgCCList(nsMsgKey key, nsACString const& ccList) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET ccList=:ccList WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("ccList"_ns, ccList);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgBCCList(nsMsgKey key, nsACString const& bccList) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET bccList=:bccList WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("bccList"_ns, bccList);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
-nsresult GlobalDB::SetMsgSize(nsMsgKey key, uint64_t size) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+nsresult GlobalDB::SetMsgSize(nsMsgKey key, uint64_t msgSize) {
+  MOZ_ASSERT(msgSize < INT64_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET msgSize=:msgSize WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("msgSize"_ns, (int64_t)msgSize);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
-nsresult GlobalDB::SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+nsresult GlobalDB::SetMsgOfflineSize(nsMsgKey key, uint64_t offlineMsgSize) {
+  MOZ_ASSERT(offlineMsgSize < INT64_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET offlineMsgSize=:offlineMsgSize WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv =
+      stmt->BindInt64ByName("offlineMsgSize"_ns, (int64_t)offlineMsgSize);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgLineCount(nsMsgKey key, uint32_t lineCount) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  MOZ_ASSERT(lineCount < INT32_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET lineCount=:lineCount WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt32ByName("lineCount"_ns, (int32_t)lineCount);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  MOZ_ASSERT(seconds < INT32_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET date=:seconds WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt32ByName("seconds"_ns, (int32_t)seconds);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgThreadID(nsMsgKey key, nsMsgKey threadID) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority) {
   return NS_ERROR_NOT_IMPLEMENTED;
@@ -593,36 +719,62 @@ nsresult GlobalDB::SetMsgIsFlagged(nsMsg
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 // to support nsMsgDatabase2
-nsresult GlobalDB::FolderContainsKey(uint32_t folderID, nsMsgKey key,
+nsresult GlobalDB::FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                                      bool* containsKey) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT 1 FROM msg_folder WHERE msg_id=:msgKey AND folder_id=:folderKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+
+  nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return stmt->ExecuteStep(containsKey);
 }
 
-nsresult GlobalDB::FolderGetMsgHdrForKey(uint32_t folderID, nsMsgKey key,
-                                         nsIMsgDBHdr** hdr) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-nsresult GlobalDB::FolderDeleteHeader(uint32_t folderID, nsMsgKey key,
+nsresult GlobalDB::FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                                       nsIDBChangeListener* instigator,
                                       bool commit, bool notify) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FolderUndoDelete(nsFolderKey folderID, nsMsgKey key) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+nsresult GlobalDB::FolderListAllKeys(nsFolderKey folderID,
+                                     nsTArray<nsMsgKey>& keys) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT msg_id FROM msg_folder WHERE folder_id=:folderKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  keys.Clear();
+  while (1) {
+    bool more;
+    rv = stmt->ExecuteStep(&more);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!more) {
+      break;
+    }
+    keys.AppendElement((nsMsgKey)stmt->AsInt64(0));
+  }
+  return NS_OK;
+}
+
 // oddities
 nsresult GlobalDB::MarkMsgRead(nsMsgKey key, bool isRead,
                                nsIDBChangeListener* instigator) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgFlag(nsMsgKey key, bool value,
                               nsMsgMessageFlagType flag,
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -82,17 +82,17 @@ class GlobalDB {
   nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
   nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
   nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID);
   nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
   nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
 
   nsresult SetMsgFlags(nsMsgKey key, uint32_t flags);
-  nsresult SetMsgMessageID(nsMsgKey key, nsACString const& author);
+  nsresult SetMsgMessageID(nsMsgKey key, nsACString const& messageID);
   nsresult SetMsgReferences(nsMsgKey key, nsACString const& references);
   nsresult SetMsgSender(nsMsgKey key, nsACString const& sender);
   nsresult SetMsgSubject(nsMsgKey key, nsACString const& subject);
   nsresult SetMsgRecipients(nsMsgKey key, nsACString const& recipients);
   nsresult SetMsgCCList(nsMsgKey key, nsACString const& ccList);
   nsresult SetMsgBCCList(nsMsgKey key, nsACString const& bccList);
   nsresult SetMsgSize(nsMsgKey key, uint64_t size);
   nsresult SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize);
@@ -127,24 +127,24 @@ class GlobalDB {
 
   // Find a folderID, given a URI. Create folder if it doesn't already exist.
   nsresult FolderFindOrCreate(nsACString const& folderURI,
                               nsFolderKey* folderID);
 
   // Ones to evalutate:
   nsresult FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                              bool* containsKey);
-  nsresult FolderGetMsgHdrForKey(nsFolderKey folderID, nsMsgKey key,
-                                 nsIMsgDBHdr** hdr);
   nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                               nsIDBChangeListener* instigator, bool commit,
                               bool notify);
 
   nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
 
+  nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
+
  private:
   nsresult InitSchema();
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -232,21 +232,29 @@ NS_IMETHODIMP nsMsgDatabase2::Close(bool
 }
 
 // Returns if the db contains this key
 NS_IMETHODIMP nsMsgDatabase2::ContainsKey(nsMsgKey key, bool* containsKey) {
   return DB().FolderContainsKey(mFolderID, key, containsKey);
 }
 
 // get a message header for the given key. Caller must release()!
+// NOTE: old version creates row in DB if it doesn't exist...
+// That seems like a no-no now.
 NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForKey(nsMsgKey key,
                                               nsIMsgDBHdr** pmsgHdr) {
-  // NOTE: old version creates row in DB if it doesn't exist...
-  // That seems like a no-no now.
-  return DB().FolderGetMsgHdrForKey(mFolderID, key, pmsgHdr);
+  bool exists;
+  nsresult rv = DB().FolderContainsKey(mFolderID, key, &exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists) {
+    return NS_MSG_MESSAGE_NOT_FOUND;
+  }
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
+  msgHdr.forget(pmsgHdr);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::DeleteMessage(nsMsgKey key,
                                             nsIDBChangeListener* instigator,
                                             bool commit) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
 
   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
@@ -301,21 +309,21 @@ NS_IMETHODIMP nsMsgDatabase2::RemoveHead
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsRead(nsMsgKey key, bool* isRead) {
   return DB().FetchMsgIsRead(key, isRead);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsMarked(nsMsgKey key, bool* isMarked) {
-  return DB().FetchMsgIsRead(key, isMarked);
+  return DB().FetchMsgIsMarked(key, isMarked);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsIgnored(nsMsgKey key, bool* isIgnored) {
-  return DB().FetchMsgIsRead(key, isIgnored);
+  return DB().FetchMsgIsIgnored(key, isIgnored);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsWatched(nsMsgKey key, bool* isWatched) {
   return DB().FetchMsgIsWatched(key, isWatched);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::HasAttachments(nsMsgKey key,
                                              bool* hasAttachments) {
@@ -641,17 +649,17 @@ nsMsgDatabase2::GetFilterEnumerator(
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::SyncCounts() {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FolderListAllKeys(mFolderID, keys);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670375526 -46800
#      Wed Dec 07 14:12:06 2022 +1300
# Node ID 77055727a1870ec59f831b0005c33728fc472d4f
# Parent  40a4378474837011c04481a09312536bd06aa511
WIP: add some basic msg enumeration

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -1,16 +1,46 @@
 #include "GlobalDB.h"
 
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
+#include "nsMsgEnumerator.h"
+
+class MsgEnumerator : public nsBaseMsgEnumerator {
+ public:
+  MsgEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& keys)
+      : mGlobalDB(db), mKeys(keys), mCur(0){};
+  MsgEnumerator() = delete;
+
+  // nsIMsgEnumerator support.
+  NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
+    MOZ_ASSERT(mCur < mKeys.Length());
+    RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mGlobalDB, mKeys[mCur++]);
+    hdr.forget(aItem);
+    return NS_OK;
+  }
+
+  NS_IMETHOD HasMoreElements(bool* aResult) override {
+    *aResult = mCur < mKeys.Length();
+    return NS_OK;
+  }
+
+ protected:
+  GlobalDB* mGlobalDB;
+  nsTArray<nsMsgKey> const& mKeys;
+  size_t mCur;
+};
+
+// **********************************************************************
+// GlobalDB
+//
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
 GlobalDB::~GlobalDB() {
   mStmtCache.FinalizeStatements();
   if (mConn) {
     mConn->Close();
   }
@@ -829,8 +859,35 @@ nsresult GlobalDB::FolderFindOrCreate(ns
     rv = mConn->GetLastInsertRowID(&rowid);
     NS_ENSURE_SUCCESS(rv, rv);
     *folderID = (nsFolderKey)rowid;
     printf("Created Folder (key='%d' uri='%s')\n", (int)(*folderID),
            nsPromiseFlatCString(folderURI).get());
   }
   return NS_OK;
 }
+
+nsresult GlobalDB::FolderEnumerateMsgs(nsFolderKey folderID,
+                                       nsIMsgEnumerator** result) {
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = FolderListAllKeys(folderID, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
+  e.forget(result);
+  return NS_OK;
+}
+
+nsresult GlobalDB::FolderReverseEnumerateMsgs(nsFolderKey folderID,
+                                              nsIMsgEnumerator** result) {
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = FolderListAllKeys(folderID, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  keys.Reverse();
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
+  e.forget(result);
+  return NS_OK;
+}
+
+nsresult GlobalDB::FolderEnumerateMsgsFiltered(
+    nsFolderKey folderID, const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms,
+    bool aReverse, nsIMsgEnumerator** aResult) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -48,16 +48,18 @@ struct RawHdr {
   int pseudoHdr{0};
   int enigmail{0};
   int notAPhishMessage{0};
 };
 
 class nsIMsgDBHdr;
 class nsIDBChangeListener;
 class nsMsgHdr2;
+class nsIMsgEnumerator;
+class nsIMsgSearchTerm;
 
 class GlobalDB {
  public:
   static GlobalDB& get();
 
   GlobalDB();
   ~GlobalDB();
   nsresult Init();
@@ -135,16 +137,24 @@ class GlobalDB {
   nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                               nsIDBChangeListener* instigator, bool commit,
                               bool notify);
 
   nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
+  nsresult FolderEnumerateMsgs(nsFolderKey folderID, nsIMsgEnumerator** result);
+  nsresult FolderReverseEnumerateMsgs(nsFolderKey folderID,
+                                      nsIMsgEnumerator** result);
+  nsresult FolderEnumerateMsgsFiltered(
+      nsFolderKey folderID,
+      const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
+      nsIMsgEnumerator** aResult);
+
  private:
   nsresult InitSchema();
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -3,44 +3,31 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // this file implements the nsMsgDatabase2 interface using the MDB Interface.
 
 #include "nscore.h"
 #include "msgCore.h"
 #include "nsMsgDatabase2.h"
-#include "GlobalDB.h"
-// #include "nsIFile.h"
-// #include "nsMailDatabase.h"
 #include "nsDBFolderInfo2.h"
-// #include "nsIMsgNewsFolder.h"
 #include "nsMsgThread.h"
-#include "nsIMsgSearchTerm.h"
 #include "nsIDBChangeListener.h"
-// #include "nsIMdbFactoryFactory.h"
-#include "mozilla/Logging.h"
-#include "mozilla/Telemetry.h"
 #include "prprf.h"
 #include "nsMsgFolderFlags.h"
-// #include "nsIMsgAccountManager.h"
+#include "nsMsgUtils.h"
+#include "nsMemory.h"
+#include "nsIMsgSearchTerm.h"
 #include "nsIMsgDBView.h"  // for nsMsgViewFlagsType
-// #include "nsIMsgFolderCache.h"
-// #include "nsIMsgFolderCacheElement.h"
-#include "MailNewsTypes2.h"
-#include "nsMsgUtils.h"
-// #include "nsComponentManagerUtils.h"
-// #include "nsServiceManagerUtils.h"
-#include "nsMemory.h"
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
-// #include "nsMsgDatabaseEnumerators.h"
-// #include "nsIMemoryReporter.h"
-// #include "nsIWeakReferenceUtils.h"
-// #include "nsMailDirServiceDefs.h"
+#include "MailNewsTypes2.h"
+#include "GlobalDB.h"
+#include "mozilla/Logging.h"
+#include "mozilla/Telemetry.h"
 #include "mozilla/Components.h"
 #include "mozilla/mailnews/MimeHeaderParser.h"
 #include "mozilla/intl/LocaleService.h"
 
 using namespace mozilla::mailnews;
 using namespace mozilla;
 
 #if defined(DEBUG_sspitzer_) || defined(DEBUG_seth_)
@@ -628,29 +615,30 @@ NS_IMETHODIMP nsMsgDatabase2::HasNew(boo
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetFirstNew(nsMsgKey* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateMessages(nsIMsgEnumerator** result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FolderEnumerateMsgs(mFolderID, result);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::ReverseEnumerateMessages(nsIMsgEnumerator** result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FolderReverseEnumerateMsgs(mFolderID, result);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::GetFilterEnumerator(
-    const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
-    nsIMsgEnumerator** aResult) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+    const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool reverse,
+    nsIMsgEnumerator** result) {
+  return DB().FolderEnumerateMsgsFiltered(mFolderID, searchTerms, reverse,
+                                          result);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::SyncCounts() {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670391335 -46800
#      Wed Dec 07 18:35:35 2022 +1300
# Node ID b88f2d994c1743bce8fd71daf4cc629dd9218191
# Parent  77055727a1870ec59f831b0005c33728fc472d4f
WIP: support storeToken

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -522,16 +522,30 @@ nsresult GlobalDB::FetchMsgPriority(nsMs
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetInt32(0, (int32_t*)priority);
 }
 
 nsresult GlobalDB::FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+nsresult GlobalDB::FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT storeToken FROM msg WHERE rowid=:rowid");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  return stmt->GetUTF8String(0, storeToken);
+}
+
 nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
   MOZ_ASSERT(flags < INT32_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET flags=:flags WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -711,16 +725,31 @@ nsresult GlobalDB::SetMsgPriority(nsMsgK
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgAccountKey(nsMsgKey key,
                                     nsACString const& accountKey) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+nsresult GlobalDB::SetMsgStoreToken(nsMsgKey key,
+                                    nsACString const& storeToken) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET storeToken=:storeToken WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("storeToken"_ns, storeToken);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
 // odd flag-twiddling ones
 nsresult GlobalDB::FetchMsgIsRead(nsMsgKey key, bool* isRead) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FetchMsgIsMarked(nsMsgKey key, bool* isMarked) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -82,32 +82,34 @@ class GlobalDB {
   nsresult FetchMsgBCCList(nsMsgKey key, nsACString& bccList);
   nsresult FetchMsgSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
   nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
   nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID);
   nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
   nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
+  nsresult FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken);
 
   nsresult SetMsgFlags(nsMsgKey key, uint32_t flags);
   nsresult SetMsgMessageID(nsMsgKey key, nsACString const& messageID);
   nsresult SetMsgReferences(nsMsgKey key, nsACString const& references);
   nsresult SetMsgSender(nsMsgKey key, nsACString const& sender);
   nsresult SetMsgSubject(nsMsgKey key, nsACString const& subject);
   nsresult SetMsgRecipients(nsMsgKey key, nsACString const& recipients);
   nsresult SetMsgCCList(nsMsgKey key, nsACString const& ccList);
   nsresult SetMsgBCCList(nsMsgKey key, nsACString const& bccList);
   nsresult SetMsgSize(nsMsgKey key, uint64_t size);
   nsresult SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize);
   nsresult SetMsgLineCount(nsMsgKey key, uint32_t lineCount);
   nsresult SetMsgDate(nsMsgKey key, uint32_t seconds);
   nsresult SetMsgThreadID(nsMsgKey key, nsMsgKey threadID);
   nsresult SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority);
   nsresult SetMsgAccountKey(nsMsgKey key, nsACString const& accountKey);
+  nsresult SetMsgStoreToken(nsMsgKey key, nsACString const& storeToken);
 
   // odd flag-twiddling ones
   nsresult FetchMsgIsRead(nsMsgKey key, bool* isRead);
   nsresult FetchMsgIsMarked(nsMsgKey key, bool* isMarked);
   nsresult FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored);
   nsresult FetchMsgIsWatched(nsMsgKey key, bool* isWatched);
   // nsresult FetchMsgIsFlagged(nsMsgKey key, bool isFlagged);
   nsresult FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments);
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -520,25 +520,44 @@ NS_IMETHODIMP nsMsgHdr2::GetIsFlagged(bo
   *isFlagged = !!(m_flags & nsMsgMessageFlags::Marked);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsKilled(bool* isKilled) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const*, char const*) {
+NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
+                                           char const* value) {
+  nsDependentCString n(name);
+  nsDependentCString v(value);
+  if (n.EqualsLiteral("storeToken")) {
+    return DB().SetMsgStoreToken(mKey, v);
+  }
+
+  printf("XYZZY: ignoring nsMsgHdr2::SetStringProperty('%s')\n", name);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const*, char**) {
+NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const* name, char** value) {
+  nsDependentCString n(name);
+  if (n.EqualsLiteral("storeToken")) {
+    nsAutoCString tmp;
+    nsresult rv = DB().FetchMsgStoreToken(mKey, tmp);
+    *value = moz_xstrdup(tmp.get());
+    return rv;
+  }
+
+  printf("XYZZY: ignoring nsMsgHdr2::GetStringProperty('%s')\n", name);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
-NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const*, unsigned int*) {
+NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const* name,
+                                           unsigned int* value) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
-NS_IMETHODIMP nsMsgHdr2::SetUint32Property(char const*, unsigned int) {
+NS_IMETHODIMP nsMsgHdr2::SetUint32Property(char const* name,
+                                           unsigned int value) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetProperties(nsTArray<nsTString<char>>&) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670472652 -46800
#      Thu Dec 08 17:10:52 2022 +1300
# Node ID 675148b4cf3382d78cecf8516fb2bd76ee5a3ab9
# Parent  b88f2d994c1743bce8fd71daf4cc629dd9218191
WIP: start using nsMsgDatabase2, more stubbing...

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -28,16 +28,34 @@ class MsgEnumerator : public nsBaseMsgEn
   }
 
  protected:
   GlobalDB* mGlobalDB;
   nsTArray<nsMsgKey> const& mKeys;
   size_t mCur;
 };
 
+// TODO
+class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
+ public:
+  explicit ThreadEnumerator(GlobalDB* db) : mGlobalDB(db) {}
+  ThreadEnumerator() = delete;
+
+  // nsIMsgThreadEnumerator support.
+  NS_IMETHOD GetNext(nsIMsgThread** aItem) override { return NS_ERROR_FAILURE; }
+
+  NS_IMETHOD HasMoreElements(bool* aResult) override {
+    *aResult = false;
+    return NS_OK;
+  }
+
+ protected:
+  GlobalDB* mGlobalDB;
+};
+
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
 GlobalDB::~GlobalDB() {
   mStmtCache.FinalizeStatements();
@@ -912,11 +930,31 @@ nsresult GlobalDB::FolderReverseEnumerat
   keys.Reverse();
   RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
   e.forget(result);
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderEnumerateMsgsFiltered(
     nsFolderKey folderID, const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms,
-    bool aReverse, nsIMsgEnumerator** aResult) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+    bool aReverse, nsIMsgEnumerator** result) {
+  // TODO
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
+  e.forget(result);
+  return NS_OK;
 }
+
+nsresult GlobalDB::FolderEnumerateMsgsWithFlag(nsFolderKey folderID,
+                                               uint32_t flag,
+                                               nsIMsgEnumerator** result) {
+  // TODO
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
+  e.forget(result);
+  return NS_OK;
+}
+
+nsresult GlobalDB::FolderEnumerateThreads(nsFolderKey folderID,
+                                          nsIMsgThreadEnumerator** result) {
+  // TODO
+  RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this);
+  e.forget(result);
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -49,16 +49,17 @@ struct RawHdr {
   int enigmail{0};
   int notAPhishMessage{0};
 };
 
 class nsIMsgDBHdr;
 class nsIDBChangeListener;
 class nsMsgHdr2;
 class nsIMsgEnumerator;
+class nsIMsgThreadEnumerator;
 class nsIMsgSearchTerm;
 
 class GlobalDB {
  public:
   static GlobalDB& get();
 
   GlobalDB();
   ~GlobalDB();
@@ -146,16 +147,20 @@ class GlobalDB {
 
   nsresult FolderEnumerateMsgs(nsFolderKey folderID, nsIMsgEnumerator** result);
   nsresult FolderReverseEnumerateMsgs(nsFolderKey folderID,
                                       nsIMsgEnumerator** result);
   nsresult FolderEnumerateMsgsFiltered(
       nsFolderKey folderID,
       const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
       nsIMsgEnumerator** aResult);
+  nsresult FolderEnumerateMsgsWithFlag(nsFolderKey folderID, uint32_t flag,
+                                       nsIMsgEnumerator** result);
+  nsresult FolderEnumerateThreads(nsFolderKey folderID,
+                                  nsIMsgThreadEnumerator** result);
 
  private:
   nsresult InitSchema();
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
--- a/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
@@ -7,17 +7,17 @@
 #include "nsDBFolderInfo2.h"
 #include "nsMsgDatabase2.h"
 #include "nsMsgFolderFlags.h"
 // #include "nsIPrefService.h"
 // #include "nsIPrefBranch.h"
 // #include "nsIPrefLocalizedString.h"
 // #include "nsIObserver.h"
 // #include "nsIObserverService.h"
-// #include "nsIMsgDBView.h"
+#include "nsIMsgDBView.h"
 #include "nsServiceManagerUtils.h"
 #include "nsImapCore.h"
 
 NS_IMPL_ADDREF(nsDBFolderInfo2)
 NS_IMPL_RELEASE(nsDBFolderInfo2)
 
 NS_IMETHODIMP
 nsDBFolderInfo2::QueryInterface(REFNSIID iid, void** result) {
@@ -30,46 +30,46 @@ nsDBFolderInfo2::QueryInterface(REFNSIID
     AddRef();
     return NS_OK;
   }
   return NS_NOINTERFACE;
 }
 
 nsDBFolderInfo2::nsDBFolderInfo2(nsMsgDatabase2* mdb)
     : m_flags(0), m_expiredMark(0) {
+  m_mdb = mdb;
   m_version = 1;                 // for upgrading...
   m_IMAPHierarchySeparator = 0;  // imap path separator
   // mail only (for now)
   m_folderSize = 0;
   m_folderDate = 0;
   m_expungedBytes = 0;  // sum of size of deleted messages in folder
   m_highWaterMessageKey = 0;
 
   m_numUnreadMessages = 0;
   m_numMessages = 0;
   // IMAP only
   m_ImapUidValidity = kUidUnknown;
   m_totalPendingMessages = 0;
   m_unreadPendingMessages = 0;
 
-  m_mdb = mdb;
+  mSortOrder = nsMsgViewSortOrder::none;
+  mSortType = nsMsgViewSortType::byNone;
+  mViewType = nsMsgViewType::eShowAllThreads;
 }
 
 nsDBFolderInfo2::~nsDBFolderInfo2() {}
 
-nsresult nsDBFolderInfo2::InitFromExistingDB() {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
+nsresult nsDBFolderInfo2::InitFromExistingDB() { return NS_OK; }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetVersion(uint32_t version) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
+NS_IMETHODIMP nsDBFolderInfo2::SetVersion(uint32_t version) { return NS_OK; }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetVersion(uint32_t* version) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *version = 42;
+  return NS_OK;
 }
 
 nsresult nsDBFolderInfo2::AdjustHighWater(nsMsgKey highWater, bool force) {
   if (force || m_highWaterMessageKey < highWater) {
     m_highWaterMessageKey = highWater;
     return NS_ERROR_NOT_IMPLEMENTED;
   }
 
@@ -81,22 +81,21 @@ NS_IMETHODIMP nsDBFolderInfo2::SetHighWa
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::OnKeyAdded(nsMsgKey aNewKey) {
   return AdjustHighWater(aNewKey, false);
 }
 
 NS_IMETHODIMP
 nsDBFolderInfo2::GetFolderSize(int64_t* size) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *size = 42;
+  return NS_OK;
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetFolderSize(int64_t size) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
+NS_IMETHODIMP nsDBFolderInfo2::SetFolderSize(int64_t size) { return NS_OK; }
 
 NS_IMETHODIMP
 nsDBFolderInfo2::GetFolderDate(uint32_t* folderDate) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetFolderDate(uint32_t folderDate) {
   m_folderDate = folderDate;
@@ -116,102 +115,131 @@ NS_IMETHODIMP nsDBFolderInfo2::GetExpire
 }
 
 // The size of the argument depends on the maximum size of a single message
 NS_IMETHODIMP nsDBFolderInfo2::ChangeExpungedBytes(int32_t delta) {
   return SetExpungedBytes(m_expungedBytes + delta);
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetMailboxName(const nsAString& newBoxName) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  mMailboxName = newBoxName;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetMailboxName(nsAString& boxName) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  boxName = mMailboxName;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::ChangeNumUnreadMessages(int32_t delta) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::ChangeNumMessages(int32_t delta) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetNumUnreadMessages(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetNumUnreadMessages(int32_t numUnreadMessages) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetNumMessages(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetNumMessages(int32_t numMessages) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetExpungedBytes(int64_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetExpungedBytes(int64_t expungedBytes) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetFlags(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetFlags(int32_t flags) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::OrFlags(int32_t flags, int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::AndFlags(int32_t flags, int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetImapUidValidity(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetImapUidValidity(int32_t uidValidity) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 bool nsDBFolderInfo2::TestFlag(int32_t flags) { return (m_flags & flags) != 0; }
 
 NS_IMETHODIMP
 nsDBFolderInfo2::GetLocale(nsAString& result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetLocale(const nsAString& locale) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsDBFolderInfo2::GetImapTotalPendingMessages(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 void nsDBFolderInfo2::ChangeImapTotalPendingMessages(int32_t delta) {
-  MOZ_ASSERT(false);
+  // TODO
 }
 
 NS_IMETHODIMP
 nsDBFolderInfo2::GetImapUnreadPendingMessages(int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  *result = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetImapUnreadPendingMessages(
     int32_t numUnreadPendingMessages) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetImapTotalPendingMessages(
@@ -219,121 +247,164 @@ NS_IMETHODIMP nsDBFolderInfo2::SetImapTo
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 void nsDBFolderInfo2::ChangeImapUnreadPendingMessages(int32_t delta) {
   MOZ_ASSERT(false);
 }
 
 /* attribute nsMsgViewTypeValue viewType; */
-NS_IMETHODIMP nsDBFolderInfo2::GetViewType(nsMsgViewTypeValue* aViewType) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+NS_IMETHODIMP nsDBFolderInfo2::GetViewType(nsMsgViewTypeValue* viewType) {
+  *viewType = mViewType;
+  return NS_OK;
 }
-NS_IMETHODIMP nsDBFolderInfo2::SetViewType(nsMsgViewTypeValue aViewType) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+NS_IMETHODIMP nsDBFolderInfo2::SetViewType(nsMsgViewTypeValue viewType) {
+  // TODO
+  mViewType = viewType;
+  return NS_OK;
 }
 
 /* attribute nsMsgViewFlagsTypeValue viewFlags; */
 NS_IMETHODIMP nsDBFolderInfo2::GetViewFlags(
-    nsMsgViewFlagsTypeValue* aViewFlags) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+    nsMsgViewFlagsTypeValue* viewFlags) {
+  // TODO
+  *viewFlags = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetViewFlags(
     nsMsgViewFlagsTypeValue aViewFlags) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 /* attribute nsMsgViewSortTypeValue sortType; */
-NS_IMETHODIMP nsDBFolderInfo2::GetSortType(nsMsgViewSortTypeValue* aSortType) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+NS_IMETHODIMP nsDBFolderInfo2::GetSortType(nsMsgViewSortTypeValue* sortType) {
+  if (mSortType != nsMsgViewSortType::byNone) {
+    *sortType = mSortType;
+    return NS_OK;
+  }
+  return m_mdb->GetDefaultSortType(sortType);
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetSortType(nsMsgViewSortTypeValue aSortType) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+NS_IMETHODIMP nsDBFolderInfo2::SetSortType(nsMsgViewSortTypeValue sortType) {
+  mSortType = sortType;
+  return NS_OK;
 }
 
 /* attribute nsMsgViewSortOrderValue sortOrder; */
 NS_IMETHODIMP nsDBFolderInfo2::GetSortOrder(
-    nsMsgViewSortOrderValue* aSortOrder) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+    nsMsgViewSortOrderValue* sortOrder) {
+  if (mSortOrder != nsMsgViewSortOrder::none) {
+    *sortOrder = mSortOrder;
+    return NS_OK;
+  }
+  return m_mdb->GetDefaultSortOrder(sortOrder);
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetSortOrder(
-    nsMsgViewSortOrderValue aSortOrder) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+NS_IMETHODIMP nsDBFolderInfo2::SetSortOrder(nsMsgViewSortOrderValue sortOrder) {
+  mSortOrder = sortOrder;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetKnownArtsSet(const char* newsArtSet) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetKnownArtsSet(char** newsArtSet) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetProperty(const char* propertyName,
                                            const nsAString& propertyStr) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::SetProperty(%s)\n", propertyName);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetProperty(const char* propertyName,
                                            nsAString& resultProperty) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  printf("XYZZY nsDBFolderInfo2::GetProperty(%s)\n", propertyName);
+  resultProperty.Truncate();
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetCharProperty(
-    const char* aPropertyName, const nsACString& aPropertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+    const char* propertyName, const nsACString& propertyValue) {
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::SetCharProperty(%s,%s)\n", propertyName,
+         PromiseFlatCString(propertyValue).get());
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetCharProperty(const char* propertyName,
                                                nsACString& resultProperty) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  resultProperty = "";
+  printf("XYZZY nsDBFolderInfo2::GetCharProperty(%s)\n", propertyName);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetUint32Property(const char* propertyName,
                                                  uint32_t propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::SetUint32Property(%s,%" PRIu32 ")\n",
+         propertyName, propertyValue);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetInt64Property(const char* propertyName,
                                                 int64_t propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::SetInt64Property(%s,%" PRId64 ")\n",
+         propertyName, propertyValue);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetUint32Property(const char* propertyName,
                                                  uint32_t defaultValue,
                                                  uint32_t* propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  printf("XYZZY nsDBFolderInfo2::GetCharProperty(%s)\n", propertyName);
+  *propertyValue = defaultValue;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetInt64Property(const char* propertyName,
                                                 int64_t defaultValue,
                                                 int64_t* propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::GetInt64Property(%s)\n", propertyName);
+  *propertyValue = defaultValue;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetBooleanProperty(const char* propertyName,
                                                   bool defaultValue,
                                                   bool* propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  printf("XYZZY nsDBFolderInfo2::GetBooleanProperty(%s)\n", propertyName);
+  *propertyValue = defaultValue;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetBooleanProperty(const char* propertyName,
                                                   bool propertyValue) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetFolderName(nsACString& folderName) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  folderName = mFolderName;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::SetFolderName(const nsACString& folderName) {
-  return SetCharProperty("folderName", folderName);
+  mFolderName = folderName;
+  return NS_OK;
+  //  return SetCharProperty("folderName", folderName);
 }
 
 /* void GetTransferInfo (out nsIDBFolderInfo transferInfo); */
 NS_IMETHODIMP nsDBFolderInfo2::GetTransferInfo(nsIDBFolderInfo** transferInfo) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /* void InitFromTransferInfo (in nsIDBFolderInfo transferInfo); */
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.h b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
--- a/mailnews/db/msgdb/src/nsDBFolderInfo2.h
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
@@ -37,20 +37,16 @@ class nsDBFolderInfo2 : public nsIDBFold
 
   nsresult InitFromExistingDB();
 
   nsTArray<nsMsgKey> m_lateredKeys;  // list of latered messages
 
  protected:
   virtual ~nsDBFolderInfo2();
 
-  // initialize from appropriate table and row in existing db.
-  nsresult InitMDBInfo();
-  nsresult LoadMemberVariables();
-
   nsresult AdjustHighWater(nsMsgKey highWater, bool force);
 
   nsMsgDatabase2* m_mdb;
 
   int64_t m_folderSize;
   int64_t m_expungedBytes;  // sum of size of deleted messages in folder
   uint32_t m_folderDate;
   nsMsgKey m_highWaterMessageKey;  // largest news article number or imap uid
@@ -74,11 +70,18 @@ class nsDBFolderInfo2 : public nsIDBFold
   // IMAP only
   int32_t m_ImapUidValidity;
   int32_t m_totalPendingMessages;
   int32_t m_unreadPendingMessages;
 
   // news only (for now)
   // Highest invalid article number in group - for expiring
   nsMsgKey m_expiredMark;
+
+  // TODO: should persist!
+  nsMsgViewSortOrderValue mSortOrder;
+  nsMsgViewSortTypeValue mSortType;
+  nsMsgViewTypeValue mViewType;
+  nsString mMailboxName;
+  nsCString mFolderName;
 };
 
 #endif
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -4,16 +4,17 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // this file implements the nsMsgDatabase interface using the MDB Interface.
 
 #include "nscore.h"
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "nsMailDatabase.h"
+#include "nsMsgDatabase2.h"
 #include "nsDBFolderInfo.h"
 #include "nsIMsgNewsFolder.h"
 #include "nsMsgThread.h"
 #include "nsIMsgSearchTerm.h"
 #include "nsIMdbFactoryFactory.h"
 #include "mozilla/Logging.h"
 #include "mozilla/Telemetry.h"
 #include "prprf.h"
@@ -135,16 +136,21 @@ nsMsgDBService::~nsMsgDBService() {
   }
 #  endif
 #endif
 }
 
 NS_IMETHODIMP nsMsgDBService::OpenFolderDB(nsIMsgFolder* aFolder,
                                            bool aLeaveInvalidDB,
                                            nsIMsgDatabase** _retval) {
+  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
+  db.forget(_retval);
+  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
+  return NS_OK;
+#if 0
   NS_ENSURE_ARG(aFolder);
   nsCOMPtr<nsIMsgIncomingServer> incomingServer;
   nsresult rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> summaryFilePath;
   rv = aFolder->GetSummaryFile(getter_AddRefs(summaryFilePath));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -174,33 +180,34 @@ NS_IMETHODIMP nsMsgDBService::OpenFolder
   nsMsgDatabase* msgDatabase = static_cast<nsMsgDatabase*>(msgDB.get());
   msgDatabase->m_folder = aFolder;
   rv = msgDatabase->Open(this, summaryFilePath, false, aLeaveInvalidDB);
   if (NS_FAILED(rv) && rv != NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE) return rv;
 
   NS_ADDREF(*_retval = msgDB);
 
   if (NS_FAILED(rv)) {
-#ifdef DEBUG
+#  ifdef DEBUG
     // Doing these checks for debug only as we don't want to report certain
     // errors in debug mode, but in release mode we wouldn't report them either
 
     // These errors are expected.
     if (rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING ||
         rv == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE)
       return rv;
 
     // If it isn't one of the expected errors, throw a warning.
     NS_ENSURE_SUCCESS(rv, rv);
-#endif
+#  endif
     return rv;
   }
 
   FinishDBOpen(aFolder, msgDatabase);
   return rv;
+#endif
 }
 
 /**
  * When a db is opened, we need to hook up any pending listeners for
  * that db, and notify them.
  */
 void nsMsgDBService::HookupPendingListeners(nsIMsgDatabase* db,
                                             nsIMsgFolder* folder) {
@@ -253,16 +260,21 @@ nsMsgDatabase* nsMsgDBService::FindInCac
 // having a corresponding nsIMsgFolder object.  This happens in a few
 // situations, including imap folder discovery, compacting local folders,
 // and copying local folders.
 NS_IMETHODIMP nsMsgDBService::OpenMailDBFromFile(nsIFile* aFolderName,
                                                  nsIMsgFolder* aFolder,
                                                  bool aCreate,
                                                  bool aLeaveInvalidDB,
                                                  nsIMsgDatabase** pMessageDB) {
+  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
+  db.forget(pMessageDB);
+  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
+  return NS_OK;
+#if 0
   if (!aFolderName) return NS_ERROR_NULL_POINTER;
 
   nsCOMPtr<nsIFile> dbPath;
   nsresult rv = GetSummaryFileLocation(aFolderName, getter_AddRefs(dbPath));
   NS_ENSURE_SUCCESS(rv, rv);
 
   *pMessageDB = FindInCache(dbPath);
   if (*pMessageDB) return NS_OK;
@@ -270,20 +282,26 @@ NS_IMETHODIMP nsMsgDBService::OpenMailDB
   RefPtr<nsMailDatabase> msgDB = new nsMailDatabase;
   NS_ENSURE_TRUE(msgDB, NS_ERROR_OUT_OF_MEMORY);
   rv = msgDB->Open(this, dbPath, aCreate, aLeaveInvalidDB);
   if (rv == NS_ERROR_FILE_NOT_FOUND) return rv;
   NS_IF_ADDREF(*pMessageDB = msgDB);
   if (aCreate && msgDB && rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) rv = NS_OK;
   if (NS_SUCCEEDED(rv)) msgDB->m_folder = aFolder;
   return rv;
+#endif
 }
 
 NS_IMETHODIMP nsMsgDBService::CreateNewDB(nsIMsgFolder* aFolder,
                                           nsIMsgDatabase** _retval) {
+  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
+  db.forget(_retval);
+  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
+  return NS_OK;
+#if 0
   NS_ENSURE_ARG(aFolder);
 
   nsCOMPtr<nsIMsgIncomingServer> incomingServer;
   nsresult rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> summaryFilePath;
   rv = aFolder->GetSummaryFile(getter_AddRefs(summaryFilePath));
@@ -313,16 +331,17 @@ NS_IMETHODIMP nsMsgDBService::CreateNewD
 
   NS_ADDREF(*_retval = msgDB);
 
   HookupPendingListeners(msgDB, aFolder);
 
   msgDatabase->RememberLastUseTime();
 
   return NS_OK;
+#endif
 }
 
 /* void registerPendingListener (in nsIMsgFolder aFolder, in nsIDBChangeListener
  * aListener); */
 NS_IMETHODIMP nsMsgDBService::RegisterPendingListener(
     nsIMsgFolder* aFolder, nsIDBChangeListener* aListener) {
   // need to make sure we don't hold onto these forever. Maybe a shutdown
   // listener? if there is a db open on this folder already, we should register
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -58,41 +58,41 @@ void nsMsgDatabase2::GetGlobalPrefs() {
     GetBoolPref("mail.strict_threading", &gStrictThreading);
     GetBoolPref("mail.correct_threading", &gCorrectThreading);
     gGotGlobalPrefs = true;
   }
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ForceClosed() { return NS_ERROR_NOT_IMPLEMENTED; }
 
-NS_IMETHODIMP nsMsgDatabase2::ClearCachedHdrs() {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
+NS_IMETHODIMP nsMsgDatabase2::ClearCachedHdrs() { return NS_OK; }
 
 NS_IMETHODIMP nsMsgDatabase2::SetMsgHdrCacheSize(uint32_t aSize) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrCacheSize(uint32_t* aSize) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *aSize = 0;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetLastUseTime(PRTime* aTime) {
   NS_ENSURE_ARG_POINTER(aTime);
   *aTime = m_lastUseTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::SetLastUseTime(PRTime aTime) {
   sLastUseTime = m_lastUseTime = aTime;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetDatabaseSize(int64_t* _retval) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *_retval = 0;
+  return NS_OK;
 }
 
 nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
   NS_ENSURE_ARG_POINTER(result);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
   msgHdr.forget(result);
   return NS_OK;
@@ -180,47 +180,45 @@ NS_IMETHODIMP nsMsgDatabase2::NotifyPare
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::NotifyAnnouncerGoingAway(void) {
   NOTIFY_LISTENERS(OnAnnouncerGoingAway, (this));
   return NS_OK;
 }
 
-nsMsgDatabase2::nsMsgDatabase2()
-    : m_dbFolderInfo(nullptr), m_nextPseudoMsgKey(kFirstPseudoKey) {}
+nsMsgDatabase2::nsMsgDatabase2(nsIMsgFolder* folder)
+    : m_folder(folder), m_nextPseudoMsgKey(kFirstPseudoKey) {
+  mGlobalDB = &GlobalDB::get();
+  m_dbFolderInfo = new nsDBFolderInfo2(this);
+}
 
 nsMsgDatabase2::~nsMsgDatabase2() {
   m_dbFolderInfo = nullptr;
   m_ChangeListeners.Clear();
 }
 
 NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIDBChangeAnnouncer)
 
 NS_IMETHODIMP nsMsgDatabase2::GetDBFolderInfo(nsIDBFolderInfo** result) {
-  if (!m_dbFolderInfo) {
-    NS_ERROR("db must be corrupt");
-    return NS_ERROR_NULL_POINTER;
-  }
+  MOZ_ASSERT(m_dbFolderInfo);
   NS_ADDREF(*result = m_dbFolderInfo);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetFolder(nsIMsgFolder** aFolder) {
   NS_ENSURE_ARG_POINTER(aFolder);
   NS_IF_ADDREF(*aFolder = m_folder);
   return NS_OK;
 }
 
-NS_IMETHODIMP nsMsgDatabase2::Commit(nsMsgDBCommit commitType) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
+NS_IMETHODIMP nsMsgDatabase2::Commit(nsMsgDBCommit commitType) { return NS_OK; }
 
 NS_IMETHODIMP nsMsgDatabase2::Close(bool forceCommit /* = TRUE */) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 // Returns if the db contains this key
 NS_IMETHODIMP nsMsgDatabase2::ContainsKey(nsMsgKey key, bool* containsKey) {
   return DB().FolderContainsKey(mFolderID, key, containsKey);
 }
 
 // get a message header for the given key. Caller must release()!
@@ -288,17 +286,18 @@ NS_IMETHODIMP nsMsgDatabase2::DeleteHead
 NS_IMETHODIMP nsMsgDatabase2::UndoDelete(nsIMsgDBHdr* aMsgHdr) {
   nsMsgKey key;
   nsresult rv = aMsgHdr->GetMessageKey(&key);
   NS_ENSURE_SUCCESS(rv, rv);
   return DB().FolderUndoDelete(mFolderID, key);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::RemoveHeaderMdbRow(nsIMsgDBHdr* msg) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsRead(nsMsgKey key, bool* isRead) {
   return DB().FetchMsgIsRead(key, isRead);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsMarked(nsMsgKey key, bool* isMarked) {
   return DB().FetchMsgIsMarked(key, isMarked);
@@ -354,24 +353,26 @@ NS_IMETHODIMP nsMsgDatabase2::MarkHasAtt
   return DB().SetMsgFlag(key, bHasAttachments, nsMsgMessageFlags::Attachment,
                          instigator);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::MarkThreadRead(nsIMsgThread* thread,
                                nsIDBChangeListener* instigator,
                                nsTArray<nsMsgKey>& aThoseMarkedRead) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::MarkThreadIgnored(nsIMsgThread* thread, nsMsgKey threadKey,
                                   bool bIgnored,
                                   nsIDBChangeListener* instigator) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::MarkHeaderKilled(nsIMsgDBHdr* msg, bool bIgnored,
                                  nsIDBChangeListener* instigator) {
   uint32_t msgFlags;
   msg->GetFlags(&msgFlags);
   uint32_t oldFlags = msgFlags;
@@ -568,17 +569,18 @@ nsresult nsMsgDatabase2::IsMDNSent(nsMsg
   uint32_t flags;
   (void)msgHdr->GetFlags(&flags);
   *pSent = !!(flags & nsMsgMessageFlags::MDNReportSent);
   return rv;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::MarkHdrRead(nsIMsgDBHdr* msgHdr, bool bRead,
                                           nsIDBChangeListener* instigator) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::MarkHdrReplied(nsIMsgDBHdr* msgHdr, bool bReplied,
                                              nsIDBChangeListener* instigator) {
   nsMsgKey key;
   msgHdr->GetMessageKey(&key);
   return DB().SetMsgFlag(key, bReplied, nsMsgMessageFlags::Replied, instigator);
 }
@@ -594,29 +596,34 @@ NS_IMETHODIMP
 nsMsgDatabase2::MarkHdrNotNew(nsIMsgDBHdr* msgHdr,
                               nsIDBChangeListener* aInstigator) {
   nsMsgKey key;
   msgHdr->GetMessageKey(&key);
   return DB().SetMsgFlag(key, false, nsMsgMessageFlags::New, aInstigator);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::MarkAllRead(nsTArray<nsMsgKey>& aThoseMarked) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddToNewList(nsMsgKey key) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ClearNewList(bool notify /* = FALSE */) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::HasNew(bool* _retval) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
+  // TODO
+  *_retval = false;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetFirstNew(nsMsgKey* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateMessages(nsIMsgEnumerator** result) {
@@ -633,31 +640,32 @@ nsMsgDatabase2::GetFilterEnumerator(
     const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool reverse,
     nsIMsgEnumerator** result) {
   return DB().FolderEnumerateMsgsFiltered(mFolderID, searchTerms, reverse,
                                           result);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::SyncCounts() {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
   return DB().FolderListAllKeys(mFolderID, keys);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FolderEnumerateThreads(mFolderID, result);
 }
 
 nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                                    uint32_t* pFlag) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FolderEnumerateMsgsWithFlag(mFolderID, *pFlag, result);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key,
                                            nsIMsgDBHdr** pnewHdr) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
@@ -679,20 +687,20 @@ nsMsgDatabase2::CompareCollationKeys(con
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::CreateCollationKey(const nsAString& sourceString,
                                    nsTArray<uint8_t>& key) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
-uint32_t nsMsgDatabase2::GetCurVersion() { return kMsgDBVersion; }
+uint32_t nsMsgDatabase2::GetCurVersion() { return 42; /*kMsgDBVersion;*/ }
 
 NS_IMETHODIMP nsMsgDatabase2::SetSummaryValid(bool valid /* = true */) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return NS_OK;  // NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetSummaryValid(bool* aResult) {
   NS_ENSURE_ARG_POINTER(aResult);
   *aResult = true;
   return NS_OK;
 }
 
@@ -808,17 +816,17 @@ nsMsgDatabase2::SetUint64AttributeOnPend
 NS_IMETHODIMP
 nsMsgDatabase2::UpdatePendingAttributes(nsIMsgDBHdr* aNewHdr) { return NS_OK; }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllOfflineMsgs(nsTArray<nsMsgKey>& keys) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetHighWaterArticleNum(nsMsgKey* key) {
-  if (!m_dbFolderInfo) return NS_ERROR_NULL_POINTER;
+  MOZ_ASSERT(m_dbFolderInfo);
   return m_dbFolderInfo->GetHighWater(key);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetLowWaterArticleNum(nsMsgKey* key) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 /* attribute nsMsgKey NextPseudoMsgKey */
@@ -922,27 +930,29 @@ NS_IMETHODIMP nsMsgDatabase2::SetMsgRete
 
 NS_IMETHODIMP nsMsgDatabase2::GetMsgRetentionSettings(
     nsIMsgRetentionSettings** retentionSettings) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::SetMsgDownloadSettings(
     nsIMsgDownloadSettings* downloadSettings) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetMsgDownloadSettings(
     nsIMsgDownloadSettings** downloadSettings) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ApplyRetentionSettings(
     nsIMsgRetentionSettings* aMsgRetentionSettings, bool aDeleteViaFolder) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetDefaultViewFlags(
     nsMsgViewFlagsTypeValue* aDefaultViewFlags) {
   NS_ENSURE_ARG_POINTER(aDefaultViewFlags);
   GetIntPref("mailnews.default_view_flags", aDefaultViewFlags);
   if (*aDefaultViewFlags < nsMsgViewFlagsType::kNone ||
       *aDefaultViewFlags >
@@ -968,39 +978,41 @@ NS_IMETHODIMP nsMsgDatabase2::GetDefault
   NS_ENSURE_ARG_POINTER(aDefaultSortOrder);
   GetIntPref("mailnews.default_sort_order", aDefaultSortOrder);
   if (*aDefaultSortOrder != nsMsgViewSortOrder::descending)
     *aDefaultSortOrder = nsMsgViewSortOrder::ascending;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ResetHdrCacheSize(uint32_t aSize) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::GetNewList(nsTArray<nsMsgKey>& aNewKeys) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::GetCachedHits(const nsACString& aSearchFolderUri,
                               nsIMsgEnumerator** aEnumerator) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::RefreshCache(const nsACString& aSearchFolderUri,
                                            nsTArray<nsMsgKey> const& aNewHits,
                                            nsTArray<nsMsgKey>& aStaleHits) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::UpdateHdrInCache(const nsACString& aSearchFolderUri,
                                  nsIMsgDBHdr* aHdr, bool aAdd) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::HdrIsInCache(const nsACString& aSearchFolderUri,
                              nsIMsgDBHdr* aHdr, bool* aResult) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  *aResult = false;
+  return NS_OK;
 }
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.h
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -25,34 +25,34 @@
 #include "nsTObserverArray.h"
 
 using mozilla::intl::Collator;
 
 class nsMsgThread;
 class nsMsgDatabase2;
 class nsIMsgThread;
 
-const int32_t kMsgDBVersion = 1;
-
 class nsMsgDatabase2 : public nsIMsgDatabase {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDBCHANGEANNOUNCER
   NS_DECL_NSIMSGDATABASE
 
+  explicit nsMsgDatabase2(nsIMsgFolder* folder);
+  nsMsgDatabase2() = delete;
+
   virtual nsresult MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool bRead,
                                    nsIDBChangeListener* instigator);
   virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
   virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
   virtual nsresult EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                              uint32_t* pFlag);
 
   //////////////////////////////////////////////////////////////////////////////
   // nsMsgDatabase2 methods:
-  nsMsgDatabase2();
 
   virtual uint32_t GetCurVersion();
   nsresult GetCollationKeyGenerator();
   nsIMimeConverter* GetMimeConverter();
 
 #ifdef DEBUG
   virtual nsresult DumpContents();
 #endif
diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -340,16 +340,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::GetD
     }
   }
   NS_IF_ADDREF(*aMsgDatabase = mDatabase);
   return rv;
 }
 
 NS_IMETHODIMP
 nsMsgLocalMailFolder::UpdateFolder(nsIMsgWindow* aWindow) {
+  printf("XYZZY UpdateFolder()\n");
   (void)RefreshSizeOnDisk();
   nsresult rv;
 
   if (!PromptForMasterPasswordIfNecessary()) return NS_ERROR_FAILURE;
 
   // If we don't currently have a database, get it.  Otherwise, the folder has
   // been updated (presumably this changes when we download headers when opening
   // inbox).  If it's updated, send NotifyFolderLoaded.
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670474167 -46800
#      Thu Dec 08 17:36:07 2022 +1300
# Node ID 7f7c2816a3b608eec604b7ff53933c047f3f241f
# Parent  675148b4cf3382d78cecf8516fb2bd76ee5a3ab9
WIP: add nsIMsgOfflineOpsDatabase interface to nsMsgDatabase2

diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -44,16 +44,19 @@ static const nsMsgKey kFirstPseudoKey = 
 
 // LazyLogModule DBLog("MsgDB"); // just use original one for now...
 
 static bool gGotGlobalPrefs = false;
 static bool gThreadWithoutRe = true;
 static bool gStrictThreading = false;
 static bool gCorrectThreading = false;
 
+NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIMsgOfflineOpsDatabase,
+                  nsIDBChangeAnnouncer)
+
 // static
 PRTime nsMsgDatabase2::sLastUseTime;
 
 void nsMsgDatabase2::GetGlobalPrefs() {
   if (!gGotGlobalPrefs) {
     GetBoolPref("mail.thread_without_re", &gThreadWithoutRe);
     GetBoolPref("mail.strict_threading", &gStrictThreading);
     GetBoolPref("mail.correct_threading", &gCorrectThreading);
@@ -191,18 +194,16 @@ nsMsgDatabase2::nsMsgDatabase2(nsIMsgFol
   m_dbFolderInfo = new nsDBFolderInfo2(this);
 }
 
 nsMsgDatabase2::~nsMsgDatabase2() {
   m_dbFolderInfo = nullptr;
   m_ChangeListeners.Clear();
 }
 
-NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIDBChangeAnnouncer)
-
 NS_IMETHODIMP nsMsgDatabase2::GetDBFolderInfo(nsIDBFolderInfo** result) {
   MOZ_ASSERT(m_dbFolderInfo);
   NS_ADDREF(*result = m_dbFolderInfo);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetFolder(nsIMsgFolder** aFolder) {
   NS_ENSURE_ARG_POINTER(aFolder);
@@ -1011,8 +1012,32 @@ nsMsgDatabase2::UpdateHdrInCache(const n
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::HdrIsInCache(const nsACString& aSearchFolderUri,
                              nsIMsgDBHdr* aHdr, bool* aResult) {
   *aResult = false;
   return NS_OK;
 }
+
+// nsIMsgOfflineOpsDatabase implementation
+NS_IMETHODIMP nsMsgDatabase2::GetOfflineOpForKey(
+    nsMsgKey msgKey, bool create, nsIMsgOfflineImapOperation** offlineOp) {
+  NS_ASSERTION(false, "overridden by nsMailDatabase");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::RemoveOfflineOp(nsIMsgOfflineImapOperation* op) {
+  NS_ASSERTION(false, "overridden by nsMailDatabase");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ListAllOfflineOpIds(
+    nsTArray<nsMsgKey>& offlineOpIds) {
+  offlineOpIds.Clear();
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ListAllOfflineDeletes(
+    nsTArray<nsMsgKey>& offlineDeletes) {
+  // technically, notimplemented, but no one's putting offline ops in anyway.
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.h
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -25,21 +25,22 @@
 #include "nsTObserverArray.h"
 
 using mozilla::intl::Collator;
 
 class nsMsgThread;
 class nsMsgDatabase2;
 class nsIMsgThread;
 
-class nsMsgDatabase2 : public nsIMsgDatabase {
+class nsMsgDatabase2 : public nsIMsgOfflineOpsDatabase {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDBCHANGEANNOUNCER
   NS_DECL_NSIMSGDATABASE
+  NS_DECL_NSIMSGOFFLINEOPSDATABASE
 
   explicit nsMsgDatabase2(nsIMsgFolder* folder);
   nsMsgDatabase2() = delete;
 
   virtual nsresult MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool bRead,
                                    nsIDBChangeListener* instigator);
   virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
   virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670565065 -46800
#      Fri Dec 09 18:51:05 2022 +1300
# Node ID 2bf7374aac76d5763b9f4c7ec478eb81e8ab92a4
# Parent  7f7c2816a3b608eec604b7ff53933c047f3f241f
WIP: support set/get generic properties on folder. Reluctantly.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -6,17 +6,19 @@
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgEnumerator.h"
 
 class MsgEnumerator : public nsBaseMsgEnumerator {
  public:
   MsgEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& keys)
-      : mGlobalDB(db), mKeys(keys), mCur(0){};
+      : mGlobalDB(db), mKeys(keys), mCur(0) {
+    printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
+  };
   MsgEnumerator() = delete;
 
   // nsIMsgEnumerator support.
   NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
     MOZ_ASSERT(mCur < mKeys.Length());
     RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mGlobalDB, mKeys[mCur++]);
     hdr.forget(aItem);
     return NS_OK;
@@ -31,17 +33,19 @@ class MsgEnumerator : public nsBaseMsgEn
   GlobalDB* mGlobalDB;
   nsTArray<nsMsgKey> const& mKeys;
   size_t mCur;
 };
 
 // TODO
 class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
  public:
-  explicit ThreadEnumerator(GlobalDB* db) : mGlobalDB(db) {}
+  explicit ThreadEnumerator(GlobalDB* db) : mGlobalDB(db) {
+    printf("XYZZY: ThreadEnumerator ctor\n");
+  }
   ThreadEnumerator() = delete;
 
   // nsIMsgThreadEnumerator support.
   NS_IMETHOD GetNext(nsIMsgThread** aItem) override { return NS_ERROR_FAILURE; }
 
   NS_IMETHOD HasMoreElements(bool* aResult) override {
     *aResult = false;
     return NS_OK;
@@ -175,16 +179,38 @@ nsresult GlobalDB::InitSchema() {
     const nsLiteralCString create_msg_folder(
         "CREATE TABLE msg_folder ( "
         "msg_id INTEGER NOT NULL, "
         "folder_id INTEGER NOT NULL "
         ")");
     rv = mConn->ExecuteSimpleSQL(create_msg_folder);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    // Generic message properties table (ugh).
+    const nsLiteralCString create_msg_prop(
+        "CREATE TABLE msg_prop ( "
+        "msg_id INTEGER NOT NULL, "
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "UNIQUE (msg_id, name)"
+        ")");
+    rv = mConn->ExecuteSimpleSQL(create_msg_prop);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    // Generic message properties table (ugh).
+    const nsLiteralCString create_folder_prop(
+        "CREATE TABLE folder_prop ( "
+        "folder_id INTEGER NOT NULL, "
+        "name TEXT NOT NULL, "
+        "value TEXT NOT NULL, "
+        "UNIQUE (folder_id, name)"
+        ")");
+    rv = mConn->ExecuteSimpleSQL(create_folder_prop);
+    NS_ENSURE_SUCCESS(rv, rv);
+
   } else {
     // Migrations go here...
   }
 
   rv = mConn->SetSchemaVersion(latestSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
@@ -289,16 +315,17 @@ nsresult GlobalDB::StashMsg(RawHdr const
   if (NS_FAILED(rv)) {
     return rv;
   }
 
   int64_t rowid;
   rv = mConn->GetLastInsertRowID(&rowid);
   NS_ENSURE_SUCCESS(rv, rv);
   *newKey = (nsMsgKey)rowid;
+  printf("XYZZY: StashMsg() - new msg %d\n", *newKey);
   return NS_OK;
 }
 
 nsresult GlobalDB::AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID) {
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO msg_folder (msg_id, folder_id) VALUES (:msgID, :folderID)");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -359,16 +386,19 @@ nsresult GlobalDB::FetchMsgFlags(nsMsgKe
       Stmt("SELECT flags FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists) {
+    printf("XYZZY: FetchMsgFlags(key=%d) found nothing\n", (int)key);
+  }
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetInt32(0, (int32_t*)flags);
 }
 
 nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT messageID FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
@@ -491,17 +521,17 @@ nsresult GlobalDB::FetchMsgOfflineSize(n
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetInt64(0, (int64_t*)size);
 }
 
 nsresult GlobalDB::FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT lineCount FROM msg WHERE rowid=:rowid");
+      Stmt("SELECT numLines FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
@@ -703,30 +733,31 @@ nsresult GlobalDB::SetMsgOfflineSize(nsM
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgLineCount(nsMsgKey key, uint32_t lineCount) {
   MOZ_ASSERT(lineCount < INT32_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET lineCount=:lineCount WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET numLines=:lineCount WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("lineCount"_ns, (int32_t)lineCount);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
-  MOZ_ASSERT(seconds < INT32_MAX);
+  //  MOZ_ASSERT(seconds < INT32_MAX);  // This was triggering...
+  printf("XYZZY SetMsgDate(key=%d seconds=0x%" PRIx32 ")\n", (int)key, seconds);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET date=:seconds WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("seconds"_ns, (int32_t)seconds);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -953,8 +984,91 @@ nsresult GlobalDB::FolderEnumerateMsgsWi
 
 nsresult GlobalDB::FolderEnumerateThreads(nsFolderKey folderID,
                                           nsIMsgThreadEnumerator** result) {
   // TODO
   RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this);
   e.forget(result);
   return NS_OK;
 }
+
+nsresult GlobalDB::FolderSetProperty(nsFolderKey folderID,
+                                     nsACString const& name,
+                                     nsACString const& value) {
+  // oooh, an UPSERT!
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "INSERT INTO folder_prop (folder_id, name, value) VALUES(:folderID, "
+      ":name, :value) ON CONFLICT(folder_id, name) DO UPDATE SET "
+      "value=excluded.value;");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("name"_ns, name);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("value"_ns, value);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+nsresult GlobalDB::FolderGetProperty(nsFolderKey folderID,
+                                     nsACString const& name,
+                                     nsACString& value) {
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT value FROM folder_prop WHERE folder_id=:folderID AND name=:name");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("name"_ns, name);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists) {
+    return NS_OK;
+  }
+  return stmt->GetUTF8String(0, value);
+}
+
+nsresult GlobalDB::MsgSetProperty(nsMsgKey key, nsACString const& name,
+                                  nsACString const& value) {
+  // oooh, an UPSERT!
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "INSERT INTO msg_prop (msg_id, name, value) VALUES(:msgKey, :name, "
+      ":value) ON CONFLICT(msg_id, name) DO UPDATE SET value=excluded.value;");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("name"_ns, name);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("value"_ns, name);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+nsresult GlobalDB::MsgGetProperty(nsMsgKey key, nsACString const& name,
+                                  nsACString& value) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT value FROM msg_prop WHERE msg_id=:msgKey AND name=:name");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindUTF8StringByName("name"_ns, name);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists) {
+    return NS_OK;
+  }
+  return stmt->GetUTF8String(0, value);
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -12,17 +12,17 @@
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 
 // Using toolkit/components/places/Database.h as rough guide
 
 typedef uint32_t nsFolderKey;
 
 struct RawHdr {
-  nsMsgKey id{0};
+  // nsMsgKey id{0};
   nsCString messageID;
   nsCString references;
   uint64_t date{0};
   uint64_t received{0};
   nsCString subject;
   nsCString sender;
   nsCString recipients;
   nsCString ccList;
@@ -152,20 +152,32 @@ class GlobalDB {
       nsFolderKey folderID,
       const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
       nsIMsgEnumerator** aResult);
   nsresult FolderEnumerateMsgsWithFlag(nsFolderKey folderID, uint32_t flag,
                                        nsIMsgEnumerator** result);
   nsresult FolderEnumerateThreads(nsFolderKey folderID,
                                   nsIMsgThreadEnumerator** result);
 
+  // Icky random-property stuff on folder and message.
+  nsresult FolderSetProperty(nsFolderKey folderID, nsACString const& name,
+                             nsACString const& value);
+  nsresult FolderGetProperty(nsFolderKey folderID, nsACString const& name,
+                             nsACString& value);
+  nsresult MsgSetProperty(nsMsgKey key, nsACString const& name,
+                          nsACString const& value);
+  nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
+                          nsACString& value);
+
+  nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
+
+  nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
+
  private:
   nsresult InitSchema();
-  nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
-  nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
   mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
--- a/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.cpp
@@ -10,16 +10,17 @@
 // #include "nsIPrefService.h"
 // #include "nsIPrefBranch.h"
 // #include "nsIPrefLocalizedString.h"
 // #include "nsIObserver.h"
 // #include "nsIObserverService.h"
 #include "nsIMsgDBView.h"
 #include "nsServiceManagerUtils.h"
 #include "nsImapCore.h"
+#include "GlobalDB.h"
 
 NS_IMPL_ADDREF(nsDBFolderInfo2)
 NS_IMPL_RELEASE(nsDBFolderInfo2)
 
 NS_IMETHODIMP
 nsDBFolderInfo2::QueryInterface(REFNSIID iid, void** result) {
   if (!result) return NS_ERROR_NULL_POINTER;
 
@@ -31,16 +32,17 @@ nsDBFolderInfo2::QueryInterface(REFNSIID
     return NS_OK;
   }
   return NS_NOINTERFACE;
 }
 
 nsDBFolderInfo2::nsDBFolderInfo2(nsMsgDatabase2* mdb)
     : m_flags(0), m_expiredMark(0) {
   m_mdb = mdb;
+  mGlobalDB = mdb->mGlobalDB;
   m_version = 1;                 // for upgrading...
   m_IMAPHierarchySeparator = 0;  // imap path separator
   // mail only (for now)
   m_folderSize = 0;
   m_folderDate = 0;
   m_expungedBytes = 0;  // sum of size of deleted messages in folder
   m_highWaterMessageKey = 0;
 
@@ -308,76 +310,97 @@ NS_IMETHODIMP nsDBFolderInfo2::SetSortOr
 NS_IMETHODIMP nsDBFolderInfo2::SetKnownArtsSet(const char* newsArtSet) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetKnownArtsSet(char** newsArtSet) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetProperty(const char* propertyName,
-                                           const nsAString& propertyStr) {
-  // TODO
-  printf("XYZZY nsDBFolderInfo2::SetProperty(%s)\n", propertyName);
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsDBFolderInfo2::GetProperty(const char* propertyName,
-                                           nsAString& resultProperty) {
-  printf("XYZZY nsDBFolderInfo2::GetProperty(%s)\n", propertyName);
-  resultProperty.Truncate();
-  return NS_OK;
+NS_IMETHODIMP nsDBFolderInfo2::SetProperty(const char* name,
+                                           const nsAString& value) {
+  // Convert from UTF-16.
+  return DB().FolderSetProperty(m_mdb->mFolderID, nsDependentCString(name),
+                                NS_ConvertUTF16toUTF8(value));
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetCharProperty(
-    const char* propertyName, const nsACString& propertyValue) {
-  // TODO
-  printf("XYZZY nsDBFolderInfo2::SetCharProperty(%s,%s)\n", propertyName,
-         PromiseFlatCString(propertyValue).get());
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsDBFolderInfo2::GetCharProperty(const char* propertyName,
-                                               nsACString& resultProperty) {
-  // TODO
-  resultProperty = "";
-  printf("XYZZY nsDBFolderInfo2::GetCharProperty(%s)\n", propertyName);
+NS_IMETHODIMP nsDBFolderInfo2::GetProperty(const char* name, nsAString& value) {
+  // Convert to UTF-16.
+  nsAutoCString tmp;
+  nsresult rv =
+      DB().FolderGetProperty(m_mdb->mFolderID, nsDependentCString(name), tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  value = NS_ConvertUTF8toUTF16(tmp);
   return NS_OK;
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetUint32Property(const char* propertyName,
-                                                 uint32_t propertyValue) {
-  // TODO
-  printf("XYZZY nsDBFolderInfo2::SetUint32Property(%s,%" PRIu32 ")\n",
-         propertyName, propertyValue);
+NS_IMETHODIMP nsDBFolderInfo2::SetCharProperty(const char* name,
+                                               const nsACString& value) {
+  return DB().FolderSetProperty(m_mdb->mFolderID, nsDependentCString(name),
+                                value);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetCharProperty(const char* name,
+                                               nsACString& value) {
+  return DB().FolderGetProperty(m_mdb->mFolderID, nsDependentCString(name),
+                                value);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetUint32Property(const char* name,
+                                                 uint32_t value) {
+  nsAutoCString s;
+  s.AppendInt(value);
+  return DB().FolderSetProperty(m_mdb->mFolderID, nsDependentCString(name), s);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::SetInt64Property(const char* name,
+                                                int64_t value) {
+  nsAutoCString s;
+  s.AppendInt(value);
+  return DB().FolderSetProperty(m_mdb->mFolderID, nsDependentCString(name), s);
+}
+
+NS_IMETHODIMP nsDBFolderInfo2::GetUint32Property(const char* name,
+                                                 uint32_t defaultValue,
+                                                 uint32_t* value) {
+  nsAutoCString s;
+  nsresult rv =
+      DB().FolderGetProperty(m_mdb->mFolderID, nsDependentCString(name), s);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (s.IsEmpty()) {
+    *value = defaultValue;
+    return NS_OK;
+  }
+  // int64 is big enough to handle uint32_t (ToInteger() returns int32_t)
+  int64_t i = s.ToInteger64(&rv);
+  if (NS_SUCCEEDED(rv)) {
+    *value = (uint32_t)i;
+  } else {
+    *value = defaultValue;  // TODO: print a warning.
+  }
   return NS_OK;
 }
 
-NS_IMETHODIMP nsDBFolderInfo2::SetInt64Property(const char* propertyName,
-                                                int64_t propertyValue) {
-  // TODO
-  printf("XYZZY nsDBFolderInfo2::SetInt64Property(%s,%" PRId64 ")\n",
-         propertyName, propertyValue);
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsDBFolderInfo2::GetUint32Property(const char* propertyName,
-                                                 uint32_t defaultValue,
-                                                 uint32_t* propertyValue) {
-  printf("XYZZY nsDBFolderInfo2::GetCharProperty(%s)\n", propertyName);
-  *propertyValue = defaultValue;
-  return NS_OK;
-}
-
-NS_IMETHODIMP nsDBFolderInfo2::GetInt64Property(const char* propertyName,
+NS_IMETHODIMP nsDBFolderInfo2::GetInt64Property(const char* name,
                                                 int64_t defaultValue,
-                                                int64_t* propertyValue) {
-  // TODO
-  printf("XYZZY nsDBFolderInfo2::GetInt64Property(%s)\n", propertyName);
-  *propertyValue = defaultValue;
+                                                int64_t* value) {
+  nsAutoCString s;
+  nsresult rv =
+      DB().FolderGetProperty(m_mdb->mFolderID, nsDependentCString(name), s);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (s.IsEmpty()) {
+    *value = defaultValue;
+    return NS_OK;
+  }
+  int64_t i = s.ToInteger64(&rv);
+  if (NS_SUCCEEDED(rv)) {
+    *value = (uint32_t)i;
+  } else {
+    *value = defaultValue;  // TODO: print a warning.
+  }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsDBFolderInfo2::GetBooleanProperty(const char* propertyName,
                                                   bool defaultValue,
                                                   bool* propertyValue) {
   // TODO
   printf("XYZZY nsDBFolderInfo2::GetBooleanProperty(%s)\n", propertyName);
diff --git a/mailnews/db/msgdb/src/nsDBFolderInfo2.h b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
--- a/mailnews/db/msgdb/src/nsDBFolderInfo2.h
+++ b/mailnews/db/msgdb/src/nsDBFolderInfo2.h
@@ -11,24 +11,26 @@
 
 #include "nsString.h"
 #include "MailNewsTypes.h"
 #include "nsTArray.h"
 #include "nsIDBFolderInfo.h"
 #include <time.h>
 
 class nsMsgDatabase2;
+class GlobalDB;
 
 // again, this could inherit from nsISupports, but I don't see the need as of
 // yet. I'm not sure it needs to be ref-counted (but I think it does).
 
 class nsDBFolderInfo2 : public nsIDBFolderInfo {
  public:
   friend class nsMsgDatabase2;
 
+  nsDBFolderInfo2() = delete;
   explicit nsDBFolderInfo2(nsMsgDatabase2* mdb);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDBFOLDERINFO
 
   bool TestFlag(int32_t flags);
   int16_t GetIMAPHierarchySeparator();
   void SetIMAPHierarchySeparator(int16_t hierarchyDelimiter);
@@ -39,17 +41,20 @@ class nsDBFolderInfo2 : public nsIDBFold
 
   nsTArray<nsMsgKey> m_lateredKeys;  // list of latered messages
 
  protected:
   virtual ~nsDBFolderInfo2();
 
   nsresult AdjustHighWater(nsMsgKey highWater, bool force);
 
+  // Only used for default sort order/type lookup.
+  // Replace with GlobalDB + folderID pair.
   nsMsgDatabase2* m_mdb;
+  GlobalDB* mGlobalDB;
 
   int64_t m_folderSize;
   int64_t m_expungedBytes;  // sum of size of deleted messages in folder
   uint32_t m_folderDate;
   nsMsgKey m_highWaterMessageKey;  // largest news article number or imap uid
                                    // whose header we've seen
 
   //  m_numUnreadMessages and m_numMessages can never be negative. 0 means 'no
@@ -77,11 +82,13 @@ class nsDBFolderInfo2 : public nsIDBFold
   nsMsgKey m_expiredMark;
 
   // TODO: should persist!
   nsMsgViewSortOrderValue mSortOrder;
   nsMsgViewSortTypeValue mSortType;
   nsMsgViewTypeValue mViewType;
   nsString mMailboxName;
   nsCString mFolderName;
+
+  GlobalDB& DB() { return *mGlobalDB; }
 };
 
 #endif
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -88,23 +88,20 @@ NS_IMETHODIMP nsMsgDatabase2::SetLastUse
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetDatabaseSize(int64_t* _retval) {
   *_retval = 0;
   return NS_OK;
 }
 
-nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
-  NS_ENSURE_ARG_POINTER(result);
-
-  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
-  msgHdr.forget(result);
-  return NS_OK;
-}
+// nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
+//   // TODO: Kill this
+//   return NS_ERROR_NOT_IMPLEMENTED;
+// }
 
 NS_IMETHODIMP nsMsgDatabase2::AddListener(nsIDBChangeListener* aListener) {
   NS_ENSURE_ARG_POINTER(aListener);
   m_ChangeListeners.AppendElementUnlessExists(aListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::RemoveListener(nsIDBChangeListener* aListener) {
@@ -186,16 +183,27 @@ NS_IMETHODIMP nsMsgDatabase2::NotifyPare
 NS_IMETHODIMP nsMsgDatabase2::NotifyAnnouncerGoingAway(void) {
   NOTIFY_LISTENERS(OnAnnouncerGoingAway, (this));
   return NS_OK;
 }
 
 nsMsgDatabase2::nsMsgDatabase2(nsIMsgFolder* folder)
     : m_folder(folder), m_nextPseudoMsgKey(kFirstPseudoKey) {
   mGlobalDB = &GlobalDB::get();
+
+  // Fudge to resolve folderID.
+  nsAutoCString uri;
+  nsresult rv = folder->GetURI(uri);
+  if (NS_SUCCEEDED(rv)) {
+    rv = DB().FolderFindOrCreate(uri, &mFolderID);
+  }
+  if (NS_FAILED(rv)) {
+    mFolderID = 0;
+  }
+
   m_dbFolderInfo = new nsDBFolderInfo2(this);
 }
 
 nsMsgDatabase2::~nsMsgDatabase2() {
   m_dbFolderInfo = nullptr;
   m_ChangeListeners.Clear();
 }
 
@@ -659,29 +667,44 @@ nsMsgDatabase2::EnumerateThreads(nsIMsgT
   return DB().FolderEnumerateThreads(mFolderID, result);
 }
 
 nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                                    uint32_t* pFlag) {
   return DB().FolderEnumerateMsgsWithFlag(mFolderID, *pFlag, result);
 }
 
-NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key,
-                                           nsIMsgDBHdr** pnewHdr) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
+  NS_ENSURE_ARG_POINTER(result);
+
+  printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
+
+  MOZ_ASSERT(key == nsMsgKey_None);
+  // TODO: ++elegance;
+  RawHdr blank;
+  nsresult rv = DB().StashMsg(blank, &key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = DB().AddMsgToFolder(key, mFolderID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
+  msgHdr.forget(result);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
+  printf("XYZZY: AddnewHdrToDB()\n");
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CopyHdrFromExistingHdr(nsMsgKey key,
                                                      nsIMsgDBHdr* existingHdr,
                                                      bool addHdrToDB,
                                                      nsIMsgDBHdr** newHdr) {
+  printf("XYZZY: CopyHdrFromExistingHdr(key=%d)\n", (int)key);
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::CompareCollationKeys(const nsTArray<uint8_t>& key1,
                                      const nsTArray<uint8_t>& key2,
                                      int32_t* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.h
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -37,36 +37,34 @@ class nsMsgDatabase2 : public nsIMsgOffl
   NS_DECL_NSIMSGDATABASE
   NS_DECL_NSIMSGOFFLINEOPSDATABASE
 
   explicit nsMsgDatabase2(nsIMsgFolder* folder);
   nsMsgDatabase2() = delete;
 
   virtual nsresult MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool bRead,
                                    nsIDBChangeListener* instigator);
-  virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
+  // virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
   virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
   virtual nsresult EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                              uint32_t* pFlag);
 
   //////////////////////////////////////////////////////////////////////////////
   // nsMsgDatabase2 methods:
 
   virtual uint32_t GetCurVersion();
   nsresult GetCollationKeyGenerator();
   nsIMimeConverter* GetMimeConverter();
 
 #ifdef DEBUG
   virtual nsresult DumpContents();
 #endif
-
-  friend class nsMsgHdr2;    // use this to get access to cached tokens for hdr
-                             // fields
-  friend class nsMsgThread;  // use this to get access to cached tokens for hdr
-                             // fields
+  friend class nsDBFolderInfo2;
+  friend class nsMsgHdr2;
+  friend class nsMsgThread;
 
  protected:
   virtual ~nsMsgDatabase2();
 
   // prefs stuff - in future, we might want to cache the prefs interface
   nsresult GetBoolPref(const char* prefName, bool* result);
   nsresult GetIntPref(const char* prefName, int32_t* result);
   virtual void GetGlobalPrefs();
@@ -106,17 +104,17 @@ class nsMsgDatabase2 : public nsIMsgOffl
                                  nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
   nsresult FindExcessMessages(uint32_t numHeadersToKeep,
                               bool applyToFlaggedMessages,
                               nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
 
   // not sure how we'll manage global DB yet, so use DB() to access.
   GlobalDB* mGlobalDB;
   GlobalDB& DB() { return *mGlobalDB; }
-  uint32_t mFolderID;  // TODO :-)
+  uint32_t mFolderID;
 
   nsCOMPtr<nsIMsgFolder> m_folder;
   RefPtr<nsDBFolderInfo2> m_dbFolderInfo;
   nsMsgKey m_nextPseudoMsgKey;
 
   // used to remember the args to Open for async open.
   nsTObserverArray<nsCOMPtr<nsIDBChangeListener>> m_ChangeListeners;
 
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -18,17 +18,17 @@
 NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
 
 #define FLAGS_INITED 0x1
 #define CACHED_VALUES_INITED 0x2
 #define REFERENCES_INITED 0x4
 #define THREAD_PARENT_INITED 0x8
 
 nsMsgHdr2::nsMsgHdr2(GlobalDB* globaldb, nsMsgKey key)
-    : mDB(globaldb), mKey(key), m_initedValues(0) {}
+    : mDB(globaldb), mKey(key), m_threadId(nsMsgKey_None), m_initedValues(0) {}
 
 nsMsgHdr2::~nsMsgHdr2() {}
 
 nsresult nsMsgHdr2::InitCachedValues() {
   nsresult rv = NS_OK;
 
   if (!(m_initedValues & CACHED_VALUES_INITED)) {
     rv = DB().FetchMsgSize(mKey, &m_messageSize);
@@ -286,20 +286,23 @@ NS_IMETHODIMP nsMsgHdr2::SetAccountKey(c
 NS_IMETHODIMP nsMsgHdr2::GetAccountKey(char** accountKey) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgAccountKey(mKey, tmp);
   *accountKey = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageOffset(uint64_t* result) {
+  printf("XYZZY: ignore %d: GetMessageOffset()\n", (int)mKey);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetMessageOffset(uint64_t offset) {
+  printf("XYZZY: ignore %d: SetMessageOffset(%" PRIu64 ")\n", (int)mKey,
+         offset);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageSize(uint32_t* size) {
   uint64_t tmp;
   nsresult rv = DB().FetchMsgSize(mKey, &tmp);
   if (NS_SUCCEEDED(rv)) {
     *size = (uint32_t)tmp;
@@ -525,28 +528,32 @@ NS_IMETHODIMP nsMsgHdr2::GetIsKilled(boo
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
                                            char const* value) {
   nsDependentCString n(name);
   nsDependentCString v(value);
   if (n.EqualsLiteral("storeToken")) {
+    printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
     return DB().SetMsgStoreToken(mKey, v);
   }
 
-  printf("XYZZY: ignoring nsMsgHdr2::SetStringProperty('%s')\n", name);
+  printf("XYZZY: %d: ignoring nsMsgHdr2::SetStringProperty('%s')\n", (int)mKey,
+         name);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const* name, char** value) {
   nsDependentCString n(name);
   if (n.EqualsLiteral("storeToken")) {
     nsAutoCString tmp;
     nsresult rv = DB().FetchMsgStoreToken(mKey, tmp);
+    printf("XYZZY: %d: GetStringProperty(%s) ==> %s\n", (int)mKey, name,
+           tmp.get());
     *value = moz_xstrdup(tmp.get());
     return rv;
   }
 
   printf("XYZZY: ignoring nsMsgHdr2::GetStringProperty('%s')\n", name);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const* name,
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.h b/mailnews/db/msgdb/src/nsMsgHdr2.h
--- a/mailnews/db/msgdb/src/nsMsgHdr2.h
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.h
@@ -38,17 +38,17 @@ class nsMsgHdr2 : public nsIMsgDBHdr {
 
   GlobalDB& DB() { return *mDB; }
   GlobalDB* mDB;  // We might remove this in favour of a singleton or
                   // something... (so access via DB() for now).
   nsMsgKey mKey;  // news: article number, local mail: key, imap: uid...
 
   // Everything else here is just caching...
   nsMsgKey m_threadId;
-  // nsMsgKey m_threadParent;  // message this is a reply to, in thread.
+  //  nsMsgKey m_threadParent;  // message this is a reply to, in thread.
   PRTime m_date;
   uint64_t m_messageSize;  // lines for news articles, bytes for mail messages
   uint32_t m_flags;
   // avoid parsing references every time we want one
   nsTArray<nsCString> m_references;
 
   uint32_t m_initedValues;
 };
diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -267,16 +267,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::GetD
       return NS_ERROR_NULL_POINTER;  // mDatabase will be null at this point.
 
     nsCOMPtr<nsIMsgDBService> msgDBService =
         do_GetService("@mozilla.org/msgDatabase/msgDBService;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
 
     nsresult folderOpen =
         msgDBService->OpenFolderDB(this, true, getter_AddRefs(mDatabase));
+
     if (folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE) {
       nsCOMPtr<nsIDBFolderInfo> dbFolderInfo;
       nsCOMPtr<nsIDBFolderInfo> transferInfo;
       if (mDatabase) {
         mDatabase->GetDBFolderInfo(getter_AddRefs(dbFolderInfo));
         if (dbFolderInfo) {
           dbFolderInfo->SetNumMessages(0);
           dbFolderInfo->SetNumUnreadMessages(0);
@@ -314,16 +315,19 @@ NS_IMETHODIMP nsMsgLocalMailFolder::GetD
       }
     } else if (folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) {
       rv = msgDBService->CreateNewDB(this, getter_AddRefs(mDatabase));
     }
 
     if (mDatabase) {
       if (mAddListener) mDatabase->AddListener(this);
 
+      // XYZZY - force a reparse!
+      folderOpen = NS_MSG_ERROR_FOLDER_SUMMARY_MISSING;
+
       // if we have to regenerate the folder, run the parser url.
       if (folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING ||
           folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE) {
         if (NS_FAILED(rv = ParseFolder(aMsgWindow, aReparseUrlListener))) {
           if (rv == NS_MSG_FOLDER_BUSY) {
             // we need to null out the db so that parsing gets kicked off again.
             mDatabase->RemoveListener(this);
             mDatabase = nullptr;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670572035 -46800
#      Fri Dec 09 20:47:15 2022 +1300
# Node ID 7bfe9a8575997996665558b9c14c7221a4023478
# Parent  2bf7374aac76d5763b9f4c7ec478eb81e8ab92a4
WIP: fix borked msg enumerator, strip caching from nsMsgHdr2.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -5,18 +5,20 @@
 #include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgEnumerator.h"
 
 class MsgEnumerator : public nsBaseMsgEnumerator {
  public:
+  // TODO: provide move ctor to avoid copy here.
   MsgEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& keys)
-      : mGlobalDB(db), mKeys(keys), mCur(0) {
+      : mGlobalDB(db), mCur(0) {
+    mKeys = keys.Clone();
     printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
   };
   MsgEnumerator() = delete;
 
   // nsIMsgEnumerator support.
   NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
     MOZ_ASSERT(mCur < mKeys.Length());
     RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mGlobalDB, mKeys[mCur++]);
@@ -26,17 +28,17 @@ class MsgEnumerator : public nsBaseMsgEn
 
   NS_IMETHOD HasMoreElements(bool* aResult) override {
     *aResult = mCur < mKeys.Length();
     return NS_OK;
   }
 
  protected:
   GlobalDB* mGlobalDB;
-  nsTArray<nsMsgKey> const& mKeys;
+  nsTArray<nsMsgKey> mKeys;
   size_t mCur;
 };
 
 // TODO
 class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
  public:
   explicit ThreadEnumerator(GlobalDB* db) : mGlobalDB(db) {
     printf("XYZZY: ThreadEnumerator ctor\n");
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -18,141 +18,101 @@
 NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
 
 #define FLAGS_INITED 0x1
 #define CACHED_VALUES_INITED 0x2
 #define REFERENCES_INITED 0x4
 #define THREAD_PARENT_INITED 0x8
 
 nsMsgHdr2::nsMsgHdr2(GlobalDB* globaldb, nsMsgKey key)
-    : mDB(globaldb), mKey(key), m_threadId(nsMsgKey_None), m_initedValues(0) {}
+    : mDB(globaldb), mKey(key) {}
 
 nsMsgHdr2::~nsMsgHdr2() {}
 
-nsresult nsMsgHdr2::InitCachedValues() {
-  nsresult rv = NS_OK;
-
-  if (!(m_initedValues & CACHED_VALUES_INITED)) {
-    rv = DB().FetchMsgSize(mKey, &m_messageSize);
-    if (NS_SUCCEEDED(rv)) {
-      uint32_t dt;
-      rv = DB().FetchMsgDate(mKey, &dt);
-      Seconds2PRTime(dt, &m_date);
-    }
-    if (NS_SUCCEEDED(rv)) {
-      rv = DB().FetchMsgThreadID(mKey, &m_threadId);
-    }
-
-    if (NS_SUCCEEDED(rv)) {
-      m_initedValues |= CACHED_VALUES_INITED;
-    }
-  }
-  return rv;
-}
-
-nsresult nsMsgHdr2::InitFlags() {
-  nsresult rv = NS_OK;
-  if (!(m_initedValues & FLAGS_INITED)) {
-    rv = DB().FetchMsgFlags(mKey, &m_flags);
-    // TODO: re-evaluate this behaviour:
-    m_flags &= ~nsMsgMessageFlags::New;  // don't get new flag from DB
-    if (NS_SUCCEEDED(rv)) {
-      m_initedValues |= FLAGS_INITED;
-    }
-  }
-  return rv;
-}
-
 NS_IMETHODIMP nsMsgHdr2::GetMessageKey(nsMsgKey* result) {
   *result = mKey;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetThreadId(nsMsgKey* result) {
-  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
-
-  if (result) {
-    *result = m_threadId;
-    return NS_OK;
-  }
-  return NS_ERROR_NULL_POINTER;
+  return DB().FetchMsgThreadID(mKey, result);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetThreadId(nsMsgKey threadID) {
-  m_threadId = threadID;
   return DB().SetMsgThreadID(mKey, threadID);
 }
 
 // TODO: should be read-only?
 NS_IMETHODIMP nsMsgHdr2::SetMessageKey(nsMsgKey value) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-nsresult nsMsgHdr2::GetRawFlags(uint32_t* result) {
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
-  *result = m_flags;
-  return NS_OK;
-}
-
 NS_IMETHODIMP nsMsgHdr2::GetFlags(uint32_t* result) {
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
+  nsresult rv = DB().FetchMsgFlags(mKey, result);
+  NS_ENSURE_SUCCESS(rv, rv);
   // TODO: Whatever GetStatusFlags() was doing to massage the flags.
-  *result = m_flags;
 #ifdef DEBUG_bienvenu
   NS_ASSERTION(!(*result & (nsMsgMessageFlags::Elided)),
                "shouldn't be set in db");
 #endif
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetFlags(uint32_t flags) {
 #ifdef DEBUG_bienvenu
   NS_ASSERTION(!(flags & (nsMsgMessageFlags::Elided)),
                "shouldn't set this flag on db");
 #endif
-  m_initedValues |= FLAGS_INITED;
-  m_flags = flags;
   // don't write out nsMsgMessageFlags::New to MDB.
-  return DB().SetMsgFlags(mKey, m_flags & ~nsMsgMessageFlags::New);
+  return DB().SetMsgFlags(mKey, flags & ~nsMsgMessageFlags::New);
 }
 
 NS_IMETHODIMP nsMsgHdr2::OrFlags(uint32_t flags, uint32_t* result) {
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
-  if ((m_flags & flags) != flags) SetFlags(m_flags | flags);
-  *result = m_flags;
+  uint32_t oldFlags;
+  nsresult rv = GetFlags(&oldFlags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  flags = oldFlags | flags;
+  if (flags != oldFlags) {
+    rv = SetFlags(flags);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  *result = flags;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::AndFlags(uint32_t flags, uint32_t* result) {
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
-  if ((m_flags & flags) != m_flags) SetFlags(m_flags & flags);
-  *result = m_flags;
+  uint32_t oldFlags;
+  nsresult rv = GetFlags(&oldFlags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  flags = oldFlags & flags;
+  if (flags != oldFlags) {
+    rv = SetFlags(flags);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  *result = flags;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::MarkHasAttachments(bool bHasAttachments) {
   return DB().SetMsgHasAttachments(mKey, bHasAttachments);
 }
 
 NS_IMETHODIMP nsMsgHdr2::MarkRead(bool bRead) {
   return DB().SetMsgIsRead(mKey, bRead);
 }
 
 NS_IMETHODIMP nsMsgHdr2::MarkFlagged(bool bFlagged) {
   return DB().SetMsgIsFlagged(mKey, bFlagged);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetNumReferences(uint16_t* result) {
-  if (!(m_initedValues & REFERENCES_INITED)) {
-    nsCString refs;
-    nsresult rv = DB().FetchMsgReferences(mKey, refs);
-    NS_ENSURE_SUCCESS(rv, rv);
-    ParseReferences(refs.get());
-    m_initedValues |= REFERENCES_INITED;
-  }
+  nsCString refs;
+  nsresult rv = DB().FetchMsgReferences(mKey, refs);
+  NS_ENSURE_SUCCESS(rv, rv);
+  ParseReferences(refs.get());
 
   if (result) *result = m_references.Length();
   // there is no real failure here; if there are no references, there are no
   //  references.
   return NS_OK;
 }
 
 nsresult nsMsgHdr2::ParseReferences(const char* references) {
@@ -170,36 +130,35 @@ nsresult nsMsgHdr2::ParseReferences(cons
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetStringReference(int32_t refNum,
                                             nsACString& resultReference) {
   nsresult err = NS_OK;
 
-  if (!(m_initedValues & REFERENCES_INITED))
-    GetNumReferences(nullptr);  // it can handle the null
+  GetNumReferences(nullptr);  // it can handle the null
 
   if ((uint32_t)refNum < m_references.Length())
     resultReference = m_references.ElementAt(refNum);
   else
     err = NS_ERROR_ILLEGAL_VALUE;
   return err;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetDate(PRTime* result) {
-  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
-  *result = m_date;
+  uint32_t dt;
+  nsresult rv = DB().FetchMsgDate(mKey, &dt);
+  NS_ENSURE_SUCCESS(rv, rv);
+  Seconds2PRTime(dt, result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetDateInSeconds(uint32_t* seconds) {
-  if (!(m_initedValues & CACHED_VALUES_INITED)) InitCachedValues();
-  *seconds = m_date / PR_USEC_PER_SEC;
-  return NS_OK;
+  return DB().FetchMsgDate(mKey, seconds);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetMessageId(const char* messageID) {
   if (messageID && *messageID == '<') {
     nsAutoCString tempMessageID(messageID + 1);
     if (tempMessageID.CharAt(tempMessageID.Length() - 1) == '>')
       tempMessageID.SetLength(tempMessageID.Length() - 1);
     return DB().SetMsgMessageID(mKey, tempMessageID);
@@ -213,19 +172,16 @@ NS_IMETHODIMP nsMsgHdr2::SetSubject(cons
 
 NS_IMETHODIMP nsMsgHdr2::SetAuthor(const char* author) {
   return DB().SetMsgSender(mKey, nsDependentCString(author));
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetReferences(const nsACString& references) {
   m_references.Clear();
   ParseReferences(PromiseFlatCString(references).get());
-
-  m_initedValues |= REFERENCES_INITED;
-
   return DB().SetMsgReferences(mKey, references);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetRecipients(const char* recipients) {
   // need to put in rfc822 address parsing code here (or make caller do it...)
   return DB().SetMsgRecipients(mKey, nsDependentCString(recipients));
 }
 
@@ -233,17 +189,16 @@ NS_IMETHODIMP nsMsgHdr2::SetCcList(const
   return DB().SetMsgCCList(mKey, nsDependentCString(ccList));
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetBccList(const char* bccList) {
   return DB().SetMsgBCCList(mKey, nsDependentCString(bccList));
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetMessageSize(uint32_t messageSize) {
-  m_messageSize = messageSize;
   return DB().SetMsgSize(mKey, (uint64_t)messageSize);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetOfflineMessageSize(uint32_t* offlineSize) {
   uint64_t tmp;
   nsresult rv = DB().FetchMsgOfflineSize(mKey, &tmp);
   if (NS_SUCCEEDED(rv)) {
     *offlineSize = (uint32_t)tmp;
@@ -255,17 +210,16 @@ NS_IMETHODIMP nsMsgHdr2::SetOfflineMessa
   return DB().SetMsgOfflineSize(mKey, (uint64_t)offlineSize);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetLineCount(uint32_t lineCount) {
   return DB().SetMsgLineCount(mKey, lineCount);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetDate(PRTime date) {
-  m_date = date;
   uint32_t seconds;
   PRTime2Seconds(date, &seconds);
   return DB().SetMsgDate(mKey, seconds);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetPriority(nsMsgPriorityValue priority) {
   return DB().SetMsgPriority(mKey, priority);
 }
@@ -366,27 +320,30 @@ NS_IMETHODIMP nsMsgHdr2::GetMime2Decoded
 
 NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedRecipients(
     nsAString& resultRecipients) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetAuthorCollationKey(
     nsTArray<uint8_t>& resultAuthor) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  resultAuthor.Clear();  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetSubjectCollationKey(
     nsTArray<uint8_t>& resultSubject) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  resultSubject.Clear();  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetRecipientsCollationKey(
     nsTArray<uint8_t>& resultRecipients) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  resultRecipients.Clear();  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetCharset(char** aCharset) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetCharset(const char* aCharset) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
@@ -507,25 +464,29 @@ const char* nsMsgHdr2::GetNextReference(
   // we did not have a fully-formed, valid message-id, so consider falling back
   if (acceptNonDelimitedReferences && whitespaceEndedAt)
     reference = whitespaceEndedAt;
   return ptr;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsRead(bool* isRead) {
   NS_ENSURE_ARG_POINTER(isRead);
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
-  *isRead = !!(m_flags & nsMsgMessageFlags::Read);
+  uint32_t flags;
+  nsresult rv = GetFlags(&flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isRead = !!(flags & nsMsgMessageFlags::Read);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsFlagged(bool* isFlagged) {
   NS_ENSURE_ARG_POINTER(isFlagged);
-  if (!(m_initedValues & FLAGS_INITED)) InitFlags();
-  *isFlagged = !!(m_flags & nsMsgMessageFlags::Marked);
+  uint32_t flags;
+  nsresult rv = GetFlags(&flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isFlagged = !!(flags & nsMsgMessageFlags::Marked);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsKilled(bool* isKilled) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.h b/mailnews/db/msgdb/src/nsMsgHdr2.h
--- a/mailnews/db/msgdb/src/nsMsgHdr2.h
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.h
@@ -20,37 +20,24 @@ class nsMsgHdr2 : public nsIMsgDBHdr {
   NS_DECL_ISUPPORTS
   NS_DECL_NSIMSGDBHDR
 
   nsMsgHdr2() = delete;
   nsMsgHdr2(GlobalDB* db, nsMsgKey key);
 
  protected:
   virtual ~nsMsgHdr2();
-  void ClearCachedValues() { m_initedValues = 0; }
-  nsresult GetRawFlags(uint32_t* result);
 
  private:
-  nsresult InitFlags();
-  nsresult InitCachedValues();
-
   nsresult ParseReferences(const char* references);
   const char* GetNextReference(const char* startNextRef, nsCString& reference,
                                bool acceptNonDelimitedReferences);
 
   GlobalDB& DB() { return *mDB; }
   GlobalDB* mDB;  // We might remove this in favour of a singleton or
                   // something... (so access via DB() for now).
   nsMsgKey mKey;  // news: article number, local mail: key, imap: uid...
 
-  // Everything else here is just caching...
-  nsMsgKey m_threadId;
-  //  nsMsgKey m_threadParent;  // message this is a reply to, in thread.
-  PRTime m_date;
-  uint64_t m_messageSize;  // lines for news articles, bytes for mail messages
-  uint32_t m_flags;
-  // avoid parsing references every time we want one
+  // Ditch this!
   nsTArray<nsCString> m_references;
-
-  uint32_t m_initedValues;
 };
 
 #endif
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670816578 -46800
#      Mon Dec 12 16:42:58 2022 +1300
# Node ID 2db264e4e0bd138636c13b105ddf66bdd27c05a3
# Parent  7bfe9a8575997996665558b9c14c7221a4023478
WIP: fudge enough thread support to actually show a list of messages!

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -1,65 +1,83 @@
 #include "GlobalDB.h"
 
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
+#include "nsMsgThread2.h"
 #include "nsMsgEnumerator.h"
 
 class MsgEnumerator : public nsBaseMsgEnumerator {
  public:
   // TODO: provide move ctor to avoid copy here.
   MsgEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& keys)
       : mGlobalDB(db), mCur(0) {
     mKeys = keys.Clone();
     printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
   };
   MsgEnumerator() = delete;
 
   // nsIMsgEnumerator support.
   NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
     MOZ_ASSERT(mCur < mKeys.Length());
+    printf("XYZZY MsgEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
     RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mGlobalDB, mKeys[mCur++]);
     hdr.forget(aItem);
     return NS_OK;
   }
 
-  NS_IMETHOD HasMoreElements(bool* aResult) override {
-    *aResult = mCur < mKeys.Length();
+  NS_IMETHOD HasMoreElements(bool* result) override {
+    *result = mCur < mKeys.Length();
+    printf("XYZZY MsgEnumerator::HasMoreElements() -> %d < %d => %s\n",
+           (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
     return NS_OK;
   }
 
  protected:
   GlobalDB* mGlobalDB;
   nsTArray<nsMsgKey> mKeys;
   size_t mCur;
 };
 
 // TODO
 class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
  public:
-  explicit ThreadEnumerator(GlobalDB* db) : mGlobalDB(db) {
-    printf("XYZZY: ThreadEnumerator ctor\n");
+  ThreadEnumerator() = delete;
+  // TODO: provide move ctor to avoid copy here.
+  explicit ThreadEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& threadIDs)
+      : mGlobalDB(db), mCur(0) {
+    mThreadIDs = threadIDs.Clone();
+    printf("XYZZY: ThreadEnumerator ctor (%d threads)\n",
+           (int)threadIDs.Length());
   }
-  ThreadEnumerator() = delete;
 
   // nsIMsgThreadEnumerator support.
-  NS_IMETHOD GetNext(nsIMsgThread** aItem) override { return NS_ERROR_FAILURE; }
+  NS_IMETHOD GetNext(nsIMsgThread** thread) override {
+    MOZ_ASSERT(mCur < mThreadIDs.Length());
+    printf("XYZZY ThreadEnumerator::GetNext() -> %d\n", (int)mThreadIDs[mCur]);
+    RefPtr<nsMsgThread2> t = new nsMsgThread2(mGlobalDB, mThreadIDs[mCur++]);
+    t.forget(thread);
+    return NS_OK;
+  }
 
-  NS_IMETHOD HasMoreElements(bool* aResult) override {
-    *aResult = false;
+  NS_IMETHOD HasMoreElements(bool* result) override {
+    *result = mCur < mThreadIDs.Length();
+    printf("XYZZY ThreadEnumerator::HasMoreElements() -> %d < %d => %s\n",
+           (int)mCur, (int)mThreadIDs.Length(), *result ? "true" : "false");
     return NS_OK;
   }
 
  protected:
   GlobalDB* mGlobalDB;
+  nsTArray<nsMsgKey> mThreadIDs;
+  size_t mCur;
 };
 
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
@@ -982,17 +1000,20 @@ nsresult GlobalDB::FolderEnumerateMsgsWi
   RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
   e.forget(result);
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderEnumerateThreads(nsFolderKey folderID,
                                           nsIMsgThreadEnumerator** result) {
   // TODO
-  RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this);
+  nsTArray<nsMsgKey> threadIDs;
+  nsresult rv = FolderListAllKeys(folderID, threadIDs);
+  NS_ENSURE_SUCCESS(rv, rv);
+  RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
   e.forget(result);
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderSetProperty(nsFolderKey folderID,
                                      nsACString const& name,
                                      nsACString const& value) {
   // oooh, an UPSERT!
@@ -1069,8 +1090,16 @@ nsresult GlobalDB::MsgGetProperty(nsMsgK
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     return NS_OK;
   }
   return stmt->GetUTF8String(0, value);
 }
+
+// TODO: is parentKey root message of thread? Or any message?
+nsresult GlobalDB::ThreadEnumerateMessages(nsMsgKey parentKey,
+                                           nsIMsgEnumerator** enumerator) {
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {parentKey});
+  e.forget(enumerator);
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -166,16 +166,20 @@ class GlobalDB {
                           nsACString const& value);
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
 
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
+  // Thread stuff.
+  nsresult ThreadEnumerateMessages(nsMsgKey parentKey,
+                                   nsIMsgEnumerator** enumerator);
+
  private:
   nsresult InitSchema();
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
diff --git a/mailnews/db/msgdb/src/moz.build b/mailnews/db/msgdb/src/moz.build
--- a/mailnews/db/msgdb/src/moz.build
+++ b/mailnews/db/msgdb/src/moz.build
@@ -12,16 +12,17 @@ SOURCES += [
     "nsMailDatabase.cpp",
     "nsMsgDatabase.cpp",
     "nsMsgDatabase2.cpp",
     "nsMsgDatabaseEnumerators.cpp",
     "nsMsgHdr.cpp",
     "nsMsgHdr2.cpp",
     "nsMsgOfflineImapOperation.cpp",
     "nsMsgThread.cpp",
+    "nsMsgThread2.cpp",
     "nsNewsDatabase.cpp",
 ]
 
 FINAL_LIBRARY = "mail"
 
 XPCOM_MANIFESTS += [
     "components.conf",
 ]
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -481,16 +481,17 @@ NS_IMETHODIMP nsMsgHdr2::GetIsFlagged(bo
   uint32_t flags;
   nsresult rv = GetFlags(&flags);
   NS_ENSURE_SUCCESS(rv, rv);
   *isFlagged = !!(flags & nsMsgMessageFlags::Marked);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsKilled(bool* isKilled) {
+  *isKilled = false;
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
                                            char const* value) {
   nsDependentCString n(name);
   nsDependentCString v(value);
   if (n.EqualsLiteral("storeToken")) {
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.cpp b/mailnews/db/msgdb/src/nsMsgThread2.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgThread2.cpp
@@ -0,0 +1,142 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "msgCore.h"
+#include "nsCOMPtr.h"
+#include "nsMsgDatabase2.h"
+#include "nsMsgHdr2.h"
+#include "nsMsgThread2.h"
+#include "nsMsgMessageFlags.h"
+//#include "nsMsgEnumerator.h"
+#include "MailNewsTypes2.h"
+//#include "mozilla/DebugOnly.h"
+#include "GlobalDB.h"
+
+NS_IMPL_ISUPPORTS(nsMsgThread2, nsIMsgThread)
+
+nsMsgThread2::nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID) : mFolderDB(folderDB), mThreadID(threadID) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::nsMsgThread2()\n", mThreadID);
+}
+
+nsMsgThread2::~nsMsgThread2() {
+  printf("XYZZY [threadID=%d] nsMsgThread2::~nsMsgThread2()\n", mThreadID);
+}
+
+NS_IMETHODIMP nsMsgThread2::SetThreadKey(nsMsgKey threadKey) {
+  MOZ_ASSERT(false, "NOPE!");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetThreadKey(nsMsgKey* result) {
+  *result = mThreadID;
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetThreadKey()\n", mThreadID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetFlags(uint32_t* result) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetFlags()\n", mThreadID);
+  *result = nsMsgMessageFlags::Watched;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::SetFlags(uint32_t flags) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::SetFlags()\n", mThreadID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::SetSubject(const nsACString& subject) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::SetSubject()\n", mThreadID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetSubject(nsACString& subject) {
+  printf("XYZZY nsMsgThread2::GetSubject())\n");
+  return mFolderDB->DB().FetchMsgSubject(mThreadID, subject);
+}
+
+NS_IMETHODIMP nsMsgThread2::GetNumChildren(uint32_t* result) {
+  *result = 1;
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetNumChildren()\n", mThreadID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetNumUnreadChildren(uint32_t* result) {
+  *result = 0;
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetNumUnreadChildren()\n", mThreadID);
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP nsMsgThread2::AddChild(nsIMsgDBHdr* child, nsIMsgDBHdr* inReplyTo,
+                                    bool threadInThread,
+                                    nsIDBChangeAnnouncer* announcer) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::AddChild()\n", mThreadID);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetChildKeyAt(uint32_t aIndex, nsMsgKey* aResult) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildKeyAt(idx=%d)\n", mThreadID, aIndex);
+  *aResult = mThreadID;
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetChildHdrAt(uint32_t aIndex,
+                                         nsIMsgDBHdr** result) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildHdrAt(idx=%d)\n", mThreadID, aIndex);
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetChild(nsMsgKey msgKey, nsIMsgDBHdr** result) {
+
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetChild(msgKey=%d)\n", mThreadID, msgKey);
+  return GetRootHdr(result);
+//  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::RemoveChildAt(uint32_t aIndex) { return NS_OK; }
+
+NS_IMETHODIMP nsMsgThread2::RemoveChildHdr(nsIMsgDBHdr* child,
+                                          nsIDBChangeAnnouncer* announcer) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::MarkChildRead(bool bRead) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::MarkChildRead()\n", mThreadID);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::EnumerateMessages(nsMsgKey parentKey,
+                                             nsIMsgEnumerator** result) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages()\n", mThreadID);
+  return mFolderDB->ThreadEnumerateMessages(parentKey, result);
+//  NS_ADDREF(*result = new MsgEnumerator
+//                new nsMsgThread2Enumerator(this, parentKey, nullptr, nullptr));
+}
+
+
+NS_IMETHODIMP nsMsgThread2::GetRootHdr(nsIMsgDBHdr** result) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetRootHdr()\n", mThreadID);
+  nsCOMPtr<nsIMsgDBHdr> foo = new nsMsgHdr2(mFolderDB, mThreadID);
+  foo.forget(result);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetFirstUnreadChild(nsIMsgDBHdr** result) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetFirstUnreadChild()\n", mThreadID);
+  return GetRootHdr(result);
+  //return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgThread2::GetNewestMsgDate(uint32_t* seconds) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::GetNewestMsgDate()\n", mThreadID);
+
+  return mFolderDB->DB().FetchMsgDate(mThreadID, seconds);
+}
+
+NS_IMETHODIMP nsMsgThread2::SetNewestMsgDate(uint32_t aNewestMsgDate) {
+  printf("XYZZY [threadID=%d] nsMsgThread2::SetNewestMsgDate()\n", mThreadID);
+  return NS_OK;
+}
+
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.h b/mailnews/db/msgdb/src/nsMsgThread2.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgThread2.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _nsMsgThread2_H
+#define _nsMsgThread2_H
+
+#include "nsIMsgThread.h"
+//#include "nsString.h"
+#include "MailNewsTypes.h"
+#include "mdb.h"
+
+class nsIMsgDBHdr;
+class nsMsgDatabase2;
+//class GlobalDB;
+
+class nsMsgThread2 : public nsIMsgThread {
+ public:
+  nsMsgThread2() = delete;
+  nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID);
+
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIMSGTHREAD
+
+ protected:
+  virtual ~nsMsgThread2();
+  nsMsgDatabase2* mFolderDB;
+  nsMsgKey mThreadID;
+};
+
+#endif
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670818967 -46800
#      Mon Dec 12 17:22:47 2022 +1300
# Node ID e61920ef60b9d34350573c03e16166751825894c
# Parent  2db264e4e0bd138636c13b105ddf66bdd27c05a3
WIP: support generic get/set properties on nsMsgHdr2.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -1064,17 +1064,17 @@ nsresult GlobalDB::MsgSetProperty(nsMsgK
       ":value) ON CONFLICT(msg_id, name) DO UPDATE SET value=excluded.value;");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("name"_ns, name);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = stmt->BindUTF8StringByName("value"_ns, name);
+  rv = stmt->BindUTF8StringByName("value"_ns, value);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 nsresult GlobalDB::MsgGetProperty(nsMsgKey key, nsACString const& name,
                                   nsACString& value) {
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -17,18 +17,18 @@
 
 NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
 
 #define FLAGS_INITED 0x1
 #define CACHED_VALUES_INITED 0x2
 #define REFERENCES_INITED 0x4
 #define THREAD_PARENT_INITED 0x8
 
-nsMsgHdr2::nsMsgHdr2(GlobalDB* globaldb, nsMsgKey key)
-    : mDB(globaldb), mKey(key) {}
+nsMsgHdr2::nsMsgHdr2(nsMsgDatabase2* folderDB, nsMsgKey key)
+    : mDB(folderDB), mKey(key) {}
 
 nsMsgHdr2::~nsMsgHdr2() {}
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageKey(nsMsgKey* result) {
   *result = mKey;
   return NS_OK;
 }
 
@@ -274,16 +274,18 @@ NS_IMETHODIMP nsMsgHdr2::GetAuthor(char*
   *sender = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetSubject(char** subject) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgSubject(mKey, tmp);
   *subject = moz_xstrdup(tmp.get());
+  printf("XYZZY: [key=%d] nsMsgHdr2::GetSubject() => '%s'\n", (int)mKey,
+         *subject);
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetRecipients(char** recipients) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgRecipients(mKey, tmp);
   *recipients = moz_xstrdup(tmp.get());
   return rv;
@@ -482,51 +484,68 @@ NS_IMETHODIMP nsMsgHdr2::GetIsFlagged(bo
   nsresult rv = GetFlags(&flags);
   NS_ENSURE_SUCCESS(rv, rv);
   *isFlagged = !!(flags & nsMsgMessageFlags::Marked);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetIsKilled(bool* isKilled) {
   *isKilled = false;
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
                                            char const* value) {
   nsDependentCString n(name);
   nsDependentCString v(value);
+  // storeToken is part of the permanent schema.
   if (n.EqualsLiteral("storeToken")) {
     printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
     return DB().SetMsgStoreToken(mKey, v);
   }
 
-  printf("XYZZY: %d: ignoring nsMsgHdr2::SetStringProperty('%s')\n", (int)mKey,
-         name);
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return DB().MsgSetProperty(mKey, n, v);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const* name, char** value) {
   nsDependentCString n(name);
+  nsAutoCString tmp;
+  nsresult rv = NS_OK;
+  // storeToken is part of the permanent schema.
   if (n.EqualsLiteral("storeToken")) {
-    nsAutoCString tmp;
-    nsresult rv = DB().FetchMsgStoreToken(mKey, tmp);
-    printf("XYZZY: %d: GetStringProperty(%s) ==> %s\n", (int)mKey, name,
-           tmp.get());
-    *value = moz_xstrdup(tmp.get());
-    return rv;
+    rv = DB().FetchMsgStoreToken(mKey, tmp);
+  } else {
+    rv = DB().MsgGetProperty(mKey, n, tmp);
   }
+  *value = moz_xstrdup(tmp.get());
+  return rv;
+}
 
-  printf("XYZZY: ignoring nsMsgHdr2::GetStringProperty('%s')\n", name);
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
 NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const* name,
                                            unsigned int* value) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsAutoCString s;
+  nsresult rv = DB().MsgGetProperty(mKey, nsDependentCString(name), s);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (s.IsEmpty()) {
+    *value = 0;
+    return NS_OK;
+  }
+  // int64 is big enough to handle uint32_t (ToInteger() returns int32_t)
+  int64_t i = s.ToInteger64(&rv);
+  if (NS_SUCCEEDED(rv)) {
+    *value = (uint32_t)i;
+  } else {
+    *value = 0;  // TODO: print a warning.
+  }
+  return NS_OK;
 }
+
 NS_IMETHODIMP nsMsgHdr2::SetUint32Property(char const* name,
                                            unsigned int value) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  nsAutoCString s;
+  s.AppendInt(value);
+  return DB().MsgSetProperty(mKey, nsDependentCString(name), s);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetProperties(nsTArray<nsTString<char>>&) {
+  printf("XYZZY: NOT IMPLEMENTED nsMsgHdr2::GetProperties()\n");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.h b/mailnews/db/msgdb/src/nsMsgHdr2.h
--- a/mailnews/db/msgdb/src/nsMsgHdr2.h
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.h
@@ -16,28 +16,28 @@ class nsIMsgThread;
 class GlobalDB;
 
 class nsMsgHdr2 : public nsIMsgDBHdr {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIMSGDBHDR
 
   nsMsgHdr2() = delete;
-  nsMsgHdr2(GlobalDB* db, nsMsgKey key);
+  nsMsgHdr2(nsMsgDBFolder* folderDB, nsMsgKey key);
 
  protected:
   virtual ~nsMsgHdr2();
 
  private:
   nsresult ParseReferences(const char* references);
   const char* GetNextReference(const char* startNextRef, nsCString& reference,
                                bool acceptNonDelimitedReferences);
 
-  GlobalDB& DB() { return *mDB; }
-  GlobalDB* mDB;  // We might remove this in favour of a singleton or
-                  // something... (so access via DB() for now).
-  nsMsgKey mKey;  // news: article number, local mail: key, imap: uid...
+  GlobalDB& DB() { return mDB->DB(); }
+  nsMsgDatabase2* mDB;  // We might remove this in favour of a singleton or
+                        // something... (so access via DB() for now).
+  nsMsgKey mKey;        // news: article number, local mail: key, imap: uid...
 
   // Ditch this!
   nsTArray<nsCString> m_references;
 };
 
 #endif
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670821317 -46800
#      Mon Dec 12 18:01:57 2022 +1300
# Node ID 9b8e365c1a97bf7ff31fb5d53f314ee14c9ff2b4
# Parent  e61920ef60b9d34350573c03e16166751825894c
WIP: move msg/thread enumeration back from GlobalDB to nsMsgDatabase2. UGH.

Doing this to support nsIMsgDBHdr.folder ... which is pervasive but I don't like :-(

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -4,82 +4,16 @@
 #include "nsIFile.h"
 #include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 #include "nsMsgEnumerator.h"
 
-class MsgEnumerator : public nsBaseMsgEnumerator {
- public:
-  // TODO: provide move ctor to avoid copy here.
-  MsgEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& keys)
-      : mGlobalDB(db), mCur(0) {
-    mKeys = keys.Clone();
-    printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
-  };
-  MsgEnumerator() = delete;
-
-  // nsIMsgEnumerator support.
-  NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
-    MOZ_ASSERT(mCur < mKeys.Length());
-    printf("XYZZY MsgEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
-    RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mGlobalDB, mKeys[mCur++]);
-    hdr.forget(aItem);
-    return NS_OK;
-  }
-
-  NS_IMETHOD HasMoreElements(bool* result) override {
-    *result = mCur < mKeys.Length();
-    printf("XYZZY MsgEnumerator::HasMoreElements() -> %d < %d => %s\n",
-           (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
-    return NS_OK;
-  }
-
- protected:
-  GlobalDB* mGlobalDB;
-  nsTArray<nsMsgKey> mKeys;
-  size_t mCur;
-};
-
-// TODO
-class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
- public:
-  ThreadEnumerator() = delete;
-  // TODO: provide move ctor to avoid copy here.
-  explicit ThreadEnumerator(GlobalDB* db, nsTArray<nsMsgKey> const& threadIDs)
-      : mGlobalDB(db), mCur(0) {
-    mThreadIDs = threadIDs.Clone();
-    printf("XYZZY: ThreadEnumerator ctor (%d threads)\n",
-           (int)threadIDs.Length());
-  }
-
-  // nsIMsgThreadEnumerator support.
-  NS_IMETHOD GetNext(nsIMsgThread** thread) override {
-    MOZ_ASSERT(mCur < mThreadIDs.Length());
-    printf("XYZZY ThreadEnumerator::GetNext() -> %d\n", (int)mThreadIDs[mCur]);
-    RefPtr<nsMsgThread2> t = new nsMsgThread2(mGlobalDB, mThreadIDs[mCur++]);
-    t.forget(thread);
-    return NS_OK;
-  }
-
-  NS_IMETHOD HasMoreElements(bool* result) override {
-    *result = mCur < mThreadIDs.Length();
-    printf("XYZZY ThreadEnumerator::HasMoreElements() -> %d < %d => %s\n",
-           (int)mCur, (int)mThreadIDs.Length(), *result ? "true" : "false");
-    return NS_OK;
-  }
-
- protected:
-  GlobalDB* mGlobalDB;
-  nsTArray<nsMsgKey> mThreadIDs;
-  size_t mCur;
-};
-
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
 GlobalDB::~GlobalDB() {
   mStmtCache.FinalizeStatements();
@@ -958,16 +892,17 @@ nsresult GlobalDB::FolderFindOrCreate(ns
     NS_ENSURE_SUCCESS(rv, rv);
     *folderID = (nsFolderKey)rowid;
     printf("Created Folder (key='%d' uri='%s')\n", (int)(*folderID),
            nsPromiseFlatCString(folderURI).get());
   }
   return NS_OK;
 }
 
+#if 0
 nsresult GlobalDB::FolderEnumerateMsgs(nsFolderKey folderID,
                                        nsIMsgEnumerator** result) {
   nsTArray<nsMsgKey> keys;
   nsresult rv = FolderListAllKeys(folderID, keys);
   NS_ENSURE_SUCCESS(rv, rv);
   RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
   e.forget(result);
   return NS_OK;
@@ -1007,16 +942,17 @@ nsresult GlobalDB::FolderEnumerateThread
   // TODO
   nsTArray<nsMsgKey> threadIDs;
   nsresult rv = FolderListAllKeys(folderID, threadIDs);
   NS_ENSURE_SUCCESS(rv, rv);
   RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
   e.forget(result);
   return NS_OK;
 }
+#endif
 
 nsresult GlobalDB::FolderSetProperty(nsFolderKey folderID,
                                      nsACString const& name,
                                      nsACString const& value) {
   // oooh, an UPSERT!
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO folder_prop (folder_id, name, value) VALUES(:folderID, "
       ":name, :value) ON CONFLICT(folder_id, name) DO UPDATE SET "
@@ -1090,16 +1026,8 @@ nsresult GlobalDB::MsgGetProperty(nsMsgK
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     return NS_OK;
   }
   return stmt->GetUTF8String(0, value);
 }
-
-// TODO: is parentKey root message of thread? Or any message?
-nsresult GlobalDB::ThreadEnumerateMessages(nsMsgKey parentKey,
-                                           nsIMsgEnumerator** enumerator) {
-  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {parentKey});
-  e.forget(enumerator);
-  return NS_OK;
-}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -48,18 +48,18 @@ struct RawHdr {
   int pseudoHdr{0};
   int enigmail{0};
   int notAPhishMessage{0};
 };
 
 class nsIMsgDBHdr;
 class nsIDBChangeListener;
 class nsMsgHdr2;
-class nsIMsgEnumerator;
-class nsIMsgThreadEnumerator;
+// class nsIMsgEnumerator;
+// class nsIMsgThreadEnumerator;
 class nsIMsgSearchTerm;
 
 class GlobalDB {
  public:
   static GlobalDB& get();
 
   GlobalDB();
   ~GlobalDB();
@@ -140,45 +140,49 @@ class GlobalDB {
   nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                               nsIDBChangeListener* instigator, bool commit,
                               bool notify);
 
   nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
+#if 0
   nsresult FolderEnumerateMsgs(nsFolderKey folderID, nsIMsgEnumerator** result);
   nsresult FolderReverseEnumerateMsgs(nsFolderKey folderID,
                                       nsIMsgEnumerator** result);
   nsresult FolderEnumerateMsgsFiltered(
       nsFolderKey folderID,
       const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
       nsIMsgEnumerator** aResult);
   nsresult FolderEnumerateMsgsWithFlag(nsFolderKey folderID, uint32_t flag,
                                        nsIMsgEnumerator** result);
   nsresult FolderEnumerateThreads(nsFolderKey folderID,
                                   nsIMsgThreadEnumerator** result);
+#endif
 
   // Icky random-property stuff on folder and message.
   nsresult FolderSetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString const& value);
   nsresult FolderGetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString& value);
   nsresult MsgSetProperty(nsMsgKey key, nsACString const& name,
                           nsACString const& value);
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
 
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   // Thread stuff.
+#if 0
   nsresult ThreadEnumerateMessages(nsMsgKey parentKey,
                                    nsIMsgEnumerator** enumerator);
+#endif
 
  private:
   nsresult InitSchema();
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -4,28 +4,30 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 // this file implements the nsMsgDatabase2 interface using the MDB Interface.
 
 #include "nscore.h"
 #include "msgCore.h"
 #include "nsMsgDatabase2.h"
 #include "nsDBFolderInfo2.h"
-#include "nsMsgThread.h"
+#include "nsMsgThread2.h"
+#include "nsMsgHdr2.h"
 #include "nsIDBChangeListener.h"
 #include "prprf.h"
 #include "nsMsgFolderFlags.h"
 #include "nsMsgUtils.h"
 #include "nsMemory.h"
 #include "nsIMsgSearchTerm.h"
 #include "nsIMsgDBView.h"  // for nsMsgViewFlagsType
 #include "nsIPrefService.h"
 #include "nsIPrefBranch.h"
 #include "MailNewsTypes2.h"
 #include "GlobalDB.h"
+#include "nsMsgEnumerator.h"  // for js-enabled base enumerators
 #include "mozilla/Logging.h"
 #include "mozilla/Telemetry.h"
 #include "mozilla/Components.h"
 #include "mozilla/mailnews/MimeHeaderParser.h"
 #include "mozilla/intl/LocaleService.h"
 
 using namespace mozilla::mailnews;
 using namespace mozilla;
@@ -44,16 +46,86 @@ static const nsMsgKey kFirstPseudoKey = 
 
 // LazyLogModule DBLog("MsgDB"); // just use original one for now...
 
 static bool gGotGlobalPrefs = false;
 static bool gThreadWithoutRe = true;
 static bool gStrictThreading = false;
 static bool gCorrectThreading = false;
 
+// Would much rather have MsgEnumerator in GlobalDB, with
+// no reference to nsMsgDataBase2 at all, but we need to provide
+// nsIMsgDBHdr.folder, dammit.
+class MsgEnumerator : public nsBaseMsgEnumerator {
+ public:
+  // TODO: provide move ctor to avoid copy here.
+  MsgEnumerator(nsMsgDatabase2* folderDB, nsTArray<nsMsgKey> const& keys)
+      : mFolderDB(folderDB), mCur(0) {
+    mKeys = keys.Clone();
+    printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
+  };
+  MsgEnumerator() = delete;
+
+  // nsIMsgEnumerator support.
+  NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
+    MOZ_ASSERT(mCur < mKeys.Length());
+    printf("XYZZY MsgEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
+    RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mFolderDB, mKeys[mCur++]);
+    hdr.forget(aItem);
+    return NS_OK;
+  }
+
+  NS_IMETHOD HasMoreElements(bool* result) override {
+    *result = mCur < mKeys.Length();
+    printf("XYZZY MsgEnumerator::HasMoreElements() -> %d < %d => %s\n",
+           (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
+    return NS_OK;
+  }
+
+ protected:
+  nsMsgDatabase2* mFolderDB;
+  nsTArray<nsMsgKey> mKeys;
+  size_t mCur;
+};
+
+// TODO
+class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
+ public:
+  ThreadEnumerator() = delete;
+  // TODO: provide move ctor to avoid copy here.
+  explicit ThreadEnumerator(nsMsgDatabase2* folderDB,
+                            nsTArray<nsMsgKey> const& threadIDs)
+      : mFolderDB(folderDB), mCur(0) {
+    mThreadIDs = threadIDs.Clone();
+    printf("XYZZY: ThreadEnumerator ctor (%d threads)\n",
+           (int)threadIDs.Length());
+  }
+
+  // nsIMsgThreadEnumerator support.
+  NS_IMETHOD GetNext(nsIMsgThread** thread) override {
+    MOZ_ASSERT(mCur < mThreadIDs.Length());
+    printf("XYZZY ThreadEnumerator::GetNext() -> %d\n", (int)mThreadIDs[mCur]);
+    RefPtr<nsMsgThread2> t = new nsMsgThread2(mFolderDB, mThreadIDs[mCur++]);
+    t.forget(thread);
+    return NS_OK;
+  }
+
+  NS_IMETHOD HasMoreElements(bool* result) override {
+    *result = mCur < mThreadIDs.Length();
+    printf("XYZZY ThreadEnumerator::HasMoreElements() -> %d < %d => %s\n",
+           (int)mCur, (int)mThreadIDs.Length(), *result ? "true" : "false");
+    return NS_OK;
+  }
+
+ protected:
+  nsMsgDatabase2* mFolderDB;
+  nsTArray<nsMsgKey> mThreadIDs;
+  size_t mCur;
+};
+
 NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIMsgOfflineOpsDatabase,
                   nsIDBChangeAnnouncer)
 
 // static
 PRTime nsMsgDatabase2::sLastUseTime;
 
 void nsMsgDatabase2::GetGlobalPrefs() {
   if (!gGotGlobalPrefs) {
@@ -236,17 +308,17 @@ NS_IMETHODIMP nsMsgDatabase2::ContainsKe
 NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForKey(nsMsgKey key,
                                               nsIMsgDBHdr** pmsgHdr) {
   bool exists;
   nsresult rv = DB().FolderContainsKey(mFolderID, key, &exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     return NS_MSG_MESSAGE_NOT_FOUND;
   }
-  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(pmsgHdr);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::DeleteMessage(nsMsgKey key,
                                             nsIDBChangeListener* instigator,
                                             bool commit) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
@@ -631,66 +703,97 @@ NS_IMETHODIMP nsMsgDatabase2::HasNew(boo
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetFirstNew(nsMsgKey* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO?
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateMessages(nsIMsgEnumerator** result) {
-  return DB().FolderEnumerateMsgs(mFolderID, result);
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = DB().FolderListAllKeys(mFolderID, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
+  e.forget(result);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::ReverseEnumerateMessages(nsIMsgEnumerator** result) {
-  return DB().FolderReverseEnumerateMsgs(mFolderID, result);
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = DB().FolderListAllKeys(mFolderID, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  keys.Reverse();
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
+  e.forget(result);
+  return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::GetFilterEnumerator(
     const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool reverse,
     nsIMsgEnumerator** result) {
-  return DB().FolderEnumerateMsgsFiltered(mFolderID, searchTerms, reverse,
-                                          result);
+  // TODO
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
+  e.forget(result);
+  return NS_OK;
 }
 
-NS_IMETHODIMP
-nsMsgDatabase2::SyncCounts() {
+nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
+                                                   uint32_t* pFlag) {
   // TODO
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
+  e.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
   return DB().FolderListAllKeys(mFolderID, keys);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
-  return DB().FolderEnumerateThreads(mFolderID, result);
+  // TODO
+  nsTArray<nsMsgKey> threadIDs;
+  nsresult rv = DB().FolderListAllKeys(mFolderID, threadIDs);
+  NS_ENSURE_SUCCESS(rv, rv);
+  RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
+  e.forget(result);
+  return NS_OK;
 }
 
-nsresult nsMsgDatabase2::EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
-                                                   uint32_t* pFlag) {
-  return DB().FolderEnumerateMsgsWithFlag(mFolderID, *pFlag, result);
+// Helper fn for nsMsgThread2
+// TODO: is parentKey root message of thread? Or any message?
+nsresult nsMsgDatabase2::ThreadEnumerateMessages(
+    nsMsgKey parentKey, nsIMsgEnumerator** enumerator) {
+  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {parentKey});
+  e.forget(enumerator);
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsMsgDatabase2::SyncCounts() {
+  // TODO
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
   NS_ENSURE_ARG_POINTER(result);
 
   printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
 
   MOZ_ASSERT(key == nsMsgKey_None);
   // TODO: ++elegance;
   RawHdr blank;
   nsresult rv = DB().StashMsg(blank, &key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = DB().AddMsgToFolder(key, mFolderID);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(mGlobalDB, key);
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
   printf("XYZZY: AddnewHdrToDB()\n");
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.h
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -6,17 +6,17 @@
 #ifndef _nsMsgDatabase2_H_
 #define _nsMsgDatabase2_H_
 
 #include "mozilla/Attributes.h"
 // #include "mozilla/MemoryReporting.h"
 #include "mozilla/Path.h"
 // #include "nsIFile.h"
 #include "nsIMsgDatabase.h"
-#include "nsMsgHdr2.h"
+// #include "nsMsgHdr2.h"
 #include "nsString.h"
 #include "nsIDBChangeAnnouncer.h"
 #include "nsMsgMessageFlags.h"
 #include "nsIMsgFolder.h"
 #include "nsDBFolderInfo2.h"
 #include "mozilla/intl/Collator.h"
 #include "nsIMimeConverter.h"
 #include "nsCOMPtr.h"
@@ -24,47 +24,49 @@
 #include "nsTArray.h"
 #include "nsTObserverArray.h"
 
 using mozilla::intl::Collator;
 
 class nsMsgThread;
 class nsMsgDatabase2;
 class nsIMsgThread;
+class nsMsgHdr2;
 
 class nsMsgDatabase2 : public nsIMsgOfflineOpsDatabase {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIDBCHANGEANNOUNCER
   NS_DECL_NSIMSGDATABASE
   NS_DECL_NSIMSGOFFLINEOPSDATABASE
 
   explicit nsMsgDatabase2(nsIMsgFolder* folder);
   nsMsgDatabase2() = delete;
 
+  GlobalDB& DB() { return *mGlobalDB; }
+
   virtual nsresult MarkHdrReadInDB(nsIMsgDBHdr* msgHdr, bool bRead,
                                    nsIDBChangeListener* instigator);
   // virtual nsresult CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result);
   virtual nsresult GetThreadForMsgKey(nsMsgKey msgKey, nsIMsgThread** result);
   virtual nsresult EnumerateMessagesWithFlag(nsIMsgEnumerator** result,
                                              uint32_t* pFlag);
 
-  //////////////////////////////////////////////////////////////////////////////
-  // nsMsgDatabase2 methods:
-
+  nsresult ThreadEnumerateMessages(nsMsgKey parentKey,
+                                   nsIMsgEnumerator** enumerator);
   virtual uint32_t GetCurVersion();
   nsresult GetCollationKeyGenerator();
   nsIMimeConverter* GetMimeConverter();
 
 #ifdef DEBUG
   virtual nsresult DumpContents();
 #endif
   friend class nsDBFolderInfo2;
   friend class nsMsgHdr2;
-  friend class nsMsgThread;
+  //  friend class nsMsgThread2;
 
  protected:
   virtual ~nsMsgDatabase2();
 
   // prefs stuff - in future, we might want to cache the prefs interface
   nsresult GetBoolPref(const char* prefName, bool* result);
   nsresult GetIntPref(const char* prefName, int32_t* result);
   virtual void GetGlobalPrefs();
@@ -103,17 +105,16 @@ class nsMsgDatabase2 : public nsIMsgOffl
                                  bool applyToFlaggedMessages,
                                  nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
   nsresult FindExcessMessages(uint32_t numHeadersToKeep,
                               bool applyToFlaggedMessages,
                               nsTArray<RefPtr<nsIMsgDBHdr>>& hdrsToDelete);
 
   // not sure how we'll manage global DB yet, so use DB() to access.
   GlobalDB* mGlobalDB;
-  GlobalDB& DB() { return *mGlobalDB; }
   uint32_t mFolderID;
 
   nsCOMPtr<nsIMsgFolder> m_folder;
   RefPtr<nsDBFolderInfo2> m_dbFolderInfo;
   nsMsgKey m_nextPseudoMsgKey;
 
   // used to remember the args to Open for async open.
   nsTObserverArray<nsCOMPtr<nsIDBChangeListener>> m_ChangeListeners;
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -18,17 +18,17 @@
 NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
 
 #define FLAGS_INITED 0x1
 #define CACHED_VALUES_INITED 0x2
 #define REFERENCES_INITED 0x4
 #define THREAD_PARENT_INITED 0x8
 
 nsMsgHdr2::nsMsgHdr2(nsMsgDatabase2* folderDB, nsMsgKey key)
-    : mDB(folderDB), mKey(key) {}
+    : mFolderDB(folderDB), mKey(key) {}
 
 nsMsgHdr2::~nsMsgHdr2() {}
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageKey(nsMsgKey* result) {
   *result = mKey;
   return NS_OK;
 }
 
@@ -37,16 +37,17 @@ NS_IMETHODIMP nsMsgHdr2::GetThreadId(nsM
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetThreadId(nsMsgKey threadID) {
   return DB().SetMsgThreadID(mKey, threadID);
 }
 
 // TODO: should be read-only?
 NS_IMETHODIMP nsMsgHdr2::SetMessageKey(nsMsgKey value) {
+  printf("XYZZY: NOT IMPLEMENTED nsMsgHdr2::SetMessageKey()\n");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetFlags(uint32_t* result) {
   nsresult rv = DB().FetchMsgFlags(mKey, result);
   NS_ENSURE_SUCCESS(rv, rv);
   // TODO: Whatever GetStatusFlags() was doing to massage the flags.
 #ifdef DEBUG_bienvenu
@@ -358,18 +359,19 @@ NS_IMETHODIMP nsMsgHdr2::GetEffectiveCha
 NS_IMETHODIMP nsMsgHdr2::SetThreadParent(nsMsgKey inKey) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetThreadParent(nsMsgKey* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetFolder(nsIMsgFolder** result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+NS_IMETHODIMP nsMsgHdr2::GetFolder(nsIMsgFolder** folder) {
+  NS_IF_ADDREF(*folder = mFolderDB->m_folder);
+  return NS_OK;
 }
 
 /**
  * Roughly speaking, get the next message-id (starts with a '<' ends with a
  *  '>').  Except, we also try to handle the case where your reference is of
  *  a prehistoric vintage that just stuck any old random junk in there.  Our
  *  old logic would (unintentionally?) just trim the whitespace off the front
  *  and hand you everything after that.  We change things at all because that
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.h b/mailnews/db/msgdb/src/nsMsgHdr2.h
--- a/mailnews/db/msgdb/src/nsMsgHdr2.h
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.h
@@ -6,38 +6,40 @@
 #ifndef _nsMsgHdr2_H
 #define _nsMsgHdr2_H
 
 #include "mozilla/MemoryReporting.h"
 #include "nsIMsgHdr.h"
 #include "nsString.h"
 #include "MailNewsTypes.h"
 #include "nsTArray.h"
+#include "nsMsgDatabase2.h"
 
 class nsIMsgThread;
 class GlobalDB;
+class nsIMsgEnumerator;
 
 class nsMsgHdr2 : public nsIMsgDBHdr {
  public:
   NS_DECL_ISUPPORTS
   NS_DECL_NSIMSGDBHDR
 
   nsMsgHdr2() = delete;
-  nsMsgHdr2(nsMsgDBFolder* folderDB, nsMsgKey key);
+  nsMsgHdr2(nsMsgDatabase2* folderDB, nsMsgKey key);
 
  protected:
   virtual ~nsMsgHdr2();
 
  private:
   nsresult ParseReferences(const char* references);
   const char* GetNextReference(const char* startNextRef, nsCString& reference,
                                bool acceptNonDelimitedReferences);
 
-  GlobalDB& DB() { return mDB->DB(); }
-  nsMsgDatabase2* mDB;  // We might remove this in favour of a singleton or
-                        // something... (so access via DB() for now).
-  nsMsgKey mKey;        // news: article number, local mail: key, imap: uid...
+  GlobalDB& DB() { return mFolderDB->DB(); }
+  nsMsgDatabase2* mFolderDB;  // We might remove this in favour of a singleton
+                              // or something... (so access via DB() for now).
+  nsMsgKey mKey;  // news: article number, local mail: key, imap: uid...
 
   // Ditch this!
   nsTArray<nsCString> m_references;
 };
 
 #endif
diff --git a/mailnews/local/src/nsMailboxUrl.cpp b/mailnews/local/src/nsMailboxUrl.cpp
--- a/mailnews/local/src/nsMailboxUrl.cpp
+++ b/mailnews/local/src/nsMailboxUrl.cpp
@@ -220,29 +220,26 @@ NS_IMETHODIMP nsMailboxUrl::GetUri(nsACS
   return NS_OK;
 }
 
 nsresult nsMailboxUrl::GetMsgHdrForKey(nsMsgKey msgKey, nsIMsgDBHdr** aMsgHdr) {
   nsresult rv = NS_OK;
   if (aMsgHdr && m_filePath) {
     nsCOMPtr<nsIMsgDatabase> mailDBFactory;
     nsCOMPtr<nsIMsgDatabase> mailDB;
-    nsCOMPtr<nsIMsgDBService> msgDBService =
-        do_GetService("@mozilla.org/msgDatabase/msgDBService;1", &rv);
+
+    nsCOMPtr<nsIMsgFolder> folder;
+    rv = GetFolder(getter_AddRefs(folder));
+    NS_ENSURE_SUCCESS(rv, rv);
 
-    if (msgDBService) {
-      rv = msgDBService->OpenMailDBFromFile(m_filePath, nullptr, false, false,
-                                            getter_AddRefs(mailDB));
-    }
-    if (NS_SUCCEEDED(rv) && mailDB) {
-      // Did we get a db back?
-      rv = mailDB->GetMsgHdrForKey(msgKey, aMsgHdr);
-    } else {
-      rv = NS_OK;
-    }
+    rv = folder->GetMsgDatabase(getter_AddRefs(mailDB));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = mailDB->GetMsgHdrForKey(msgKey, aMsgHdr);
+    NS_ENSURE_SUCCESS(rv, rv);
+
   } else {
     rv = NS_ERROR_NULL_POINTER;
   }
 
   return rv;
 }
 
 NS_IMETHODIMP nsMailboxUrl::GetMessageHeader(nsIMsgDBHdr** aMsgHdr) {
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670827937 -46800
#      Mon Dec 12 19:52:17 2022 +1300
# Node ID a20e7c4ff7e0be9b4864537d590c50a63dd3ee4f
# Parent  9b8e365c1a97bf7ff31fb5d53f314ee14c9ff2b4
WIP: unstub some of the msg flag-twiddling methods.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -743,17 +743,17 @@ nsresult GlobalDB::SetMsgStoreToken(nsMs
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
-// odd flag-twiddling ones
+// odd flag-twiddling ones (TODO: rationalise these)
 nsresult GlobalDB::FetchMsgIsRead(nsMsgKey key, bool* isRead) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FetchMsgIsMarked(nsMsgKey key, bool* isMarked) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -769,25 +769,62 @@ nsresult GlobalDB::FetchMsgIsWatched(nsM
 //   return NS_ERROR_NOT_IMPLEMENTED;
 // }
 
 nsresult GlobalDB::FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgIsRead(nsMsgKey key, bool isRead) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  uint32_t oldFlags;
+  nsresult rv = FetchMsgFlags(key, &oldFlags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  uint32_t flags = oldFlags;
+  if (isRead) {
+    flags |= nsMsgMessageFlags::Read;
+  } else {
+    flags &= ~nsMsgMessageFlags::Read;
+  }
+  if (flags == oldFlags) {
+    return NS_OK;
+  }
+  return SetMsgFlags(key, flags);
 }
 
+// TODO: consistant naming. should be Marked, not Flagged.
 nsresult GlobalDB::SetMsgIsFlagged(nsMsgKey key, bool isFlagged) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  uint32_t oldFlags;
+  nsresult rv = FetchMsgFlags(key, &oldFlags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  uint32_t flags = oldFlags;
+  if (isFlagged) {
+    flags |= nsMsgMessageFlags::Marked;
+  } else {
+    flags &= ~nsMsgMessageFlags::Marked;
+  }
+  if (flags == oldFlags) {
+    return NS_OK;
+  }
+  return SetMsgFlags(key, flags);
 }
 
 nsresult GlobalDB::SetMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  uint32_t oldFlags;
+  nsresult rv = FetchMsgFlags(key, &oldFlags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  uint32_t flags = oldFlags;
+  if (hasAttachments) {
+    flags |= nsMsgMessageFlags::Attachment;
+  } else {
+    flags &= ~nsMsgMessageFlags::Attachment;
+  }
+  if (flags == oldFlags) {
+    return NS_OK;
+  }
+  return SetMsgFlags(key, flags);
 }
 
 // to support nsMsgDatabase2
 nsresult GlobalDB::FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                                      bool* containsKey) {
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT 1 FROM msg_folder WHERE msg_id=:msgKey AND folder_id=:folderKey");
   NS_ENSURE_STATE(stmt);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670892813 -46800
#      Tue Dec 13 13:53:33 2022 +1300
# Node ID f7a0fbd909c36d6f729310ea6a7c4e9b5fbd6667
# Parent  a20e7c4ff7e0be9b4864537d590c50a63dd3ee4f
WIP: implement some of the msg flag manipulation fns

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -745,37 +745,59 @@ nsresult GlobalDB::SetMsgStoreToken(nsMs
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 // odd flag-twiddling ones (TODO: rationalise these)
 nsresult GlobalDB::FetchMsgIsRead(nsMsgKey key, bool* isRead) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  uint32_t flags;
+  nsresult rv = FetchMsgFlags(key, &flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isRead = flags & nsMsgMessageFlags::Read;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgIsMarked(nsMsgKey key, bool* isMarked) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  uint32_t flags;
+  nsresult rv = FetchMsgFlags(key, &flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isMarked = flags & nsMsgMessageFlags::Marked;
+  return NS_OK;
 }
 
+// return true if the msg is in a thread with Ignored flag.
+// TODO: this is too easy to confuse with msg-related Fetch fns.
 nsresult GlobalDB::FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO: For now threads only have root message. Fix.
+  uint32_t flags;
+  nsresult rv = FetchMsgFlags(key, &flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isIgnored = flags & nsMsgMessageFlags::Ignored;
+  return NS_OK;
 }
 
+// return true if the msg is in a thread with Watched flag.
+// TODO: this is too easy to confuse with msg-related Fetch fns.
 nsresult GlobalDB::FetchMsgIsWatched(nsMsgKey key, bool* isWatched) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // TODO: For now threads only have root message. Fix.
+  uint32_t flags;
+  nsresult rv = FetchMsgFlags(key, &flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *isWatched = flags & nsMsgMessageFlags::Watched;
+  return NS_OK;
 }
 
-// nsresult GlobalDB::FetchMsgIsFlagged(nsMsgKey key, bool isFlagged) {
-//   return NS_ERROR_NOT_IMPLEMENTED;
-// }
-
-nsresult GlobalDB::FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+nsresult GlobalDB::FetchMsgHasAttachments(nsMsgKey key, bool* hasAttachments) {
+  uint32_t flags;
+  nsresult rv = FetchMsgFlags(key, &flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *hasAttachments = flags & nsMsgMessageFlags::Attachment;
+  return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgIsRead(nsMsgKey key, bool isRead) {
   uint32_t oldFlags;
   nsresult rv = FetchMsgFlags(key, &oldFlags);
   NS_ENSURE_SUCCESS(rv, rv);
   uint32_t flags = oldFlags;
   if (isRead) {
@@ -784,23 +806,22 @@ nsresult GlobalDB::SetMsgIsRead(nsMsgKey
     flags &= ~nsMsgMessageFlags::Read;
   }
   if (flags == oldFlags) {
     return NS_OK;
   }
   return SetMsgFlags(key, flags);
 }
 
-// TODO: consistant naming. should be Marked, not Flagged.
-nsresult GlobalDB::SetMsgIsFlagged(nsMsgKey key, bool isFlagged) {
+nsresult GlobalDB::SetMsgIsMarked(nsMsgKey key, bool isMarked) {
   uint32_t oldFlags;
   nsresult rv = FetchMsgFlags(key, &oldFlags);
   NS_ENSURE_SUCCESS(rv, rv);
   uint32_t flags = oldFlags;
-  if (isFlagged) {
+  if (isMarked) {
     flags |= nsMsgMessageFlags::Marked;
   } else {
     flags &= ~nsMsgMessageFlags::Marked;
   }
   if (flags == oldFlags) {
     return NS_OK;
   }
   return SetMsgFlags(key, flags);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -105,23 +105,25 @@ class GlobalDB {
   nsresult SetMsgThreadID(nsMsgKey key, nsMsgKey threadID);
   nsresult SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority);
   nsresult SetMsgAccountKey(nsMsgKey key, nsACString const& accountKey);
   nsresult SetMsgStoreToken(nsMsgKey key, nsACString const& storeToken);
 
   // odd flag-twiddling ones
   nsresult FetchMsgIsRead(nsMsgKey key, bool* isRead);
   nsresult FetchMsgIsMarked(nsMsgKey key, bool* isMarked);
+  nsresult FetchMsgHasAttachments(nsMsgKey key, bool* hasAttachments);
+
+  // return true if the msg is in a thread with Ignored flag.
   nsresult FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored);
+  // return true if the msg is in a thread with Watched flag.
   nsresult FetchMsgIsWatched(nsMsgKey key, bool* isWatched);
-  // nsresult FetchMsgIsFlagged(nsMsgKey key, bool isFlagged);
-  nsresult FetchMsgHasAttachments(nsMsgKey key, bool hasAttachments);
 
   nsresult SetMsgIsRead(nsMsgKey key, bool isRead);
-  nsresult SetMsgIsFlagged(nsMsgKey key, bool isFlagged);
+  nsresult SetMsgIsMarked(nsMsgKey key, bool isMarked);
   nsresult SetMsgHasAttachments(nsMsgKey key, bool hasAttachments);
 
   // oddities
   nsresult MarkMsgRead(nsMsgKey key, bool isRead,
                        nsIDBChangeListener* instigator);
   nsresult SetMsgFlag(nsMsgKey key, bool value, nsMsgMessageFlagType flag,
                       nsIDBChangeListener* instigator);
 
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -55,33 +55,38 @@ static bool gCorrectThreading = false;
 // no reference to nsMsgDataBase2 at all, but we need to provide
 // nsIMsgDBHdr.folder, dammit.
 class MsgEnumerator : public nsBaseMsgEnumerator {
  public:
   // TODO: provide move ctor to avoid copy here.
   MsgEnumerator(nsMsgDatabase2* folderDB, nsTArray<nsMsgKey> const& keys)
       : mFolderDB(folderDB), mCur(0) {
     mKeys = keys.Clone();
-    printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
+    // printf("XYZZY: MsgEnumerator ctor (%d keys)\n", (int)keys.Length());
   };
   MsgEnumerator() = delete;
 
   // nsIMsgEnumerator support.
   NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
-    MOZ_ASSERT(mCur < mKeys.Length());
-    printf("XYZZY MsgEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
+    if (mCur >= mKeys.Length()) {
+      *aItem = nullptr;
+      // NOTE: JSMsgIterator doesn't call HasMoreElements and relies on this
+      // behaviour.
+      return NS_ERROR_ILLEGAL_VALUE;
+    }
+    // printf("XYZZY MsgEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
     RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mFolderDB, mKeys[mCur++]);
     hdr.forget(aItem);
     return NS_OK;
   }
 
   NS_IMETHOD HasMoreElements(bool* result) override {
     *result = mCur < mKeys.Length();
-    printf("XYZZY MsgEnumerator::HasMoreElements() -> %d < %d => %s\n",
-           (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
+    // printf("XYZZY MsgEnumerator::HasMoreElements() -> %d < %d => %s\n",
+    //        (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
     return NS_OK;
   }
 
  protected:
   nsMsgDatabase2* mFolderDB;
   nsTArray<nsMsgKey> mKeys;
   size_t mCur;
 };
@@ -90,33 +95,39 @@ class MsgEnumerator : public nsBaseMsgEn
 class ThreadEnumerator : public nsBaseMsgThreadEnumerator {
  public:
   ThreadEnumerator() = delete;
   // TODO: provide move ctor to avoid copy here.
   explicit ThreadEnumerator(nsMsgDatabase2* folderDB,
                             nsTArray<nsMsgKey> const& threadIDs)
       : mFolderDB(folderDB), mCur(0) {
     mThreadIDs = threadIDs.Clone();
-    printf("XYZZY: ThreadEnumerator ctor (%d threads)\n",
-           (int)threadIDs.Length());
+    // printf("XYZZY: ThreadEnumerator ctor (%d threads)\n",
+    //        (int)threadIDs.Length());
   }
 
   // nsIMsgThreadEnumerator support.
   NS_IMETHOD GetNext(nsIMsgThread** thread) override {
-    MOZ_ASSERT(mCur < mThreadIDs.Length());
-    printf("XYZZY ThreadEnumerator::GetNext() -> %d\n", (int)mThreadIDs[mCur]);
+    if (mCur >= mThreadIDs.Length()) {
+      *thread = nullptr;
+      // NOTE: JSMsgIterator doesn't call HasMoreElements and relies on this
+      // behaviour.
+      return NS_ERROR_ILLEGAL_VALUE;
+    }
+    // printf("XYZZY ThreadEnumerator::GetNext() -> %d\n",
+    // (int)mThreadIDs[mCur]);
     RefPtr<nsMsgThread2> t = new nsMsgThread2(mFolderDB, mThreadIDs[mCur++]);
     t.forget(thread);
     return NS_OK;
   }
 
   NS_IMETHOD HasMoreElements(bool* result) override {
     *result = mCur < mThreadIDs.Length();
-    printf("XYZZY ThreadEnumerator::HasMoreElements() -> %d < %d => %s\n",
-           (int)mCur, (int)mThreadIDs.Length(), *result ? "true" : "false");
+    // printf("XYZZY ThreadEnumerator::HasMoreElements() -> %d < %d => %s\n",
+    //        (int)mCur, (int)mThreadIDs.Length(), *result ? "true" : "false");
     return NS_OK;
   }
 
  protected:
   nsMsgDatabase2* mFolderDB;
   nsTArray<nsMsgKey> mThreadIDs;
   size_t mCur;
 };
@@ -789,25 +800,25 @@ NS_IMETHODIMP nsMsgDatabase2::CreateNewH
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
-  printf("XYZZY: AddnewHdrToDB()\n");
+  printf("XYZZY: AddnewHdrToDB() NOT IMPLEMENTED\n");
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CopyHdrFromExistingHdr(nsMsgKey key,
                                                      nsIMsgDBHdr* existingHdr,
                                                      bool addHdrToDB,
                                                      nsIMsgDBHdr** newHdr) {
-  printf("XYZZY: CopyHdrFromExistingHdr(key=%d)\n", (int)key);
+  printf("XYZZY: CopyHdrFromExistingHdr(key=%d) NOT IMPLEMENTED\n", (int)key);
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::CompareCollationKeys(const nsTArray<uint8_t>& key1,
                                      const nsTArray<uint8_t>& key2,
                                      int32_t* result) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -96,17 +96,17 @@ NS_IMETHODIMP nsMsgHdr2::MarkHasAttachme
   return DB().SetMsgHasAttachments(mKey, bHasAttachments);
 }
 
 NS_IMETHODIMP nsMsgHdr2::MarkRead(bool bRead) {
   return DB().SetMsgIsRead(mKey, bRead);
 }
 
 NS_IMETHODIMP nsMsgHdr2::MarkFlagged(bool bFlagged) {
-  return DB().SetMsgIsFlagged(mKey, bFlagged);
+  return DB().SetMsgIsMarked(mKey, bFlagged);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetNumReferences(uint16_t* result) {
   nsCString refs;
   nsresult rv = DB().FetchMsgReferences(mKey, refs);
   NS_ENSURE_SUCCESS(rv, rv);
   ParseReferences(refs.get());
 
@@ -275,18 +275,18 @@ NS_IMETHODIMP nsMsgHdr2::GetAuthor(char*
   *sender = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetSubject(char** subject) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgSubject(mKey, tmp);
   *subject = moz_xstrdup(tmp.get());
-  printf("XYZZY: [key=%d] nsMsgHdr2::GetSubject() => '%s'\n", (int)mKey,
-         *subject);
+  // printf("XYZZY: [key=%d] nsMsgHdr2::GetSubject() => '%s'\n", (int)mKey,
+  //        *subject);
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetRecipients(char** recipients) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgRecipients(mKey, tmp);
   *recipients = moz_xstrdup(tmp.get());
   return rv;
@@ -495,17 +495,17 @@ NS_IMETHODIMP nsMsgHdr2::GetIsKilled(boo
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
                                            char const* value) {
   nsDependentCString n(name);
   nsDependentCString v(value);
   // storeToken is part of the permanent schema.
   if (n.EqualsLiteral("storeToken")) {
-    printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
+    // printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
     return DB().SetMsgStoreToken(mKey, v);
   }
 
   return DB().MsgSetProperty(mKey, n, v);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const* name, char** value) {
   nsDependentCString n(name);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670904221 -46800
#      Tue Dec 13 17:03:41 2022 +1300
# Node ID e9c1517e39d0d8f7afd16a3a5f5ea4efad75b9e3
# Parent  f7a0fbd909c36d6f729310ea6a7c4e9b5fbd6667
WIP: implement some of the collation functions

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -1,13 +1,15 @@
 #include "GlobalDB.h"
 
+#include "mozIStorageService.h"
+#include "mozilla/intl/Collator.h"
+#include "mozilla/intl/LocaleService.h"
 #include "msgCore.h"
 #include "nsIFile.h"
-#include "mozIStorageService.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 #include "nsMsgEnumerator.h"
 
 // **********************************************************************
 // GlobalDB
@@ -62,16 +64,35 @@ nsresult GlobalDB::Init() {
         NS_SUCCEEDED(statement->GetUTF8String(0, journalMode))) {
       printf("journal_mode: %s\n", journalMode.get());
     }
   }
 
   rv = InitSchema();
   NS_ENSURE_SUCCESS(rv, rv);
 
+  {
+    // I'm a bit rusty on my Rust interfacing...
+    auto result = mozilla::intl::LocaleService::TryCreateComponent<Collator>();
+    if (result.isErr()) {
+      NS_WARNING("Could not create mozilla::intl::Collation.");
+      return NS_ERROR_FAILURE;
+    }
+    mCollator = result.unwrap();
+    // Sort in a case-insensitive way, where "base" letters are considered
+    // equal, e.g: a = á, a = A, a ≠ b.
+    Collator::Options options{};
+    options.sensitivity = Collator::Sensitivity::Base;
+    auto optResult = mCollator->SetOptions(options);
+    if (optResult.isErr()) {
+      NS_WARNING("Could not configure the mozilla::intl::Collation.");
+      mCollator = nullptr;
+      return NS_ERROR_FAILURE;
+    }
+  }
   return NS_OK;
 }
 
 nsresult GlobalDB::InitSchema() {
   const int32_t latestSchemaVersion = 1;
   int32_t currentSchemaVersion;
   nsresult rv = mConn->GetSchemaVersion(&currentSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -390,27 +411,31 @@ nsresult GlobalDB::FetchMsgSender(nsMsgK
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetUTF8String(0, sender);
 }
 
 nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
+  //  printf("XYZZY GlobalDB::FetchMsgSubject(key=%d)\n", key);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT subject FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, subject);
+  rv = stmt->GetUTF8String(0, subject);
+  //  printf("XYZZY      FetchMsgSubject()  ==> '%s'\n",
+  //         nsPromiseFlatCString(subject).get());
+  return rv;
 }
 
 nsresult GlobalDB::FetchMsgRecipients(nsMsgKey key, nsACString& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT recipients FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
@@ -538,16 +563,82 @@ nsresult GlobalDB::FetchMsgStoreToken(ns
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetUTF8String(0, storeToken);
 }
 
+// The Mime2Decoded ones are intended to convert according to charset field in
+// message (potentially with default encoding for news folders). For now
+// just assume everything is utf-8.
+nsresult GlobalDB::FetchMsgMime2DecodedSender(nsMsgKey key, nsAString& author) {
+  nsAutoCString tmp;
+  nsresult rv = FetchMsgSender(key, tmp);
+  author = NS_ConvertUTF8toUTF16(tmp);
+  return rv;
+}
+
+nsresult GlobalDB::FetchMsgMime2DecodedSubject(nsMsgKey key,
+                                               nsAString& subject) {
+  nsAutoCString tmp;
+  nsresult rv = FetchMsgSubject(key, tmp);
+  subject = NS_ConvertUTF8toUTF16(tmp);
+  return rv;
+}
+
+nsresult GlobalDB::FetchMsgMime2DecodedRecipients(nsMsgKey key,
+                                                  nsAString& recipients) {
+  nsAutoCString tmp;
+  nsresult rv = FetchMsgRecipients(key, tmp);
+  recipients = NS_ConvertUTF8toUTF16(tmp);
+  return rv;
+}
+
+nsresult GlobalDB::FetchMsgSenderCollationKey(nsMsgKey key,
+                                              nsTArray<uint8_t>& buf) {
+  nsAutoString tmp;
+  nsresult rv = FetchMsgMime2DecodedSender(key, tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return CreateCollationKey(tmp, buf);
+}
+
+nsresult GlobalDB::FetchMsgSubjectCollationKey(nsMsgKey key,
+                                               nsTArray<uint8_t>& buf) {
+  nsAutoString tmp;
+  nsresult rv = FetchMsgMime2DecodedSubject(key, tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return CreateCollationKey(tmp, buf);
+}
+
+nsresult GlobalDB::FetchMsgRecipientsCollationKey(nsMsgKey key,
+                                                  nsTArray<uint8_t>& buf) {
+  nsAutoString tmp;
+  nsresult rv = FetchMsgMime2DecodedRecipients(key, tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return CreateCollationKey(tmp, buf);
+}
+
+nsresult GlobalDB::CompareCollationKeys(const nsTArray<uint8_t>& key1,
+                                        const nsTArray<uint8_t>& key2,
+                                        int32_t* result) {
+  *result = mCollator->CompareSortKeys(key1, key2);
+  return NS_OK;
+}
+
+nsresult GlobalDB::CreateCollationKey(const nsAString& sourceString,
+                                      nsTArray<uint8_t>& buf) {
+  auto result = mCollator->GetSortKey(sourceString, buf);
+  if (result.isErr()) {
+    return NS_ERROR_FAILURE;
+  }
+  return NS_OK;
+}
+
 nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
   MOZ_ASSERT(flags < INT32_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET flags=:flags WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -701,17 +792,18 @@ nsresult GlobalDB::SetMsgLineCount(nsMsg
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
   //  MOZ_ASSERT(seconds < INT32_MAX);  // This was triggering...
-  printf("XYZZY SetMsgDate(key=%d seconds=0x%" PRIx32 ")\n", (int)key, seconds);
+  //  printf("XYZZY SetMsgDate(key=%d seconds=0x%" PRIx32 ")\n", (int)key,
+  //  seconds);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET date=:seconds WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("seconds"_ns, (int32_t)seconds);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -7,19 +7,21 @@
 #ifndef GlobalDB_h_
 #define GlobalDB_h_
 
 #include "mozilla/storage.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 
-// Using toolkit/components/places/Database.h as rough guide
+typedef uint32_t nsFolderKey;
 
-typedef uint32_t nsFolderKey;
+namespace mozilla::intl {
+class Collator;
+}
 
 struct RawHdr {
   // nsMsgKey id{0};
   nsCString messageID;
   nsCString references;
   uint64_t date{0};
   uint64_t received{0};
   nsCString subject;
@@ -85,16 +87,30 @@ class GlobalDB {
   nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
   nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
   nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID);
   nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
   nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
   nsresult FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken);
 
+  // Hmm. Feels like these shouldn't exist.
+  nsresult FetchMsgMime2DecodedSender(nsMsgKey key, nsAString& author);
+  nsresult FetchMsgMime2DecodedSubject(nsMsgKey key, nsAString& subject);
+  nsresult FetchMsgMime2DecodedRecipients(nsMsgKey key, nsAString& recipients);
+
+  // Collation...
+  nsresult FetchMsgSenderCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
+  nsresult FetchMsgSubjectCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
+  nsresult FetchMsgRecipientsCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
+
+  nsresult CompareCollationKeys(const nsTArray<uint8_t>& key1,
+                                const nsTArray<uint8_t>& key2, int32_t* result);
+  nsresult CreateCollationKey(const nsAString& sourceString,
+                              nsTArray<uint8_t>& buf);
   nsresult SetMsgFlags(nsMsgKey key, uint32_t flags);
   nsresult SetMsgMessageID(nsMsgKey key, nsACString const& messageID);
   nsresult SetMsgReferences(nsMsgKey key, nsACString const& references);
   nsresult SetMsgSender(nsMsgKey key, nsACString const& sender);
   nsresult SetMsgSubject(nsMsgKey key, nsACString const& subject);
   nsresult SetMsgRecipients(nsMsgKey key, nsACString const& recipients);
   nsresult SetMsgCCList(nsMsgKey key, nsACString const& ccList);
   nsresult SetMsgBCCList(nsMsgKey key, nsACString const& bccList);
@@ -186,11 +202,13 @@ class GlobalDB {
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
   mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
+
+  mozilla::UniquePtr<mozilla::intl::Collator> mCollator;
 };
 
 #endif  // GlobalDB_h_
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -781,16 +781,30 @@ nsresult nsMsgDatabase2::ThreadEnumerate
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::SyncCounts() {
   // TODO
   return NS_OK;
 }
 
+/*
+ * NOTE:
+ * It's not quite clear to me how the old Mork setup worked here.
+ * nsMsgHdr objects were created with CreateNewHdr(), and were assigned a key,
+ * which kind of implies they are live rows in the DB.
+ *
+ * But then, later, AddNewHdrDB() would be called to finalise the message.
+ *
+ * Questions:
+ * Does CreateNewHdr() create a row in a separate table?
+ *
+ * For now we'll create the live here in CreateNewHdr() and leave AddNewHdrDB()
+ * as more or less a no-op.
+ */
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
   NS_ENSURE_ARG_POINTER(result);
 
   printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
 
   MOZ_ASSERT(key == nsMsgKey_None);
   // TODO: ++elegance;
   RawHdr blank;
@@ -800,39 +814,41 @@ NS_IMETHODIMP nsMsgDatabase2::CreateNewH
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
-  printf("XYZZY: AddnewHdrToDB() NOT IMPLEMENTED\n");
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  printf("XYZZY: AddnewHdrToDB() - no-op\n");
+  // TODO: implement
+  return NS_OK;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CopyHdrFromExistingHdr(nsMsgKey key,
                                                      nsIMsgDBHdr* existingHdr,
                                                      bool addHdrToDB,
                                                      nsIMsgDBHdr** newHdr) {
   printf("XYZZY: CopyHdrFromExistingHdr(key=%d) NOT IMPLEMENTED\n", (int)key);
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::CompareCollationKeys(const nsTArray<uint8_t>& key1,
                                      const nsTArray<uint8_t>& key2,
                                      int32_t* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().CompareCollationKeys(key1, key2, result);
 }
 
+// Used by nsMsgDBView
 NS_IMETHODIMP
 nsMsgDatabase2::CreateCollationKey(const nsAString& sourceString,
                                    nsTArray<uint8_t>& key) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().CreateCollationKey(sourceString, key);
 }
 
 uint32_t nsMsgDatabase2::GetCurVersion() { return 42; /*kMsgDBVersion;*/ }
 
 NS_IMETHODIMP nsMsgDatabase2::SetSummaryValid(bool valid /* = true */) {
   return NS_OK;  // NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -241,24 +241,31 @@ NS_IMETHODIMP nsMsgHdr2::SetAccountKey(c
 NS_IMETHODIMP nsMsgHdr2::GetAccountKey(char** accountKey) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgAccountKey(mKey, tmp);
   *accountKey = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageOffset(uint64_t* result) {
-  printf("XYZZY: ignore %d: GetMessageOffset()\n", (int)mKey);
-  return NS_ERROR_NOT_IMPLEMENTED;
+  // FUDGE for now. Kill GetMessageOffset() eventually.
+  nsAutoCString tok;
+  nsresult rv = DB().FetchMsgStoreToken(mKey, tok);
+  NS_ENSURE_SUCCESS(rv, rv);
+  int64_t i = tok.ToInteger64(&rv);
+  NS_ENSURE_SUCCESS(rv, rv);
+  MOZ_ASSERT(i >= 0);
+  *result = (uint64_t)i;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetMessageOffset(uint64_t offset) {
-  printf("XYZZY: ignore %d: SetMessageOffset(%" PRIu64 ")\n", (int)mKey,
+  printf("XYZZY: [key=%d] ignore SetMessageOffset(%" PRIu64 ")\n", (int)mKey,
          offset);
-  return NS_ERROR_NOT_IMPLEMENTED;
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageSize(uint32_t* size) {
   uint64_t tmp;
   nsresult rv = DB().FetchMsgSize(mKey, &tmp);
   if (NS_SUCCEEDED(rv)) {
     *size = (uint32_t)tmp;
   }
@@ -309,44 +316,37 @@ NS_IMETHODIMP nsMsgHdr2::GetBccList(char
 NS_IMETHODIMP nsMsgHdr2::GetMessageId(char** messageID) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgMessageID(mKey, tmp);
   *messageID = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedAuthor(nsAString& author) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+  return DB().FetchMsgMime2DecodedSender(mKey, author);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedSubject(nsAString& resultSubject) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedSubject(nsAString& subject) {
+  return DB().FetchMsgMime2DecodedSubject(mKey, subject);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedRecipients(
-    nsAString& resultRecipients) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+NS_IMETHODIMP nsMsgHdr2::GetMime2DecodedRecipients(nsAString& recipients) {
+  return DB().FetchMsgMime2DecodedRecipients(mKey, recipients);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetAuthorCollationKey(
-    nsTArray<uint8_t>& resultAuthor) {
-  resultAuthor.Clear();  // TODO
-  return NS_OK;
+NS_IMETHODIMP nsMsgHdr2::GetAuthorCollationKey(nsTArray<uint8_t>& buf) {
+  return DB().FetchMsgSenderCollationKey(mKey, buf);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetSubjectCollationKey(
-    nsTArray<uint8_t>& resultSubject) {
-  resultSubject.Clear();  // TODO
-  return NS_OK;
+NS_IMETHODIMP nsMsgHdr2::GetSubjectCollationKey(nsTArray<uint8_t>& buf) {
+  return DB().FetchMsgSubjectCollationKey(mKey, buf);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetRecipientsCollationKey(
-    nsTArray<uint8_t>& resultRecipients) {
-  resultRecipients.Clear();  // TODO
-  return NS_OK;
+NS_IMETHODIMP nsMsgHdr2::GetRecipientsCollationKey(nsTArray<uint8_t>& buf) {
+  return DB().FetchMsgRecipientsCollationKey(mKey, buf);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetCharset(char** aCharset) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetCharset(const char* aCharset) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670908860 -46800
#      Tue Dec 13 18:21:00 2022 +1300
# Node ID ef744dd94a0fb30d55aa5610636023f4a6eb5bc5
# Parent  e9c1517e39d0d8f7afd16a3a5f5ea4efad75b9e3
WIP: Add some exceedingly basic field caching for subject, flags and recipients.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -352,30 +352,39 @@ already_AddRefed<mozIStorageStatement> G
 
 already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(const char* query) {
   return Stmt(nsDependentCString(query));
 }
 
 // -------------- data access ---------------
 
 nsresult GlobalDB::FetchMsgFlags(nsMsgKey key, uint32_t* flags) {
+  if (auto p = mFlagsCache.lookup(key)) {
+    *flags = p->value();
+    // printf("XYZZY mFlagsCache hit (key=%d) => 0x%" PRIx32 "\n", (int)key,
+    // *flags);
+    return NS_OK;
+  }
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT flags FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     printf("XYZZY: FetchMsgFlags(key=%d) found nothing\n", (int)key);
   }
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetInt32(0, (int32_t*)flags);
+  rv = stmt->GetInt32(0, (int32_t*)flags);
+  NS_ENSURE_SUCCESS(rv, rv);
+  mFlagsCache.putNew(key, *flags);
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT messageID FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
@@ -397,44 +406,59 @@ nsresult GlobalDB::FetchMsgReferences(ns
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetUTF8String(0, refs);
 }
 
 nsresult GlobalDB::FetchMsgSender(nsMsgKey key, nsACString& sender) {
+  if (auto p = mSenderCache.lookup(key)) {
+    sender = p->value();
+    // printf("XYZZY mSenderCache hit (key=%d) => '%s'\n", (int)key,
+    // nsPromiseFlatCString(sender).get());
+    return NS_OK;
+  }
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT sender FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, sender);
+  rv = stmt->GetUTF8String(0, sender);
+  mSenderCache.putNew(key, sender);
+  return rv;
 }
 
 nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
+  if (auto p = mSubjectCache.lookup(key)) {
+    subject = p->value();
+    // printf("XYZZY mSubjectCache hit (key=%d) => '%s'\n", (int)key,
+    // nsPromiseFlatCString(subject).get());
+    return NS_OK;
+  }
   //  printf("XYZZY GlobalDB::FetchMsgSubject(key=%d)\n", key);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT subject FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   rv = stmt->GetUTF8String(0, subject);
   //  printf("XYZZY      FetchMsgSubject()  ==> '%s'\n",
   //         nsPromiseFlatCString(subject).get());
+  mSubjectCache.putNew(key, subject);
   return rv;
 }
 
 nsresult GlobalDB::FetchMsgRecipients(nsMsgKey key, nsACString& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT recipients FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -641,16 +665,17 @@ nsresult GlobalDB::SetMsgFlags(nsMsgKey 
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+  mFlagsCache.put(key, flags);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET messageID=:messageID WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -684,30 +709,33 @@ nsresult GlobalDB::SetMsgSender(nsMsgKey
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("sender"_ns, sender);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+  mSenderCache.put(key, sender);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET subject=:subject WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("subject"_ns, subject);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  mSubjectCache.put(key, subject);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
                                     nsACString const& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET recipients=:recipients WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -3,16 +3,17 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef GlobalDB_h_
 #define GlobalDB_h_
 
 #include "mozilla/storage.h"
+#include "mozilla/HashTable.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 
 typedef uint32_t nsFolderKey;
 
 namespace mozilla::intl {
 class Collator;
@@ -204,11 +205,16 @@ class GlobalDB {
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
   mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
 
   mozilla::UniquePtr<mozilla::intl::Collator> mCollator;
+
+  // Noddy caching system
+  mozilla::HashMap<nsMsgKey, nsAutoCString> mSubjectCache;
+  mozilla::HashMap<nsMsgKey, nsAutoCString> mSenderCache;
+  mozilla::HashMap<nsMsgKey, uint32_t> mFlagsCache;
 };
 
 #endif  // GlobalDB_h_
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1670963146 -46800
#      Wed Dec 14 09:25:46 2022 +1300
# Node ID 5e85dc7834efc7dd9ecdcafb2140a887b12c6d56
# Parent  ef744dd94a0fb30d55aa5610636023f4a6eb5bc5
WIP: add missing bccList field to schema and rawhdr

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -112,16 +112,17 @@ nsresult GlobalDB::InitSchema() {
         "messageID TEXT NOT NULL DEFAULT '', "
         "refs TEXT NOT NULL DEFAULT '', "        // REFERENCES is reserved word
         "date INTEGER NOT NULL DEFAULT 0, "      // use proper datetime type?
         "received INTEGER NOT NULL DEFAULT 0, "  // ditto
         "subject TEXT NOT NULL DEFAULT '', "
         "sender TEXT NOT NULL DEFAULT '', "  // (NOTE: FROM is reserved word)
         "recipients TEXT NOT NULL DEFAULT '', "
         "ccList TEXT NOT NULL DEFAULT '', "
+        "bccList TEXT NOT NULL DEFAULT '', "
         "replyTo TEXT NOT NULL DEFAULT '', "
         "flags INTEGER NOT NULL DEFAULT 0, "
         "priority INTEGER NOT NULL DEFAULT 0, "
         "msgSize INTEGER NOT NULL DEFAULT 0, "  // SIZE is reserved word
         "storeToken TEXT NOT NULL DEFAULT '', "
         "offlineMsgSize INTEGER NOT NULL DEFAULT 0, "
         "numLines INTEGER NOT NULL DEFAULT 0, "
         "preview TEXT NOT NULL DEFAULT '', "
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -24,16 +24,17 @@ struct RawHdr {
   nsCString messageID;
   nsCString references;
   uint64_t date{0};
   uint64_t received{0};
   nsCString subject;
   nsCString sender;
   nsCString recipients;
   nsCString ccList;
+  nsCString bccList;
   nsCString replyTo;
   uint32_t flags{0};
   int32_t priority{0};
   uint64_t msgSize{0};
   nsCString storeToken;
   uint64_t offlineMsgSize{0};
   uint32_t numLines{0};
   nsCString preview;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1671085294 -46800
#      Thu Dec 15 19:21:34 2022 +1300
# Node ID 30b02b109cb2562eeea4f4c75406f6ba32649c30
# Parent  5e85dc7834efc7dd9ecdcafb2140a887b12c6d56
WIP: create nsMsgDBService2 to handle nsMsgDatabase lookup by folderURI

diff --git a/mailnews/base/src/nsMsgDBView.cpp b/mailnews/base/src/nsMsgDBView.cpp
--- a/mailnews/base/src/nsMsgDBView.cpp
+++ b/mailnews/base/src/nsMsgDBView.cpp
@@ -121,16 +121,17 @@ NS_INTERFACE_MAP_BEGIN(nsMsgDBView)
   NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, nsIMsgDBView)
   NS_INTERFACE_MAP_ENTRY(nsIMsgDBView)
   NS_INTERFACE_MAP_ENTRY(nsIDBChangeListener)
   NS_INTERFACE_MAP_ENTRY(nsITreeView)
   NS_INTERFACE_MAP_ENTRY(nsIJunkMailClassificationListener)
 NS_INTERFACE_MAP_END
 
 nsMsgDBView::nsMsgDBView() {
+  printf("XYZZY [%p] nsMsgDBView ctor\n", this);
   // Member initializers and constructor code.
   m_sortValid = false;
   m_checkedCustomColumns = false;
   m_sortOrder = nsMsgViewSortOrder::none;
   m_sortType = nsMsgViewSortType::byNone;
   m_viewFlags = nsMsgViewFlagsType::kNone;
   m_secondarySort = nsMsgViewSortType::byId;
   m_secondarySortOrder = nsMsgViewSortOrder::ascending;
@@ -180,16 +181,17 @@ void nsMsgDBView::InitializeLiterals() {
   GetString(u"yesterday", kYesterdayString);
   GetString(u"last7Days", kLastWeekString);
   GetString(u"last14Days", kTwoWeeksAgoString);
   GetString(u"older", kOldMailString);
   GetString(u"futureDate", kFutureDateString);
 }
 
 nsMsgDBView::~nsMsgDBView() {
+  printf("XYZZY [%p] nsMsgDBView dtor\n", this);
   if (m_db) m_db->RemoveListener(this);
 }
 
 // Helper function used to fetch strings from the messenger string bundle
 void nsMsgDBView::GetString(const char16_t* aStringName, nsAString& aValue) {
   nsresult res = NS_ERROR_UNEXPECTED;
 
   if (!nsMsgDBView::mMessengerStringBundle) {
@@ -2133,16 +2135,22 @@ nsMsgDBView::CycleCell(int32_t row, nsTr
 NS_IMETHODIMP
 nsMsgDBView::Open(nsIMsgFolder* folder, nsMsgViewSortTypeValue sortType,
                   nsMsgViewSortOrderValue sortOrder,
                   nsMsgViewFlagsTypeValue viewFlags, int32_t* pCount) {
   m_viewFlags = viewFlags;
   m_sortOrder = sortOrder;
   m_sortType = sortType;
 
+  {
+    nsAutoCString uri;
+    folder->GetURI(uri);
+    printf("XYZZY [%p] nsMsgDBView::Open(%s)\n", this, uri.get());
+  }
+
   nsresult rv;
   nsCOMPtr<nsIMsgAccountManager> accountManager =
       do_GetService("@mozilla.org/messenger/account-manager;1", &rv);
 
   NS_ENSURE_SUCCESS(rv, rv);
   bool userNeedsToAuthenticate = false;
   // If we're PasswordProtectLocalCache, then we need to find out if the
   // server is authenticated.
@@ -4895,16 +4903,17 @@ nsresult nsMsgDBView::CollapseByIndex(ns
 
   NoteChange(index + 1, rowDelta, nsMsgViewNotificationCode::insertOrDelete);
 
   return rv;
 }
 
 nsresult nsMsgDBView::OnNewHeader(nsIMsgDBHdr* newHdr, nsMsgKey aParentKey,
                                   bool /*ensureListed*/) {
+  printf("XYZZY nsMsgDBView::OnNewHeader()\n");
   nsresult rv = NS_OK;
   // Views can override this behaviour, which is to append to view.
   // This is the mail behaviour, but threaded views will want
   // to insert in order...
   if (newHdr) rv = AddHdr(newHdr);
 
   return rv;
 }
@@ -5136,16 +5145,19 @@ nsMsgViewIndex nsMsgDBView::GetInsertInd
     return GetIndexForThread(msgHdr);
   }
 
   return GetInsertIndexHelper(msgHdr, m_keys, GetFolders(), m_sortOrder,
                               m_sortType);
 }
 
 nsresult nsMsgDBView::AddHdr(nsIMsgDBHdr* msgHdr, nsMsgViewIndex* resultIndex) {
+  nsMsgKey key;
+  msgHdr->GetMessageKey(&key);
+  printf("XYZZY: nsMsgDBView::AddHdr(key=%d)\n", (int)key);
   uint32_t flags = 0;
 #ifdef DEBUG_bienvenu
   NS_ASSERTION(m_keys.Length() == m_flags.Length() &&
                    (int)m_keys.Length() == m_levels.Length(),
                "view arrays out of sync!");
 #endif
 
   if (resultIndex) *resultIndex = nsMsgViewIndex_None;
@@ -5756,16 +5768,17 @@ nsresult nsMsgDBView::ListUnreadIdsInThr
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDBView::OnHdrFlagsChanged(nsIMsgDBHdr* aHdrChanged, uint32_t aOldFlags,
                                uint32_t aNewFlags,
                                nsIDBChangeListener* aInstigator) {
+  printf("nsMsgDBView::OnHdrFlagsChanged() 0x%x->0x%x\n", aOldFlags, aNewFlags);
   // If we're not the instigator, update flags if this key is in our view.
   if (aInstigator != this) {
     NS_ENSURE_ARG_POINTER(aHdrChanged);
     nsMsgKey msgKey;
     aHdrChanged->GetMessageKey(&msgKey);
     nsMsgViewIndex index = FindHdr(aHdrChanged);
     if (index != nsMsgViewIndex_None) {
       uint32_t viewOnlyFlags =
@@ -5815,26 +5828,29 @@ nsMsgDBView::OnHdrDeleted(nsIMsgDBHdr* a
   }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsMsgDBView::OnHdrAdded(nsIMsgDBHdr* aHdrChanged, nsMsgKey aParentKey,
                         int32_t aFlags, nsIDBChangeListener* aInstigator) {
+  printf("XYZZY nsMsgDBView::OnHdrAdded()\n");
   return OnNewHeader(aHdrChanged, aParentKey, false);
   // Probably also want to pass that parent key in, since we went to the
   // trouble of figuring out what it is.
 }
 
 NS_IMETHODIMP
 nsMsgDBView::OnHdrPropertyChanged(nsIMsgDBHdr* aHdrToChange,
                                   const nsACString& property, bool aPreChange,
                                   uint32_t* aStatus,
                                   nsIDBChangeListener* aInstigator) {
+  printf("nsMsgDBView::OnHdrPropertyChanged(%s)\n",
+         nsPromiseFlatCString(property).get());
   if (aPreChange) return NS_OK;
 
   if (aHdrToChange) {
     nsMsgViewIndex index = FindHdr(aHdrToChange);
     if (index != nsMsgViewIndex_None)
       NoteChange(index, 1, nsMsgViewNotificationCode::changed);
   }
 
diff --git a/mailnews/db/msgdb/public/moz.build b/mailnews/db/msgdb/public/moz.build
--- a/mailnews/db/msgdb/public/moz.build
+++ b/mailnews/db/msgdb/public/moz.build
@@ -14,12 +14,13 @@ XPIDL_SOURCES += [
 
 XPIDL_MODULE = "msgdb"
 
 EXPORTS += [
     "nsDBFolderInfo.h",
     "nsImapMailDatabase.h",
     "nsMailDatabase.h",
     "nsMsgDatabase.h",
+    "nsMsgDBService2.h",
     "nsMsgHdr.h",
     "nsMsgThread.h",
     "nsNewsDatabase.h",
 ]
diff --git a/mailnews/db/msgdb/public/nsMsgDBService2.h b/mailnews/db/msgdb/public/nsMsgDBService2.h
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/public/nsMsgDBService2.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef _nsMsgDBService22_H_
+#define _nsMsgDBService22_H_
+
+#include "nsIMsgDatabase.h"
+#include "nsString.h"
+// #include "nsIDBChangeAnnouncer.h"
+#include "nsIMsgFolder.h"
+#include "nsCOMPtr.h"
+#include "nsCOMArray.h"
+#include "nsTArray.h"
+
+// NOTE: the DB-caching function here should be obsolete. Folders should just
+// own their own nsMsgDatabase2 instance... but we currently get duplicate
+// folders, so it all falls down. The multiple-folders dumpster fire
+// should be sorted out and then folders and nsMsgDatabase objects can have
+// a nice simple 1:1 mapping.
+// But for now, keep track of all the folders we have DBs for, and reuse the
+// DB if the folderURI matches.
+// Eventually, nsMsgDBService might just be a nice place for the global msgdb
+// to live?
+class nsMsgDBService2 final : public nsIMsgDBService {
+ public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSIMSGDBSERVICE
+
+  nsMsgDBService2();
+
+ protected:
+  ~nsMsgDBService2();
+  void HookupPendingListeners(nsIMsgDatabase* db, nsIMsgFolder* folder);
+
+  struct ent {
+    nsCString folderURI;
+    nsCOMPtr<nsIMsgDatabase> db;
+  };
+  nsTArray<ent> mCache;
+
+  nsCOMArray<nsIMsgFolder> m_foldersPendingListeners;
+  nsCOMArray<nsIDBChangeListener> m_pendingListeners;
+};
+
+#endif
diff --git a/mailnews/db/msgdb/src/components.conf b/mailnews/db/msgdb/src/components.conf
--- a/mailnews/db/msgdb/src/components.conf
+++ b/mailnews/db/msgdb/src/components.conf
@@ -31,14 +31,14 @@ Classes = [
         "cid": "{4e3dae5a-157a-11d5-a5c0-0060b0fc04b7}",
         "contract_ids": ["@mozilla.org/msgDatabase/downloadSettings;1"],
         "type": "nsMsgDownloadSettings",
         "headers": ["/comm/mailnews/db/msgdb/public/nsMsgDatabase.h"],
     },
     {
         "cid": "{03223c50-1e88-45e8-ba1a-7ce792dc3fc3}",
         "contract_ids": ["@mozilla.org/msgDatabase/msgDBService;1"],
-        "type": "nsMsgDBService",
-        "headers": ["/comm/mailnews/db/msgdb/public/nsMsgDatabase.h"],
+        "type": "nsMsgDBService2",
+        "headers": ["/comm/mailnews/db/msgdb/public/nsMsgDBService2.h"],
         "name": "DB",
         "interfaces": ["nsIMsgDBService"],
     },
 ]
diff --git a/mailnews/db/msgdb/src/moz.build b/mailnews/db/msgdb/src/moz.build
--- a/mailnews/db/msgdb/src/moz.build
+++ b/mailnews/db/msgdb/src/moz.build
@@ -8,16 +8,17 @@ SOURCES += [
     "MSFSlurp.cpp",
     "nsDBFolderInfo.cpp",
     "nsDBFolderInfo2.cpp",
     "nsImapMailDatabase.cpp",
     "nsMailDatabase.cpp",
     "nsMsgDatabase.cpp",
     "nsMsgDatabase2.cpp",
     "nsMsgDatabaseEnumerators.cpp",
+    "nsMsgDBService2.cpp",
     "nsMsgHdr.cpp",
     "nsMsgHdr2.cpp",
     "nsMsgOfflineImapOperation.cpp",
     "nsMsgThread.cpp",
     "nsMsgThread2.cpp",
     "nsNewsDatabase.cpp",
 ]
 
diff --git a/mailnews/db/msgdb/src/nsMsgDBService2.cpp b/mailnews/db/msgdb/src/nsMsgDBService2.cpp
new file mode 100644
--- /dev/null
+++ b/mailnews/db/msgdb/src/nsMsgDBService2.cpp
@@ -0,0 +1,133 @@
+#include "nsMsgDBService2.h"
+#include "nsMsgDatabase2.h"
+#include "nsIDBChangeListener.h"
+
+NS_IMPL_ISUPPORTS(nsMsgDBService2, nsIMsgDBService)
+
+nsMsgDBService2::nsMsgDBService2() {}
+
+nsMsgDBService2::~nsMsgDBService2() {}
+
+NS_IMETHODIMP nsMsgDBService2::OpenFolderDB(nsIMsgFolder* folder,
+                                            bool /*aLeaveInvalidDB*/,
+                                            nsIMsgDatabase** _retval) {
+  nsAutoCString needle;
+  nsresult rv = folder->GetURI(needle);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCOMPtr<nsIMsgDatabase> db;
+  for (ent& e : mCache) {
+    if (e.folderURI == needle) {
+      db = e.db;
+      break;
+    }
+  }
+
+  if (!db) {
+    db = new nsMsgDatabase2(folder);
+
+    mCache.AppendElement(ent{needle, db});
+  }
+
+  HookupPendingListeners(db, folder);
+  db.forget(_retval);
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDBService2::CreateNewDB(nsIMsgFolder* aFolder,
+                                           nsIMsgDatabase** _retval) {
+  return OpenFolderDB(aFolder, false, _retval);
+}
+
+// Used internally, and by tests. Otherwise, should be private.
+NS_IMETHODIMP nsMsgDBService2::CachedDBForFolder(nsIMsgFolder* aFolder,
+                                                 nsIMsgDatabase** aRetDB) {
+  nsAutoCString needle;
+  nsresult rv = aFolder->GetURI(needle);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  *aRetDB = nullptr;
+  for (ent& e : mCache) {
+    if (e.folderURI == needle) {
+      NS_IF_ADDREF(*aRetDB = e.db);
+      break;
+    }
+  }
+  return NS_OK;
+}
+
+/**
+ * When a db is opened, we need to hook up any pending listeners for
+ * that db, and notify them.
+ */
+void nsMsgDBService2::HookupPendingListeners(nsIMsgDatabase* db,
+                                             nsIMsgFolder* folder) {
+  for (int32_t listenerIndex = 0;
+       listenerIndex < m_foldersPendingListeners.Count(); listenerIndex++) {
+    //  check if we have a pending listener on this db, and if so, add it.
+    if (m_foldersPendingListeners[listenerIndex] == folder) {
+      db->AddListener(m_pendingListeners.ObjectAt(listenerIndex));
+      m_pendingListeners.ObjectAt(listenerIndex)->OnEvent(db, "DBOpened");
+    }
+  }
+}
+
+// This method is called when the caller is trying to create a db without
+// having a corresponding nsIMsgFolder object.  This happens in a few
+// situations, including imap folder discovery, compacting local folders,
+// and copying local folders.
+NS_IMETHODIMP nsMsgDBService2::OpenMailDBFromFile(nsIFile* aFolderName,
+                                                  nsIMsgFolder* aFolder,
+                                                  bool aCreate,
+                                                  bool aLeaveInvalidDB,
+                                                  nsIMsgDatabase** pMessageDB) {
+  MOZ_ASSERT(false, "NOT IMPLEMENTED");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+/* void registerPendingListener (in nsIMsgFolder aFolder, in nsIDBChangeListener
+ * aListener); */
+NS_IMETHODIMP nsMsgDBService2::RegisterPendingListener(
+    nsIMsgFolder* aFolder, nsIDBChangeListener* aListener) {
+  // need to make sure we don't hold onto these forever. Maybe a shutdown
+  // listener? if there is a db open on this folder already, we should register
+  // the listener.
+  m_foldersPendingListeners.AppendObject(aFolder);
+  m_pendingListeners.AppendObject(aListener);
+  nsCOMPtr<nsIMsgDatabase> openDB;
+  CachedDBForFolder(aFolder, getter_AddRefs(openDB));
+  if (openDB) openDB->AddListener(aListener);
+  return NS_OK;
+}
+
+/* void unregisterPendingListener (in nsIDBChangeListener aListener); */
+NS_IMETHODIMP nsMsgDBService2::UnregisterPendingListener(
+    nsIDBChangeListener* aListener) {
+  int32_t listenerIndex = m_pendingListeners.IndexOfObject(aListener);
+  if (listenerIndex != -1) {
+    nsCOMPtr<nsIMsgDatabase> msgDB;
+    CachedDBForFolder(m_foldersPendingListeners[listenerIndex],
+                      getter_AddRefs(msgDB));
+    if (msgDB) msgDB->RemoveListener(aListener);
+    m_foldersPendingListeners.RemoveObjectAt(listenerIndex);
+    m_pendingListeners.RemoveObjectAt(listenerIndex);
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP nsMsgDBService2::ForceFolderDBClosed(nsIMsgFolder* aFolder) {
+  printf("XYZZY nsMsgDBService2::ForceFolderDBClosed() - why bother?");
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDBService2::GetOpenDBs(
+    nsTArray<RefPtr<nsIMsgDatabase>>& aOpenDBs) {
+  printf("XYZZY nsMsgDBService2::GetOpenDBs() - why bother?");
+  aOpenDBs.Clear();
+  aOpenDBs.SetCapacity(mCache.Length());
+  for (ent& e : mCache) {
+    aOpenDBs.AppendElement(e.db);
+  }
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -136,21 +136,16 @@ nsMsgDBService::~nsMsgDBService() {
   }
 #  endif
 #endif
 }
 
 NS_IMETHODIMP nsMsgDBService::OpenFolderDB(nsIMsgFolder* aFolder,
                                            bool aLeaveInvalidDB,
                                            nsIMsgDatabase** _retval) {
-  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
-  db.forget(_retval);
-  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
-  return NS_OK;
-#if 0
   NS_ENSURE_ARG(aFolder);
   nsCOMPtr<nsIMsgIncomingServer> incomingServer;
   nsresult rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> summaryFilePath;
   rv = aFolder->GetSummaryFile(getter_AddRefs(summaryFilePath));
   NS_ENSURE_SUCCESS(rv, rv);
@@ -180,34 +175,33 @@ NS_IMETHODIMP nsMsgDBService::OpenFolder
   nsMsgDatabase* msgDatabase = static_cast<nsMsgDatabase*>(msgDB.get());
   msgDatabase->m_folder = aFolder;
   rv = msgDatabase->Open(this, summaryFilePath, false, aLeaveInvalidDB);
   if (NS_FAILED(rv) && rv != NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE) return rv;
 
   NS_ADDREF(*_retval = msgDB);
 
   if (NS_FAILED(rv)) {
-#  ifdef DEBUG
+#ifdef DEBUG
     // Doing these checks for debug only as we don't want to report certain
     // errors in debug mode, but in release mode we wouldn't report them either
 
     // These errors are expected.
     if (rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING ||
         rv == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE)
       return rv;
 
     // If it isn't one of the expected errors, throw a warning.
     NS_ENSURE_SUCCESS(rv, rv);
-#  endif
+#endif
     return rv;
   }
 
   FinishDBOpen(aFolder, msgDatabase);
   return rv;
-#endif
 }
 
 /**
  * When a db is opened, we need to hook up any pending listeners for
  * that db, and notify them.
  */
 void nsMsgDBService::HookupPendingListeners(nsIMsgDatabase* db,
                                             nsIMsgFolder* folder) {
@@ -260,21 +254,16 @@ nsMsgDatabase* nsMsgDBService::FindInCac
 // having a corresponding nsIMsgFolder object.  This happens in a few
 // situations, including imap folder discovery, compacting local folders,
 // and copying local folders.
 NS_IMETHODIMP nsMsgDBService::OpenMailDBFromFile(nsIFile* aFolderName,
                                                  nsIMsgFolder* aFolder,
                                                  bool aCreate,
                                                  bool aLeaveInvalidDB,
                                                  nsIMsgDatabase** pMessageDB) {
-  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
-  db.forget(pMessageDB);
-  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
-  return NS_OK;
-#if 0
   if (!aFolderName) return NS_ERROR_NULL_POINTER;
 
   nsCOMPtr<nsIFile> dbPath;
   nsresult rv = GetSummaryFileLocation(aFolderName, getter_AddRefs(dbPath));
   NS_ENSURE_SUCCESS(rv, rv);
 
   *pMessageDB = FindInCache(dbPath);
   if (*pMessageDB) return NS_OK;
@@ -282,26 +271,20 @@ NS_IMETHODIMP nsMsgDBService::OpenMailDB
   RefPtr<nsMailDatabase> msgDB = new nsMailDatabase;
   NS_ENSURE_TRUE(msgDB, NS_ERROR_OUT_OF_MEMORY);
   rv = msgDB->Open(this, dbPath, aCreate, aLeaveInvalidDB);
   if (rv == NS_ERROR_FILE_NOT_FOUND) return rv;
   NS_IF_ADDREF(*pMessageDB = msgDB);
   if (aCreate && msgDB && rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) rv = NS_OK;
   if (NS_SUCCEEDED(rv)) msgDB->m_folder = aFolder;
   return rv;
-#endif
 }
 
 NS_IMETHODIMP nsMsgDBService::CreateNewDB(nsIMsgFolder* aFolder,
                                           nsIMsgDatabase** _retval) {
-  RefPtr<nsMsgDatabase2> db = new nsMsgDatabase2(aFolder);
-  db.forget(_retval);
-  // TODO: HookupPendingListeners()? Virtualfolders only, I think...
-  return NS_OK;
-#if 0
   NS_ENSURE_ARG(aFolder);
 
   nsCOMPtr<nsIMsgIncomingServer> incomingServer;
   nsresult rv = aFolder->GetServer(getter_AddRefs(incomingServer));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIFile> summaryFilePath;
   rv = aFolder->GetSummaryFile(getter_AddRefs(summaryFilePath));
@@ -331,17 +314,16 @@ NS_IMETHODIMP nsMsgDBService::CreateNewD
 
   NS_ADDREF(*_retval = msgDB);
 
   HookupPendingListeners(msgDB, aFolder);
 
   msgDatabase->RememberLastUseTime();
 
   return NS_OK;
-#endif
 }
 
 /* void registerPendingListener (in nsIMsgFolder aFolder, in nsIDBChangeListener
  * aListener); */
 NS_IMETHODIMP nsMsgDBService::RegisterPendingListener(
     nsIMsgFolder* aFolder, nsIDBChangeListener* aListener) {
   // need to make sure we don't hold onto these forever. Maybe a shutdown
   // listener? if there is a db open on this folder already, we should register
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -126,17 +126,16 @@ class ThreadEnumerator : public nsBaseMs
     return NS_OK;
   }
 
  protected:
   nsMsgDatabase2* mFolderDB;
   nsTArray<nsMsgKey> mThreadIDs;
   size_t mCur;
 };
-
 NS_IMPL_ISUPPORTS(nsMsgDatabase2, nsIMsgDatabase, nsIMsgOfflineOpsDatabase,
                   nsIDBChangeAnnouncer)
 
 // static
 PRTime nsMsgDatabase2::sLastUseTime;
 
 void nsMsgDatabase2::GetGlobalPrefs() {
   if (!gGotGlobalPrefs) {
@@ -178,22 +177,24 @@ NS_IMETHODIMP nsMsgDatabase2::GetDatabas
 
 // nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
 //   // TODO: Kill this
 //   return NS_ERROR_NOT_IMPLEMENTED;
 // }
 
 NS_IMETHODIMP nsMsgDatabase2::AddListener(nsIDBChangeListener* aListener) {
   NS_ENSURE_ARG_POINTER(aListener);
+  printf("XYZZY [%p] nsMsgDatabase2::AddListener(0x%p)\n", this, aListener);
   m_ChangeListeners.AppendElementUnlessExists(aListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::RemoveListener(nsIDBChangeListener* aListener) {
   NS_ENSURE_ARG_POINTER(aListener);
+  printf("XYZZY [%p] nsMsgDatabase2::RemoveListener(0x%p)\n", this, aListener);
   m_ChangeListeners.RemoveElement(aListener);
   return NS_OK;
 }
 
 // XXX should we return rv for listener->propertyfunc_?
 #define NOTIFY_LISTENERS(propertyfunc_, params_)                         \
   PR_BEGIN_MACRO                                                         \
   nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator iter( \
@@ -246,16 +247,17 @@ NS_IMETHODIMP nsMsgDatabase2::NotifyHdrD
 }
 
 NS_IMETHODIMP nsMsgDatabase2::NotifyHdrAddedAll(
     nsIMsgDBHdr* aHdrAdded, nsMsgKey aParentKey, int32_t aFlags,
     nsIDBChangeListener* aInstigator) {
 #ifdef DEBUG_bienvenu1
   printf("notifying add of %ld parent %ld\n", keyAdded, parentKey);
 #endif
+  printf("XYZZY [%p] nsMsgDatabase2::NotifyHdrAddedAll()\n", this);
   NOTIFY_LISTENERS(OnHdrAdded, (aHdrAdded, aParentKey, aFlags, aInstigator));
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::NotifyParentChangedAll(
     nsMsgKey aKeyReparented, nsMsgKey aOldParent, nsMsgKey aNewParent,
     nsIDBChangeListener* aInstigator) {
   NOTIFY_LISTENERS(OnParentChanged,
@@ -277,20 +279,24 @@ nsMsgDatabase2::nsMsgDatabase2(nsIMsgFol
   nsresult rv = folder->GetURI(uri);
   if (NS_SUCCEEDED(rv)) {
     rv = DB().FolderFindOrCreate(uri, &mFolderID);
   }
   if (NS_FAILED(rv)) {
     mFolderID = 0;
   }
 
+  printf("XYZZY [%p] nsMsgDatabase2::nsMsgDatabase2(uri='%s' folderID='%d')\n",
+         this, uri.get(), (int)mFolderID);
   m_dbFolderInfo = new nsDBFolderInfo2(this);
 }
 
 nsMsgDatabase2::~nsMsgDatabase2() {
+  printf("XYZZY [%p] nsMsgDatabase2::~nsMsgDatabase2(folderID='%d')\n", this,
+         (int)mFolderID);
   m_dbFolderInfo = nullptr;
   m_ChangeListeners.Clear();
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetDBFolderInfo(nsIDBFolderInfo** result) {
   MOZ_ASSERT(m_dbFolderInfo);
   NS_ADDREF(*result = m_dbFolderInfo);
   return NS_OK;
@@ -787,17 +793,17 @@ nsMsgDatabase2::SyncCounts() {
 }
 
 /*
  * NOTE:
  * It's not quite clear to me how the old Mork setup worked here.
  * nsMsgHdr objects were created with CreateNewHdr(), and were assigned a key,
  * which kind of implies they are live rows in the DB.
  *
- * But then, later, AddNewHdrDB() would be called to finalise the message.
+ * But then, later, AddNewHdrDB() would be called to finalise the message?
  *
  * Questions:
  * Does CreateNewHdr() create a row in a separate table?
  *
  * For now we'll create the live here in CreateNewHdr() and leave AddNewHdrDB()
  * as more or less a no-op.
  */
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
@@ -814,18 +820,24 @@ NS_IMETHODIMP nsMsgDatabase2::CreateNewH
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
-  printf("XYZZY: AddnewHdrToDB() - no-op\n");
-  // TODO: implement
+  printf("XYZZY: AddnewHdrToDB(%s)\n", notify ? "notify" : "no notify");
+  if (notify) {
+    uint32_t flags;
+    nsMsgKey threadParent;
+    newHdr->GetFlags(&flags);
+    newHdr->GetThreadParent(&threadParent);
+    NotifyHdrAddedAll(newHdr, threadParent, flags, NULL);
+  }
   return NS_OK;  // TODO
 }
 
 NS_IMETHODIMP nsMsgDatabase2::CopyHdrFromExistingHdr(nsMsgKey key,
                                                      nsIMsgDBHdr* existingHdr,
                                                      bool addHdrToDB,
                                                      nsIMsgDBHdr** newHdr) {
   printf("XYZZY: CopyHdrFromExistingHdr(key=%d) NOT IMPLEMENTED\n", (int)key);
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.cpp b/mailnews/db/msgdb/src/nsMsgThread2.cpp
--- a/mailnews/db/msgdb/src/nsMsgThread2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgThread2.cpp
@@ -4,139 +4,145 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "msgCore.h"
 #include "nsCOMPtr.h"
 #include "nsMsgDatabase2.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 #include "nsMsgMessageFlags.h"
-//#include "nsMsgEnumerator.h"
+// #include "nsMsgEnumerator.h"
 #include "MailNewsTypes2.h"
-//#include "mozilla/DebugOnly.h"
+// #include "mozilla/DebugOnly.h"
 #include "GlobalDB.h"
 
 NS_IMPL_ISUPPORTS(nsMsgThread2, nsIMsgThread)
 
-nsMsgThread2::nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID) : mFolderDB(folderDB), mThreadID(threadID) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::nsMsgThread2()\n", mThreadID);
+nsMsgThread2::nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID)
+    : mFolderDB(folderDB), mThreadID(threadID) {
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::nsMsgThread2()\n", mThreadID);
 }
 
 nsMsgThread2::~nsMsgThread2() {
-  printf("XYZZY [threadID=%d] nsMsgThread2::~nsMsgThread2()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::~nsMsgThread2()\n", mThreadID);
 }
 
 NS_IMETHODIMP nsMsgThread2::SetThreadKey(nsMsgKey threadKey) {
   MOZ_ASSERT(false, "NOPE!");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetThreadKey(nsMsgKey* result) {
   *result = mThreadID;
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetThreadKey()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetThreadKey()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetFlags(uint32_t* result) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetFlags()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetFlags()\n", mThreadID);
   *result = nsMsgMessageFlags::Watched;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::SetFlags(uint32_t flags) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::SetFlags()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::SetFlags()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::SetSubject(const nsACString& subject) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::SetSubject()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::SetSubject()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetSubject(nsACString& subject) {
-  printf("XYZZY nsMsgThread2::GetSubject())\n");
+  //  printf("XYZZY nsMsgThread2::GetSubject())\n");
   return mFolderDB->DB().FetchMsgSubject(mThreadID, subject);
 }
 
 NS_IMETHODIMP nsMsgThread2::GetNumChildren(uint32_t* result) {
   *result = 1;
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetNumChildren()\n", mThreadID);
+  // printf("XYZZY [threadID=%d] nsMsgThread2::GetNumChildren()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetNumUnreadChildren(uint32_t* result) {
   *result = 0;
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetNumUnreadChildren()\n", mThreadID);
+  // printf("XYZZY [threadID=%d] nsMsgThread2::GetNumUnreadChildren()\n",
+  // mThreadID);
   return NS_OK;
 }
 
-
 NS_IMETHODIMP nsMsgThread2::AddChild(nsIMsgDBHdr* child, nsIMsgDBHdr* inReplyTo,
-                                    bool threadInThread,
-                                    nsIDBChangeAnnouncer* announcer) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::AddChild()\n", mThreadID);
+                                     bool threadInThread,
+                                     nsIDBChangeAnnouncer* announcer) {
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::AddChild()\n", mThreadID);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetChildKeyAt(uint32_t aIndex, nsMsgKey* aResult) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildKeyAt(idx=%d)\n", mThreadID, aIndex);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildKeyAt(idx=%d)\n",
+  //  mThreadID, aIndex);
   *aResult = mThreadID;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetChildHdrAt(uint32_t aIndex,
-                                         nsIMsgDBHdr** result) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildHdrAt(idx=%d)\n", mThreadID, aIndex);
+                                          nsIMsgDBHdr** result) {
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildHdrAt(idx=%d)\n",
+  //  mThreadID, aIndex);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetChild(nsMsgKey msgKey, nsIMsgDBHdr** result) {
-
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetChild(msgKey=%d)\n", mThreadID, msgKey);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChild(msgKey=%d)\n",
+  //  mThreadID, msgKey);
   return GetRootHdr(result);
-//  return NS_ERROR_NOT_IMPLEMENTED;
+  //  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::RemoveChildAt(uint32_t aIndex) { return NS_OK; }
 
 NS_IMETHODIMP nsMsgThread2::RemoveChildHdr(nsIMsgDBHdr* child,
-                                          nsIDBChangeAnnouncer* announcer) {
+                                           nsIDBChangeAnnouncer* announcer) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::MarkChildRead(bool bRead) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::MarkChildRead()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::MarkChildRead()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::EnumerateMessages(nsMsgKey parentKey,
-                                             nsIMsgEnumerator** result) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages()\n", mThreadID);
+                                              nsIMsgEnumerator** result) {
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages()\n",
+  //  mThreadID);
   return mFolderDB->ThreadEnumerateMessages(parentKey, result);
-//  NS_ADDREF(*result = new MsgEnumerator
-//                new nsMsgThread2Enumerator(this, parentKey, nullptr, nullptr));
+  //  NS_ADDREF(*result = new MsgEnumerator
+  //                new nsMsgThread2Enumerator(this, parentKey, nullptr,
+  //                nullptr));
 }
 
-
 NS_IMETHODIMP nsMsgThread2::GetRootHdr(nsIMsgDBHdr** result) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetRootHdr()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetRootHdr()\n", mThreadID);
   nsCOMPtr<nsIMsgDBHdr> foo = new nsMsgHdr2(mFolderDB, mThreadID);
   foo.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetFirstUnreadChild(nsIMsgDBHdr** result) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetFirstUnreadChild()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetFirstUnreadChild()\n",
+  //  mThreadID);
   return GetRootHdr(result);
-  //return NS_ERROR_NOT_IMPLEMENTED;
+  // return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetNewestMsgDate(uint32_t* seconds) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::GetNewestMsgDate()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetNewestMsgDate()\n",
+  //  mThreadID);
 
   return mFolderDB->DB().FetchMsgDate(mThreadID, seconds);
 }
 
 NS_IMETHODIMP nsMsgThread2::SetNewestMsgDate(uint32_t aNewestMsgDate) {
-  printf("XYZZY [threadID=%d] nsMsgThread2::SetNewestMsgDate()\n", mThreadID);
+  //  printf("XYZZY [threadID=%d] nsMsgThread2::SetNewestMsgDate()\n",
+  //  mThreadID);
   return NS_OK;
 }
-
diff --git a/mailnews/local/src/nsLocalMailFolder.cpp b/mailnews/local/src/nsLocalMailFolder.cpp
--- a/mailnews/local/src/nsLocalMailFolder.cpp
+++ b/mailnews/local/src/nsLocalMailFolder.cpp
@@ -139,16 +139,17 @@ NS_IMETHODIMP nsMsgLocalMailFolder::GetM
   }
 
   return nsMsgDBFolder::GetManyHeadersToDownload(retval);
 }
 
 // run the url to parse the mailbox
 NS_IMETHODIMP nsMsgLocalMailFolder::ParseFolder(nsIMsgWindow* aMsgWindow,
                                                 nsIUrlListener* aListener) {
+  printf("XYZZY: nsMsgLocalMailFolder::ParseFolder() - UHOH!\n");
   nsCOMPtr<nsIMsgPluggableStore> msgStore;
   nsresult rv = GetMsgStore(getter_AddRefs(msgStore));
   NS_ENSURE_SUCCESS(rv, rv);
   if (aListener != this) mReparseListener = aListener;
   // if parsing is synchronous, we need to set m_parsingFolder to
   // true before starting. And we need to open the db before
   // setting m_parsingFolder to true.
   //  OpenDatabase();
@@ -315,19 +316,16 @@ NS_IMETHODIMP nsMsgLocalMailFolder::GetD
       }
     } else if (folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) {
       rv = msgDBService->CreateNewDB(this, getter_AddRefs(mDatabase));
     }
 
     if (mDatabase) {
       if (mAddListener) mDatabase->AddListener(this);
 
-      // XYZZY - force a reparse!
-      folderOpen = NS_MSG_ERROR_FOLDER_SUMMARY_MISSING;
-
       // if we have to regenerate the folder, run the parser url.
       if (folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING ||
           folderOpen == NS_MSG_ERROR_FOLDER_SUMMARY_OUT_OF_DATE) {
         if (NS_FAILED(rv = ParseFolder(aMsgWindow, aReparseUrlListener))) {
           if (rv == NS_MSG_FOLDER_BUSY) {
             // we need to null out the db so that parsing gets kicked off again.
             mDatabase->RemoveListener(this);
             mDatabase = nullptr;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1671421814 -46800
#      Mon Dec 19 16:50:14 2022 +1300
# Node ID 12f156a35ffb4ca55610c14d28f95f9ea501a85a
# Parent  30b02b109cb2562eeea4f4c75406f6ba32649c30
WIP: First stab at message threading

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -5,16 +5,17 @@
 #include "mozilla/intl/LocaleService.h"
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 #include "nsMsgEnumerator.h"
+#include "nsWhitespaceTokenizer.h"
 
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
 GlobalDB::~GlobalDB() {
@@ -177,16 +178,27 @@ nsresult GlobalDB::InitSchema() {
         "folder_id INTEGER NOT NULL, "
         "name TEXT NOT NULL, "
         "value TEXT NOT NULL, "
         "UNIQUE (folder_id, name)"
         ")");
     rv = mConn->ExecuteSimpleSQL(create_folder_prop);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    // Message thread structure.
+    const nsLiteralCString create_msg_thread(
+        "CREATE TABLE msg_thread ( "
+        "msg INTEGER NOT NULL, "
+        "parent INTEGER, "           // null = root
+        "thread INTEGER NOT NULL, "  // root msgkey
+        "depth INTEGER NOT NULL "    // 0=root (implies threadID==msg)
+        ")");
+    rv = mConn->ExecuteSimpleSQL(create_msg_thread);
+    NS_ENSURE_SUCCESS(rv, rv);
+
   } else {
     // Migrations go here...
   }
 
   rv = mConn->SetSchemaVersion(latestSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
@@ -374,17 +386,17 @@ nsresult GlobalDB::FetchMsgFlags(nsMsgKe
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     printf("XYZZY: FetchMsgFlags(key=%d) found nothing\n", (int)key);
   }
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   rv = stmt->GetInt32(0, (int32_t*)flags);
   NS_ENSURE_SUCCESS(rv, rv);
-  mFlagsCache.putNew(key, *flags);
+  NS_ENSURE_TRUE(mFlagsCache.putNew(key, *flags), NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT messageID FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -424,17 +436,17 @@ nsresult GlobalDB::FetchMsgSender(nsMsgK
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   rv = stmt->GetUTF8String(0, sender);
-  mSenderCache.putNew(key, sender);
+  NS_ENSURE_TRUE(mSenderCache.putNew(key, sender), NS_ERROR_OUT_OF_MEMORY);
   return rv;
 }
 
 nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
   if (auto p = mSubjectCache.lookup(key)) {
     subject = p->value();
     // printf("XYZZY mSubjectCache hit (key=%d) => '%s'\n", (int)key,
     // nsPromiseFlatCString(subject).get());
@@ -449,17 +461,17 @@ nsresult GlobalDB::FetchMsgSubject(nsMsg
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   rv = stmt->GetUTF8String(0, subject);
   //  printf("XYZZY      FetchMsgSubject()  ==> '%s'\n",
   //         nsPromiseFlatCString(subject).get());
-  mSubjectCache.putNew(key, subject);
+  NS_ENSURE_TRUE(mSubjectCache.putNew(key, subject), NS_ERROR_OUT_OF_MEMORY);
   return rv;
 }
 
 nsresult GlobalDB::FetchMsgRecipients(nsMsgKey key, nsACString& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT recipients FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -551,18 +563,62 @@ nsresult GlobalDB::FetchMsgDate(nsMsgKey
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetInt32(0, (int32_t*)seconds);
 }
 
-nsresult GlobalDB::FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+// Return the thread this message belongs to.
+nsresult GlobalDB::FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadKey) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT thread FROM msg_thread WHERE msg=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+  int64_t tmp;
+  rv = stmt->GetInt64(0, &tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *threadKey = (nsMsgKey)tmp;
+  return NS_OK;
+}
+
+// Return the parent of this message (or nsMsgKey_None if root).
+nsresult GlobalDB::FetchMsgThreadParent(nsMsgKey key, nsMsgKey* parentKey) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT parent FROM msg_thread WHERE msg=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
+
+  bool isNull;
+  rv = stmt->GetIsNull(0, &isNull);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (isNull) {
+    // We've hit the root. No parent.
+    *parentKey = nsMsgKey_None;
+    return NS_OK;
+  }
+
+  int64_t tmp;
+  rv = stmt->GetInt64(0, &tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *parentKey = (nsMsgKey)tmp;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgPriority(nsMsgKey key,
                                     nsMsgPriorityValue* priority) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT priority FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -666,17 +722,17 @@ nsresult GlobalDB::SetMsgFlags(nsMsgKey 
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
-  mFlagsCache.put(key, flags);
+  NS_ENSURE_TRUE(mFlagsCache.put(key, flags), NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET messageID=:messageID WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
@@ -710,33 +766,33 @@ nsresult GlobalDB::SetMsgSender(nsMsgKey
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("sender"_ns, sender);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
-  mSenderCache.put(key, sender);
+  NS_ENSURE_TRUE(mSenderCache.put(key, sender), NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET subject=:subject WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("subject"_ns, subject);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
 
-  mSubjectCache.put(key, subject);
+  NS_ENSURE_TRUE(mSubjectCache.put(key, subject), NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
                                     nsACString const& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET recipients=:recipients WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
@@ -1205,8 +1261,210 @@ nsresult GlobalDB::MsgGetProperty(nsMsgK
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     return NS_OK;
   }
   return stmt->GetUTF8String(0, value);
 }
+
+// Returns nsMsgKey_None if none found.
+nsresult GlobalDB::FindMsgByMessageID(nsACString const& messageID,
+                                      nsMsgKey* msgKey) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT rowid FROM msg WHERE messageID=:messageID");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (!exists) {
+    *msgKey = nsMsgKey_None;
+    return NS_OK;
+  }
+  int64_t tmp;
+  rv = stmt->GetInt64(0, &tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *msgKey = (nsMsgKey)tmp;
+  return NS_OK;
+}
+
+static nsTArray<nsCString> SplitReferences(nsACString const& in) {
+  nsTArray<nsCString> out;
+
+  // HACKHACKHACK!!!
+  // Should parse according to rfc5322 section 3.6.4.
+  nsCWhitespaceTokenizer tokenizer(in);
+  while (tokenizer.hasMoreTokens()) {
+    nsDependentCSubstring const& ref = tokenizer.nextToken();
+    if (ref.IsEmpty()) {
+      continue;
+    }
+    if (ref.CharAt(0) == '<' && ref.CharAt(ref.Length() - 1) == '>') {
+      out.AppendElement(Substring(ref, 1, ref.Length() - 2));
+    } else {
+      out.AppendElement(ref);
+    }
+  }
+
+  return out;
+}
+
+// Insert msg into the threading system.
+nsresult GlobalDB::ThreadNewMsg(nsMsgKey msgKey, nsMsgKey* threadID) {
+  nsAutoCString unParsedReferences;
+  nsresult rv = FetchMsgReferences(msgKey, unParsedReferences);
+  NS_ENSURE_SUCCESS(rv, rv);
+  auto refs = SplitReferences(unParsedReferences);
+
+  // Resolve all the refs. If any are missing, treat them as if they
+  // just don't exist.
+  nsTArray<nsMsgKey> refKeys(refs.Length());
+  for (auto const& ref : refs) {
+    nsMsgKey k;
+    rv = FindMsgByMessageID(ref, &k);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (k == nsMsgKey_None) {
+      printf("XYZZY: UHOH - messageID '%s' not found (referenced by %d\n)\n",
+             ref.get(), msgKey);
+      continue;
+    }
+    refKeys.AppendElement(k);
+  }
+
+  int32_t depth = (int32_t)refKeys.Length();  // 0 = root;
+  nsMsgKey parentKey;
+  if (depth == 0) {
+    // It's root.
+    *threadID = msgKey;
+    parentKey = nsMsgKey_None;
+  } else {
+    *threadID = refKeys[0];
+    parentKey = refKeys.LastElement();
+  }
+
+  {
+    nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+        "INSERT INTO msg_thread (msg, parent, thread, depth) VALUES (:msg, "
+        ":parent, :thread, :depth)");
+    NS_ENSURE_STATE(stmt);
+    mozStorageStatementScoper scoper(stmt);
+    rv = stmt->BindInt64ByName("msg"_ns, (int64_t)msgKey);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (parentKey == nsMsgKey_None) {
+      rv = stmt->BindNullByName("parent"_ns);
+    } else {
+      rv = stmt->BindInt64ByName("parent"_ns, (int64_t)parentKey);
+    }
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt64ByName("thread"_ns, (int64_t)*threadID);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->BindInt32ByName("depth"_ns, depth);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = stmt->Execute();
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    printf(
+        "XYZZY: GlobalDB::ThreadNewMsg() -> msg=%d parent=%d thread=%d "
+        "depth=%d\n",
+        (int)msgKey, (int)parentKey, (int)*threadID, (int)depth);
+  }
+  return NS_OK;
+}
+
+// Count the total number of messages belonging to this thread.
+nsresult GlobalDB::ThreadMemberCount(nsMsgKey threadKey, uint32_t* total) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT count(*) FROM msg_thread WHERE thread=:threadKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("threadKey"_ns, (int64_t)threadKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  bool exists;
+  rv = stmt->ExecuteStep(&exists);
+  NS_ENSURE_SUCCESS(rv, rv);
+  NS_ENSURE_TRUE(exists,
+                 NS_MSG_MESSAGE_NOT_FOUND);  // really thread not found...
+
+  int64_t tmp;
+  rv = stmt->GetInt64(0, &tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *total = (uint32_t)tmp;
+  return NS_OK;
+}
+
+// Get child messages ordered by date.
+nsresult GlobalDB::ThreadChildren(nsMsgKey parentKey,
+                                  nsTArray<nsMsgKey>& children) {
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
+      "WHERE t.parent=:parentKey ORDER BY m.date ASC");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("parentKey"_ns, (int64_t)parentKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  children.Clear();
+  while (1) {
+    bool exists;
+    rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    int64_t tmp;
+    rv = stmt->GetInt64(0, &tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    children.AppendElement((nsMsgKey)tmp);
+  }
+  return NS_OK;
+}
+
+// Get all messages belonging to thread, ordered by date.
+nsresult GlobalDB::ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs) {
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
+      "WHERE t.thread=:threadKey ORDER BY m.date ASC");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("threadKey"_ns, (int64_t)threadKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  msgs.Clear();
+  while (1) {
+    bool exists;
+    rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    int64_t tmp;
+    rv = stmt->GetInt64(0, &tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    msgs.AppendElement((nsMsgKey)tmp);
+  }
+  return NS_OK;
+}
+
+// Get a list of all threads.
+nsresult GlobalDB::AllThreads(nsTArray<nsMsgKey>& threadKeys) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT distinct thread FROM msg_thread");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  threadKeys.Clear();
+  while (1) {
+    bool exists;
+    nsresult rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    int64_t tmp;
+    rv = stmt->GetInt64(0, &tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    threadKeys.AppendElement((nsMsgKey)tmp);
+  }
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -84,21 +84,23 @@ class GlobalDB {
   nsresult FetchMsgSubject(nsMsgKey key, nsACString& subject);
   nsresult FetchMsgRecipients(nsMsgKey key, nsACString& recipients);
   nsresult FetchMsgCCList(nsMsgKey key, nsACString& ccList);
   nsresult FetchMsgBCCList(nsMsgKey key, nsACString& bccList);
   nsresult FetchMsgSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
   nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
-  nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadID);
   nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
   nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
   nsresult FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken);
 
+  nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadKey);
+  nsresult FetchMsgThreadParent(nsMsgKey key, nsMsgKey* parentKey);
+
   // Hmm. Feels like these shouldn't exist.
   nsresult FetchMsgMime2DecodedSender(nsMsgKey key, nsAString& author);
   nsresult FetchMsgMime2DecodedSubject(nsMsgKey key, nsAString& subject);
   nsresult FetchMsgMime2DecodedRecipients(nsMsgKey key, nsAString& recipients);
 
   // Collation...
   nsresult FetchMsgSenderCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
   nsresult FetchMsgSubjectCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
@@ -193,16 +195,32 @@ class GlobalDB {
 
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   // Thread stuff.
 #if 0
   nsresult ThreadEnumerateMessages(nsMsgKey parentKey,
                                    nsIMsgEnumerator** enumerator);
 #endif
+  // Return key of message with matching messageID.
+  // Returns nsMsgKey_None if not found.
+  nsresult FindMsgByMessageID(nsACString const& messageID, nsMsgKey* msgKey);
+
+  // Return all direct children of parentKey.
+  nsresult ThreadChildren(nsMsgKey parentKey, nsTArray<nsMsgKey>& children);
+  // Return all messages belonging to thread.
+  nsresult ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs);
+  // Number of messages belonging to thread.
+  nsresult ThreadMemberCount(nsMsgKey threadKey, uint32_t* total);
+
+  // Inserts a message into the threading system.
+  nsresult ThreadNewMsg(nsMsgKey msgKey, nsMsgKey* threadID);
+
+  // List all the threads in the DB.
+  nsresult AllThreads(nsTArray<nsMsgKey>& threadKeys);
 
  private:
   nsresult InitSchema();
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
diff --git a/mailnews/db/msgdb/src/nsMsgDBService2.cpp b/mailnews/db/msgdb/src/nsMsgDBService2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDBService2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDBService2.cpp
@@ -112,22 +112,22 @@ NS_IMETHODIMP nsMsgDBService2::Unregiste
     m_foldersPendingListeners.RemoveObjectAt(listenerIndex);
     m_pendingListeners.RemoveObjectAt(listenerIndex);
     return NS_OK;
   }
   return NS_ERROR_FAILURE;
 }
 
 NS_IMETHODIMP nsMsgDBService2::ForceFolderDBClosed(nsIMsgFolder* aFolder) {
-  printf("XYZZY nsMsgDBService2::ForceFolderDBClosed() - why bother?");
+  printf("XYZZY nsMsgDBService2::ForceFolderDBClosed() - why bother?\n");
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDBService2::GetOpenDBs(
     nsTArray<RefPtr<nsIMsgDatabase>>& aOpenDBs) {
-  printf("XYZZY nsMsgDBService2::GetOpenDBs() - why bother?");
+  printf("XYZZY nsMsgDBService2::GetOpenDBs() - why bother?\n");
   aOpenDBs.Clear();
   aOpenDBs.SetCapacity(mCache.Length());
   for (ent& e : mCache) {
     aOpenDBs.AppendElement(e.db);
   }
   return NS_OK;
 }
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -177,24 +177,25 @@ NS_IMETHODIMP nsMsgDatabase2::GetDatabas
 
 // nsresult nsMsgDatabase2::CreateMsgHdr(nsMsgKey key, nsIMsgDBHdr** result) {
 //   // TODO: Kill this
 //   return NS_ERROR_NOT_IMPLEMENTED;
 // }
 
 NS_IMETHODIMP nsMsgDatabase2::AddListener(nsIDBChangeListener* aListener) {
   NS_ENSURE_ARG_POINTER(aListener);
-  printf("XYZZY [%p] nsMsgDatabase2::AddListener(0x%p)\n", this, aListener);
+  // printf("XYZZY [%p] nsMsgDatabase2::AddListener(0x%p)\n", this, aListener);
   m_ChangeListeners.AppendElementUnlessExists(aListener);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::RemoveListener(nsIDBChangeListener* aListener) {
   NS_ENSURE_ARG_POINTER(aListener);
-  printf("XYZZY [%p] nsMsgDatabase2::RemoveListener(0x%p)\n", this, aListener);
+  // printf("XYZZY [%p] nsMsgDatabase2::RemoveListener(0x%p)\n", this,
+  // aListener);
   m_ChangeListeners.RemoveElement(aListener);
   return NS_OK;
 }
 
 // XXX should we return rv for listener->propertyfunc_?
 #define NOTIFY_LISTENERS(propertyfunc_, params_)                         \
   PR_BEGIN_MACRO                                                         \
   nsTObserverArray<nsCOMPtr<nsIDBChangeListener>>::ForwardIterator iter( \
@@ -247,17 +248,17 @@ NS_IMETHODIMP nsMsgDatabase2::NotifyHdrD
 }
 
 NS_IMETHODIMP nsMsgDatabase2::NotifyHdrAddedAll(
     nsIMsgDBHdr* aHdrAdded, nsMsgKey aParentKey, int32_t aFlags,
     nsIDBChangeListener* aInstigator) {
 #ifdef DEBUG_bienvenu1
   printf("notifying add of %ld parent %ld\n", keyAdded, parentKey);
 #endif
-  printf("XYZZY [%p] nsMsgDatabase2::NotifyHdrAddedAll()\n", this);
+  // printf("XYZZY [%p] nsMsgDatabase2::NotifyHdrAddedAll()\n", this);
   NOTIFY_LISTENERS(OnHdrAdded, (aHdrAdded, aParentKey, aFlags, aInstigator));
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::NotifyParentChangedAll(
     nsMsgKey aKeyReparented, nsMsgKey aOldParent, nsMsgKey aNewParent,
     nsIDBChangeListener* aInstigator) {
   NOTIFY_LISTENERS(OnParentChanged,
@@ -765,17 +766,19 @@ nsresult nsMsgDatabase2::EnumerateMessag
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
   return DB().FolderListAllKeys(mFolderID, keys);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
   // TODO
   nsTArray<nsMsgKey> threadIDs;
-  nsresult rv = DB().FolderListAllKeys(mFolderID, threadIDs);
+
+  // TODO: limit to folder!
+  nsresult rv = DB().AllThreads(threadIDs);
   NS_ENSURE_SUCCESS(rv, rv);
   RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
   e.forget(result);
   return NS_OK;
 }
 
 // Helper fn for nsMsgThread2
 // TODO: is parentKey root message of thread? Or any message?
@@ -789,48 +792,51 @@ nsresult nsMsgDatabase2::ThreadEnumerate
 NS_IMETHODIMP
 nsMsgDatabase2::SyncCounts() {
   // TODO
   return NS_OK;
 }
 
 /*
  * NOTE:
- * It's not quite clear to me how the old Mork setup worked here.
- * nsMsgHdr objects were created with CreateNewHdr(), and were assigned a key,
- * which kind of implies they are live rows in the DB.
- *
- * But then, later, AddNewHdrDB() would be called to finalise the message?
+ * The old Mork implementation was a little murky here.
+ * Looks like CreateNewHdr() created a detached row if key was
+ * nsMsgKey_None.
  *
- * Questions:
- * Does CreateNewHdr() create a row in a separate table?
+ * Later, AddNewHdrDB() add the detached row to the main mgs table
+ * to finalise the message...
  *
- * For now we'll create the live here in CreateNewHdr() and leave AddNewHdrDB()
- * as more or less a no-op.
+ * For now we'll create it live in the DB immediately.
+ * TODO: this needs some proper sorting out.
  */
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
   NS_ENSURE_ARG_POINTER(result);
 
-  printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
+  // printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
 
   MOZ_ASSERT(key == nsMsgKey_None);
   // TODO: ++elegance;
   RawHdr blank;
   nsresult rv = DB().StashMsg(blank, &key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = DB().AddMsgToFolder(key, mFolderID);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
   printf("XYZZY: AddnewHdrToDB(%s)\n", notify ? "notify" : "no notify");
+  // Sort out threading.
+  nsMsgKey threadID;
+  nsMsgKey key;
+  newHdr->GetMessageKey(&key);
+  DB().ThreadNewMsg(key, &threadID);
   if (notify) {
     uint32_t flags;
     nsMsgKey threadParent;
     newHdr->GetFlags(&flags);
     newHdr->GetThreadParent(&threadParent);
     NotifyHdrAddedAll(newHdr, threadParent, flags, NULL);
   }
   return NS_OK;  // TODO
@@ -918,29 +924,31 @@ NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrF
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForGMMsgID(const char* aGMMsgId,
                                                   nsIMsgDBHdr** aHdr) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::GetThreadContainingMsgHdr(nsIMsgDBHdr* msgHdr,
-                                                        nsIMsgThread** result) {
-  return NS_ERROR_NOT_IMPLEMENTED;
+                                                        nsIMsgThread** thread) {
+  nsMsgKey msgKey;
+  nsresult rv = msgHdr->GetMessageKey(&msgKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return GetThreadForMsgKey(msgKey, thread);
 }
 
 nsresult nsMsgDatabase2::GetThreadForMsgKey(nsMsgKey msgKey,
-                                            nsIMsgThread** aResult) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-// caller needs to unrefer.
-nsIMsgThread* nsMsgDatabase2::GetThreadForThreadId(nsMsgKey threadId) {
-  MOZ_ASSERT(false);
-  return nullptr;
+                                            nsIMsgThread** thread) {
+  nsMsgKey threadID;
+  nsresult rv = DB().FetchMsgThreadID(msgKey, &threadID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  RefPtr<nsMsgThread2> t = new nsMsgThread2(this, threadID);
+  t.forget(thread);
+  return NS_OK;
 }
 
 nsresult nsMsgDatabase2::GetBoolPref(const char* prefName, bool* result) {
   bool prefValue = false;
   nsresult rv;
   nsCOMPtr<nsIPrefBranch> pPrefBranch(
       do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
   if (pPrefBranch) {
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.h b/mailnews/db/msgdb/src/nsMsgDatabase2.h
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.h
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.h
@@ -69,17 +69,16 @@ class nsMsgDatabase2 : public nsIMsgOffl
   // prefs stuff - in future, we might want to cache the prefs interface
   nsresult GetBoolPref(const char* prefName, bool* result);
   nsresult GetIntPref(const char* prefName, int32_t* result);
   virtual void GetGlobalPrefs();
   // retrieval methods
   nsIMsgThread* GetThreadForReference(nsCString& msgID, nsIMsgDBHdr** pMsgHdr);
   nsIMsgThread* GetThreadForSubject(nsCString& subject);
   nsIMsgThread* GetThreadForMessageId(nsCString& msgId);
-  nsIMsgThread* GetThreadForThreadId(nsMsgKey threadId);
   nsMsgHdr2* GetMsgHdrForReference(nsCString& reference);
   // threading interfaces
   virtual nsresult CreateNewThread(nsMsgKey key, const char* subject,
                                    nsMsgThread** newThread);
   virtual bool ThreadBySubjectWithoutRe();
   virtual bool UseStrictThreading();
   virtual bool UseCorrectThreading();
 
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -32,17 +32,20 @@ NS_IMETHODIMP nsMsgHdr2::GetMessageKey(n
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetThreadId(nsMsgKey* result) {
   return DB().FetchMsgThreadID(mKey, result);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetThreadId(nsMsgKey threadID) {
-  return DB().SetMsgThreadID(mKey, threadID);
+  printf("XYZZY: nsMsgHdr2::SetThreadId(%d) - NOT IMPLEMENTED\n",
+         (int)threadID);
+  // return DB().SetMsgThreadID(mKey, threadID);
+  return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 // TODO: should be read-only?
 NS_IMETHODIMP nsMsgHdr2::SetMessageKey(nsMsgKey value) {
   printf("XYZZY: NOT IMPLEMENTED nsMsgHdr2::SetMessageKey()\n");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
@@ -352,21 +355,23 @@ NS_IMETHODIMP nsMsgHdr2::SetCharset(cons
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetEffectiveCharset(nsACString& resultCharset) {
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetThreadParent(nsMsgKey inKey) {
+  printf("XYZZY: nsMsgHdr2::SetThreadParent(%d) - NOT IMPLEMENTED\n",
+         (int)inKey);
   return NS_ERROR_NOT_IMPLEMENTED;  // TODO
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetThreadParent(nsMsgKey* result) {
-  return NS_ERROR_NOT_IMPLEMENTED;  // TODO
+NS_IMETHODIMP nsMsgHdr2::GetThreadParent(nsMsgKey* parentKey) {
+  return DB().FetchMsgThreadParent(mKey, parentKey);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetFolder(nsIMsgFolder** folder) {
   NS_IF_ADDREF(*folder = mFolderDB->m_folder);
   return NS_OK;
 }
 
 /**
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.cpp b/mailnews/db/msgdb/src/nsMsgThread2.cpp
--- a/mailnews/db/msgdb/src/nsMsgThread2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgThread2.cpp
@@ -4,21 +4,64 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "msgCore.h"
 #include "nsCOMPtr.h"
 #include "nsMsgDatabase2.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 #include "nsMsgMessageFlags.h"
-// #include "nsMsgEnumerator.h"
+#include "nsMsgEnumerator.h"
 #include "MailNewsTypes2.h"
 // #include "mozilla/DebugOnly.h"
 #include "GlobalDB.h"
 
+/**
+ * Helper class for enumerating through the messages in a thread.
+ */
+
+// NOTE: This is a complete dupe of MsgEnumerator in nsMsgDatabase2.cpp!
+// Rationalise.
+class ChildEnumerator : public nsBaseMsgEnumerator {
+ public:
+  // TODO: provide move ctor to avoid copy here.
+  ChildEnumerator(nsMsgDatabase2* folderDB, nsTArray<nsMsgKey> const& keys)
+      : mFolderDB(folderDB), mCur(0) {
+    mKeys = keys.Clone();
+    // printf("XYZZY: ChildEnumerator ctor (%d keys)\n", (int)keys.Length());
+  };
+  ChildEnumerator() = delete;
+
+  // nsIMsgEnumerator support.
+  NS_IMETHOD GetNext(nsIMsgDBHdr** aItem) override {
+    if (mCur >= mKeys.Length()) {
+      *aItem = nullptr;
+      // NOTE: JSMsgIterator doesn't call HasMoreElements and relies on this
+      // behaviour.
+      return NS_ERROR_ILLEGAL_VALUE;
+    }
+    // printf("XYZZY ChildEnumerator::GetNext() -> %d\n", (int)mKeys[mCur]);
+    RefPtr<nsMsgHdr2> hdr = new nsMsgHdr2(mFolderDB, mKeys[mCur++]);
+    hdr.forget(aItem);
+    return NS_OK;
+  }
+
+  NS_IMETHOD HasMoreElements(bool* result) override {
+    *result = mCur < mKeys.Length();
+    // printf("XYZZY ChildEnumerator::HasMoreElements() -> %d < %d => %s\n",
+    //        (int)mCur, (int)mKeys.Length(), *result ? "true" : "false");
+    return NS_OK;
+  }
+
+ protected:
+  nsMsgDatabase2* mFolderDB;
+  nsTArray<nsMsgKey> mKeys;
+  size_t mCur;
+};
+
 NS_IMPL_ISUPPORTS(nsMsgThread2, nsIMsgThread)
 
 nsMsgThread2::nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID)
     : mFolderDB(folderDB), mThreadID(threadID) {
   //  printf("XYZZY [threadID=%d] nsMsgThread2::nsMsgThread2()\n", mThreadID);
 }
 
 nsMsgThread2::~nsMsgThread2() {
@@ -48,81 +91,96 @@ NS_IMETHODIMP nsMsgThread2::SetFlags(uin
 }
 
 NS_IMETHODIMP nsMsgThread2::SetSubject(const nsACString& subject) {
   //  printf("XYZZY [threadID=%d] nsMsgThread2::SetSubject()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetSubject(nsACString& subject) {
-  //  printf("XYZZY nsMsgThread2::GetSubject())\n");
+  // TODO
   return mFolderDB->DB().FetchMsgSubject(mThreadID, subject);
 }
 
 NS_IMETHODIMP nsMsgThread2::GetNumChildren(uint32_t* result) {
-  *result = 1;
-  // printf("XYZZY [threadID=%d] nsMsgThread2::GetNumChildren()\n", mThreadID);
-  return NS_OK;
+  return DB().ThreadMemberCount(mThreadID, result);
 }
 
 NS_IMETHODIMP nsMsgThread2::GetNumUnreadChildren(uint32_t* result) {
-  *result = 0;
-  // printf("XYZZY [threadID=%d] nsMsgThread2::GetNumUnreadChildren()\n",
-  // mThreadID);
-  return NS_OK;
+  // TODO
+  return DB().ThreadMemberCount(mThreadID, result);
 }
 
 NS_IMETHODIMP nsMsgThread2::AddChild(nsIMsgDBHdr* child, nsIMsgDBHdr* inReplyTo,
                                      bool threadInThread,
                                      nsIDBChangeAnnouncer* announcer) {
-  //  printf("XYZZY [threadID=%d] nsMsgThread2::AddChild()\n", mThreadID);
+  printf("XYZZY [threadID=%d] nsMsgThread2::AddChild() NOT IMPLEMENTED\n",
+         mThreadID);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
-NS_IMETHODIMP nsMsgThread2::GetChildKeyAt(uint32_t aIndex, nsMsgKey* aResult) {
-  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildKeyAt(idx=%d)\n",
-  //  mThreadID, aIndex);
-  *aResult = mThreadID;
+NS_IMETHODIMP nsMsgThread2::GetChildKeyAt(uint32_t index, nsMsgKey* childKey) {
+  nsTArray<nsMsgKey> msgKeys;
+  nsresult rv = DB().ThreadMembers(mThreadID, msgKeys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  MOZ_ASSERT(index < msgKeys.Length());
+  *childKey = msgKeys[index];
   return NS_OK;
 }
 
-NS_IMETHODIMP nsMsgThread2::GetChildHdrAt(uint32_t aIndex,
-                                          nsIMsgDBHdr** result) {
+NS_IMETHODIMP nsMsgThread2::GetChildHdrAt(uint32_t index,
+                                          nsIMsgDBHdr** childHdr) {
   //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChildHdrAt(idx=%d)\n",
   //  mThreadID, aIndex);
-  return NS_ERROR_NOT_IMPLEMENTED;
+
+  nsMsgKey childKey;
+  nsresult rv = GetChildKeyAt(index, &childKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  nsCOMPtr<nsIMsgDBHdr> foo = new nsMsgHdr2(mFolderDB, childKey);
+  foo.forget(childHdr);
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetChild(nsMsgKey msgKey, nsIMsgDBHdr** result) {
-  //  printf("XYZZY [threadID=%d] nsMsgThread2::GetChild(msgKey=%d)\n",
-  //  mThreadID, msgKey);
-  return GetRootHdr(result);
-  //  return NS_ERROR_NOT_IMPLEMENTED;
+  printf(
+      "XYZZY [threadID=%d] nsMsgThread2::GetChild(msgKey=%d) NOT IMPLEMENTED\n",
+      mThreadID, msgKey);
+  return NS_ERROR_NOT_IMPLEMENTED;
+  // nsCOMPtr<nsIMsgDBHdr> foo = new nsMsgHdr2(mFolderDB, childKey);
+  // foo.forget(result);
+  // return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::RemoveChildAt(uint32_t aIndex) { return NS_OK; }
 
 NS_IMETHODIMP nsMsgThread2::RemoveChildHdr(nsIMsgDBHdr* child,
                                            nsIDBChangeAnnouncer* announcer) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgThread2::MarkChildRead(bool bRead) {
   //  printf("XYZZY [threadID=%d] nsMsgThread2::MarkChildRead()\n", mThreadID);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::EnumerateMessages(nsMsgKey parentKey,
                                               nsIMsgEnumerator** result) {
-  //  printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages()\n",
-  //  mThreadID);
-  return mFolderDB->ThreadEnumerateMessages(parentKey, result);
-  //  NS_ADDREF(*result = new MsgEnumerator
-  //                new nsMsgThread2Enumerator(this, parentKey, nullptr,
-  //                nullptr));
+  printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages(parentKey=%d)\n",
+         mThreadID, (int)parentKey);
+
+  nsTArray<nsMsgKey> childKeys;
+  nsresult rv = DB().ThreadChildren(parentKey, childKeys);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  if (parentKey == nsMsgKey_None) {
+    parentKey = mThreadID;
+  }
+  printf(" -> %d messages to enumerate\n", (int)childKeys.Length());
+  NS_ADDREF(*result = new ChildEnumerator(mFolderDB, childKeys));
+  return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgThread2::GetRootHdr(nsIMsgDBHdr** result) {
   //  printf("XYZZY [threadID=%d] nsMsgThread2::GetRootHdr()\n", mThreadID);
   nsCOMPtr<nsIMsgDBHdr> foo = new nsMsgHdr2(mFolderDB, mThreadID);
   foo.forget(result);
   return NS_OK;
 }
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.h b/mailnews/db/msgdb/src/nsMsgThread2.h
--- a/mailnews/db/msgdb/src/nsMsgThread2.h
+++ b/mailnews/db/msgdb/src/nsMsgThread2.h
@@ -2,31 +2,33 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #ifndef _nsMsgThread2_H
 #define _nsMsgThread2_H
 
 #include "nsIMsgThread.h"
-//#include "nsString.h"
+// #include "nsString.h"
 #include "MailNewsTypes.h"
 #include "mdb.h"
 
 class nsIMsgDBHdr;
 class nsMsgDatabase2;
-//class GlobalDB;
+// class GlobalDB;
 
+// TODO: restrict thread messages to single folder.
 class nsMsgThread2 : public nsIMsgThread {
  public:
   nsMsgThread2() = delete;
   nsMsgThread2(nsMsgDatabase2* folderDB, nsMsgKey threadID);
 
   NS_DECL_ISUPPORTS
   NS_DECL_NSIMSGTHREAD
 
  protected:
   virtual ~nsMsgThread2();
+  GlobalDB& DB() { return mFolderDB->DB(); }
   nsMsgDatabase2* mFolderDB;
   nsMsgKey mThreadID;
 };
 
 #endif
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1671686928 -46800
#      Thu Dec 22 18:28:48 2022 +1300
# Node ID dada94158a1486976fc3059f417c1386f98ba037
# Parent  12f156a35ffb4ca55610c14d28f95f9ea501a85a
WIP: implement a bit of caching to mitigate read hammering

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -122,16 +122,17 @@ nsresult GlobalDB::InitSchema() {
         "replyTo TEXT NOT NULL DEFAULT '', "
         "flags INTEGER NOT NULL DEFAULT 0, "
         "priority INTEGER NOT NULL DEFAULT 0, "
         "msgSize INTEGER NOT NULL DEFAULT 0, "  // SIZE is reserved word
         "storeToken TEXT NOT NULL DEFAULT '', "
         "offlineMsgSize INTEGER NOT NULL DEFAULT 0, "
         "numLines INTEGER NOT NULL DEFAULT 0, "
         "preview TEXT NOT NULL DEFAULT '', "
+        "junkscore INTEGER NOT NULL DEFAULT 0, "
         "junkscoreorigin TEXT NOT NULL DEFAULT '', "
         "junkpercent TEXT NOT NULL DEFAULT '', "
         "senderName TEXT NOT NULL DEFAULT '', "  // KILL?
         "prevkeywords TEXT NOT NULL DEFAULT '', "
         "keywords TEXT NOT NULL DEFAULT '', "
         "remoteContentPolicy INTEGER NOT NULL DEFAULT 0, "
         "protoThreadFlags INTEGER NOT NULL DEFAULT 0, "
         //  "account TEXT NOT NULL DEFAULT '', "    // ACCOUNT is reserved word
@@ -364,236 +365,238 @@ already_AddRefed<mozIStorageStatement> G
 }
 
 already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(const char* query) {
   return Stmt(nsDependentCString(query));
 }
 
 // -------------- data access ---------------
 
-nsresult GlobalDB::FetchMsgFlags(nsMsgKey key, uint32_t* flags) {
-  if (auto p = mFlagsCache.lookup(key)) {
-    *flags = p->value();
-    // printf("XYZZY mFlagsCache hit (key=%d) => 0x%" PRIx32 "\n", (int)key,
-    // *flags);
-    return NS_OK;
-  }
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT flags FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
-  NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  if (!exists) {
-    printf("XYZZY: FetchMsgFlags(key=%d) found nothing\n", (int)key);
-  }
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  rv = stmt->GetInt32(0, (int32_t*)flags);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(mFlagsCache.putNew(key, *flags), NS_ERROR_OUT_OF_MEMORY);
-  return NS_OK;
-}
-
-nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT messageID FROM msg WHERE rowid=:rowid");
+// private helper
+nsresult GlobalDB::FetchMsg(nsMsgKey key, CachedHdr& hdr) {
+  printf("XYZZY GlobalDB::FetchMsg(key=%d)\n", (int)key);
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT messageID, refs, date, subject, sender, sender, "
+      "recipients, ccList, bccList, flags, msgSize, storeToken, "
+      "offlineMsgSize, numLines, junkscore, keywords FROM msg "
+      "WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, messageID);
-}
 
-nsresult GlobalDB::FetchMsgReferences(nsMsgKey key, nsACString& refs) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT refs FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
-  NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, refs);
-}
-
-nsresult GlobalDB::FetchMsgSender(nsMsgKey key, nsACString& sender) {
-  if (auto p = mSenderCache.lookup(key)) {
-    sender = p->value();
-    // printf("XYZZY mSenderCache hit (key=%d) => '%s'\n", (int)key,
-    // nsPromiseFlatCString(sender).get());
-    return NS_OK;
-  }
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT sender FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
-  NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  rv = stmt->GetUTF8String(0, sender);
-  NS_ENSURE_TRUE(mSenderCache.putNew(key, sender), NS_ERROR_OUT_OF_MEMORY);
-  return rv;
-}
-
-nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
-  if (auto p = mSubjectCache.lookup(key)) {
-    subject = p->value();
-    // printf("XYZZY mSubjectCache hit (key=%d) => '%s'\n", (int)key,
-    // nsPromiseFlatCString(subject).get());
-    return NS_OK;
-  }
-  //  printf("XYZZY GlobalDB::FetchMsgSubject(key=%d)\n", key);
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT subject FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
-  NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  rv = stmt->GetUTF8String(0, subject);
-  //  printf("XYZZY      FetchMsgSubject()  ==> '%s'\n",
-  //         nsPromiseFlatCString(subject).get());
-  NS_ENSURE_TRUE(mSubjectCache.putNew(key, subject), NS_ERROR_OUT_OF_MEMORY);
-  return rv;
+
+  // Unmarshall row into CachedHdr struct
+  int pos = 0;
+  int64_t tmp64 = 0;
+
+  rv = stmt->GetUTF8String(pos++, hdr.messageID);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetUTF8String(pos++, hdr.references);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.date = (uint32_t)tmp64;
+
+  rv = stmt->GetUTF8String(pos++, hdr.subject);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetUTF8String(pos++, hdr.sender);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetUTF8String(pos++, hdr.recipients);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetUTF8String(pos++, hdr.ccList);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetUTF8String(pos++, hdr.bccList);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.flags = (uint32_t)tmp64;
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.size = (uint32_t)tmp64;
+
+  rv = stmt->GetUTF8String(pos++, hdr.storeToken);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.offlineSize = (uint32_t)tmp64;
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.lineCount = (uint32_t)tmp64;
+
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.junkscore = (uint32_t)tmp64;
+
+  rv = stmt->GetUTF8String(pos++, hdr.keywords);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  return NS_OK;
+}
+
+// Probably a little naughty returning a pointer to fiddle the
+// data in-place. It's unclear if HashMap moves values around
+// I think not, but you never know.
+nsresult GlobalDB::GetCachedHdr(nsMsgKey key, CachedHdr** hdr) {
+  auto p = mHdrCache.lookupForAdd(key);
+  if (p) {
+    *hdr = &(p->value());
+    return NS_OK;
+  }
+
+  CachedHdr tmp;
+  nsresult rv = FetchMsg(key, tmp);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ENSURE_TRUE(mHdrCache.add(p, key, tmp), NS_ERROR_OUT_OF_MEMORY);
+  *hdr = &(p->value());
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgFlags(nsMsgKey key, uint32_t* flags) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *flags = hdr->flags;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  messageID = hdr->messageID;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgReferences(nsMsgKey key, nsACString& refs) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  refs = hdr->references;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgSender(nsMsgKey key, nsACString& sender) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  sender = hdr->sender;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgSubject(nsMsgKey key, nsACString& subject) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  subject = hdr->subject;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgRecipients(nsMsgKey key, nsACString& recipients) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT recipients FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, recipients);
+  recipients = hdr->recipients;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgCCList(nsMsgKey key, nsACString& ccList) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT ccList FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, ccList);
+  ccList = hdr->ccList;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgBCCList(nsMsgKey key, nsACString& bccList) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT bccList FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, bccList);
+  bccList = hdr->bccList;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgSize(nsMsgKey key, uint64_t* size) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT msgSize FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetInt64(0, (int64_t*)size);
+  *size = hdr->size;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgOfflineSize(nsMsgKey key, uint64_t* size) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT offlineMsgSize FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetInt64(0, (int64_t*)size);
+  *size = hdr->offlineSize;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT numLines FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetInt32(0, (int32_t*)lineCount);
+  *lineCount = hdr->lineCount;
+  return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgDate(nsMsgKey key, uint32_t* seconds) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT date FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetInt32(0, (int32_t*)seconds);
+  *seconds = hdr->date;
+  return NS_OK;
 }
 
 // Return the thread this message belongs to.
 nsresult GlobalDB::FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadKey) {
+  if (auto p = mMsgThreadIDCache.lookup(key)) {
+    *threadKey = p->value();
+    return NS_OK;
+  }
+  printf("XYZZY GlobalDB::FetchMsgThreadID(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT thread FROM msg_thread WHERE msg=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   int64_t tmp;
   rv = stmt->GetInt64(0, &tmp);
   NS_ENSURE_SUCCESS(rv, rv);
   *threadKey = (nsMsgKey)tmp;
+
+  // Cache it.
+  NS_ENSURE_TRUE(mMsgThreadIDCache.putNew(key, *threadKey),
+                 NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 // Return the parent of this message (or nsMsgKey_None if root).
 nsresult GlobalDB::FetchMsgThreadParent(nsMsgKey key, nsMsgKey* parentKey) {
+  printf("XYZZY GlobalDB::FetchMsgThreadParent(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT parent FROM msg_thread WHERE msg=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
@@ -613,16 +616,17 @@ nsresult GlobalDB::FetchMsgThreadParent(
   rv = stmt->GetInt64(0, &tmp);
   NS_ENSURE_SUCCESS(rv, rv);
   *parentKey = (nsMsgKey)tmp;
   return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgPriority(nsMsgKey key,
                                     nsMsgPriorityValue* priority) {
+  printf("XYZZY GlobalDB::FetchMsgPriority(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT priority FROM msg WHERE rowid=:rowid");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
@@ -631,27 +635,37 @@ nsresult GlobalDB::FetchMsgPriority(nsMs
   return stmt->GetInt32(0, (int32_t*)priority);
 }
 
 nsresult GlobalDB::FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT storeToken FROM msg WHERE rowid=:rowid");
-  NS_ENSURE_STATE(stmt);
-  mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  storeToken = hdr->storeToken;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgKeywords(nsMsgKey key, nsACString& keywords) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  bool exists;
-  rv = stmt->ExecuteStep(&exists);
+  keywords = hdr->keywords;
+  return NS_OK;
+}
+
+nsresult GlobalDB::FetchMsgJunkscore(nsMsgKey key, uint32_t* junkscore) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
-  return stmt->GetUTF8String(0, storeToken);
+  *junkscore = hdr->junkscore;
+  return NS_OK;
 }
 
 // The Mime2Decoded ones are intended to convert according to charset field in
 // message (potentially with default encoding for news folders). For now
 // just assume everything is utf-8.
 nsresult GlobalDB::FetchMsgMime2DecodedSender(nsMsgKey key, nsAString& author) {
   nsAutoCString tmp;
   nsresult rv = FetchMsgSender(key, tmp);
@@ -712,176 +726,239 @@ nsresult GlobalDB::CreateCollationKey(co
   if (result.isErr()) {
     return NS_ERROR_FAILURE;
   }
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
   MOZ_ASSERT(flags < INT32_MAX);
+  // Update the DB.
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET flags=:flags WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(mFlagsCache.put(key, flags), NS_ERROR_OUT_OF_MEMORY);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->flags = flags;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET messageID=:messageID WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->messageID = messageID;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgReferences(nsMsgKey key,
                                     nsACString const& references) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET refs=:refs WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("refs"_ns, references);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->references = references;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSender(nsMsgKey key, nsACString const& sender) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET sender=:sender WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("sender"_ns, sender);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(mSenderCache.put(key, sender), NS_ERROR_OUT_OF_MEMORY);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->sender = sender;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET subject=:subject WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("subject"_ns, subject);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
 
-  NS_ENSURE_TRUE(mSubjectCache.put(key, subject), NS_ERROR_OUT_OF_MEMORY);
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->subject = subject;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
                                     nsACString const& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET recipients=:recipients WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("recipients"_ns, recipients);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->recipients = recipients;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgCCList(nsMsgKey key, nsACString const& ccList) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET ccList=:ccList WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("ccList"_ns, ccList);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->ccList = ccList;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgBCCList(nsMsgKey key, nsACString const& bccList) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET bccList=:bccList WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("bccList"_ns, bccList);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->bccList = bccList;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSize(nsMsgKey key, uint64_t msgSize) {
   MOZ_ASSERT(msgSize < INT64_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET msgSize=:msgSize WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("msgSize"_ns, (int64_t)msgSize);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->size = msgSize;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgOfflineSize(nsMsgKey key, uint64_t offlineMsgSize) {
   MOZ_ASSERT(offlineMsgSize < INT64_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET offlineMsgSize=:offlineMsgSize WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv =
       stmt->BindInt64ByName("offlineMsgSize"_ns, (int64_t)offlineMsgSize);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->offlineSize = offlineMsgSize;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgLineCount(nsMsgKey key, uint32_t lineCount) {
   MOZ_ASSERT(lineCount < INT32_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET numLines=:lineCount WHERE rowid=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("lineCount"_ns, (int32_t)lineCount);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->lineCount = lineCount;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
   //  MOZ_ASSERT(seconds < INT32_MAX);  // This was triggering...
   //  printf("XYZZY SetMsgDate(key=%d seconds=0x%" PRIx32 ")\n", (int)key,
   //  seconds);
   nsCOMPtr<mozIStorageStatement> stmt =
@@ -889,16 +966,22 @@ nsresult GlobalDB::SetMsgDate(nsMsgKey k
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("seconds"_ns, (int32_t)seconds);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->date = seconds;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgThreadID(nsMsgKey key, nsMsgKey threadID) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority) {
@@ -917,16 +1000,62 @@ nsresult GlobalDB::SetMsgStoreToken(nsMs
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("storeToken"_ns, storeToken);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->storeToken = storeToken;
+  return NS_OK;
+}
+
+nsresult GlobalDB::SetMsgKeywords(nsMsgKey key, nsACString const& keywords) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET keywords=:keywords WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindUTF8StringByName("keywords"_ns, keywords);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->keywords = keywords;
+  return NS_OK;
+}
+
+nsresult GlobalDB::SetMsgJunkscore(nsMsgKey key, uint32_t junkscore) {
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET junkscore=:junkscore WHERE rowid=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("junkscore"_ns, (int64_t)junkscore);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->junkscore = junkscore;
   return NS_OK;
 }
 
 // odd flag-twiddling ones (TODO: rationalise these)
 nsresult GlobalDB::FetchMsgIsRead(nsMsgKey key, bool* isRead) {
   uint32_t flags;
   nsresult rv = FetchMsgFlags(key, &flags);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1018,40 +1147,52 @@ nsresult GlobalDB::SetMsgHasAttachments(
     return NS_OK;
   }
   return SetMsgFlags(key, flags);
 }
 
 // to support nsMsgDatabase2
 nsresult GlobalDB::FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                                      bool* containsKey) {
+  if (mFolderContainsKeyCache.has({folderID, key})) {
+    *containsKey = true;
+    return NS_OK;
+  }
+  printf("XYZZY GlobalDB::FolderContainsKey(folderID=%d, key=%d)\n",
+         (int)folderID, (int)key);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT 1 FROM msg_folder WHERE msg_id=:msgKey AND folder_id=:folderKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
 
   nsresult rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderID);
   NS_ENSURE_SUCCESS(rv, rv);
-  return stmt->ExecuteStep(containsKey);
+  rv = stmt->ExecuteStep(containsKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  NS_ENSURE_TRUE(mFolderContainsKeyCache.put(FolderMsgPair{folderID, key}),
+                 NS_ERROR_OUT_OF_MEMORY);
+  return NS_OK;
 }
 
 nsresult GlobalDB::FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                                       nsIDBChangeListener* instigator,
                                       bool commit, bool notify) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FolderUndoDelete(nsFolderKey folderID, nsMsgKey key) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::FolderListAllKeys(nsFolderKey folderID,
                                      nsTArray<nsMsgKey>& keys) {
+  printf("XYZZY GlobalDB::FolderListAllKeys(folderID=%d)\n", (int)folderID);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT msg_id FROM msg_folder WHERE folder_id=:folderKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderID);
   NS_ENSURE_SUCCESS(rv, rv);
 
   keys.Clear();
@@ -1127,68 +1268,16 @@ nsresult GlobalDB::FolderFindOrCreate(ns
     NS_ENSURE_SUCCESS(rv, rv);
     *folderID = (nsFolderKey)rowid;
     printf("Created Folder (key='%d' uri='%s')\n", (int)(*folderID),
            nsPromiseFlatCString(folderURI).get());
   }
   return NS_OK;
 }
 
-#if 0
-nsresult GlobalDB::FolderEnumerateMsgs(nsFolderKey folderID,
-                                       nsIMsgEnumerator** result) {
-  nsTArray<nsMsgKey> keys;
-  nsresult rv = FolderListAllKeys(folderID, keys);
-  NS_ENSURE_SUCCESS(rv, rv);
-  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
-  e.forget(result);
-  return NS_OK;
-}
-
-nsresult GlobalDB::FolderReverseEnumerateMsgs(nsFolderKey folderID,
-                                              nsIMsgEnumerator** result) {
-  nsTArray<nsMsgKey> keys;
-  nsresult rv = FolderListAllKeys(folderID, keys);
-  NS_ENSURE_SUCCESS(rv, rv);
-  keys.Reverse();
-  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, keys);
-  e.forget(result);
-  return NS_OK;
-}
-
-nsresult GlobalDB::FolderEnumerateMsgsFiltered(
-    nsFolderKey folderID, const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms,
-    bool aReverse, nsIMsgEnumerator** result) {
-  // TODO
-  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
-  e.forget(result);
-  return NS_OK;
-}
-
-nsresult GlobalDB::FolderEnumerateMsgsWithFlag(nsFolderKey folderID,
-                                               uint32_t flag,
-                                               nsIMsgEnumerator** result) {
-  // TODO
-  RefPtr<MsgEnumerator> e = new MsgEnumerator(this, {});
-  e.forget(result);
-  return NS_OK;
-}
-
-nsresult GlobalDB::FolderEnumerateThreads(nsFolderKey folderID,
-                                          nsIMsgThreadEnumerator** result) {
-  // TODO
-  nsTArray<nsMsgKey> threadIDs;
-  nsresult rv = FolderListAllKeys(folderID, threadIDs);
-  NS_ENSURE_SUCCESS(rv, rv);
-  RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
-  e.forget(result);
-  return NS_OK;
-}
-#endif
-
 nsresult GlobalDB::FolderSetProperty(nsFolderKey folderID,
                                      nsACString const& name,
                                      nsACString const& value) {
   // oooh, an UPSERT!
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO folder_prop (folder_id, name, value) VALUES(:folderID, "
       ":name, :value) ON CONFLICT(folder_id, name) DO UPDATE SET "
       "value=excluded.value;");
@@ -1204,16 +1293,18 @@ nsresult GlobalDB::FolderSetProperty(nsF
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderGetProperty(nsFolderKey folderID,
                                      nsACString const& name,
                                      nsACString& value) {
+  printf("XYZZY GlobalDB::FolderGetProperty(%s)\n",
+         nsPromiseFlatCString(name).get());
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT value FROM folder_prop WHERE folder_id=:folderID AND name=:name");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("name"_ns, name);
@@ -1239,42 +1330,61 @@ nsresult GlobalDB::MsgSetProperty(nsMsgK
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("name"_ns, name);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("value"_ns, value);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
+
+  // Invalidate cache
+  mMsgPropertyCache.remove(MsgPropPair(key, name));
   return NS_OK;
 }
 
 nsresult GlobalDB::MsgGetProperty(nsMsgKey key, nsACString const& name,
                                   nsACString& value) {
+  if (auto p = mMsgPropertyCache.lookup(MsgPropPair(key, name))) {
+    value = p->value();
+    return NS_OK;
+  }
+
+  printf("XYZZY GlobalDB::MsgGetProperty(msgKey=%d '%s')\n", (int)key,
+         nsPromiseFlatCString(name).get());
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT value FROM msg_prop WHERE msg_id=:msgKey AND name=:name");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("name"_ns, name);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
-  if (!exists) {
-    return NS_OK;
+  if (exists) {
+    rv = stmt->GetUTF8String(0, value);
+    NS_ENSURE_SUCCESS(rv, rv);
+  } else {
+    value.Truncate();
   }
-  return stmt->GetUTF8String(0, value);
+
+  // Cache it
+  NS_ENSURE_TRUE(mMsgPropertyCache.putNew(MsgPropPair(key, name), value),
+                 NS_ERROR_OUT_OF_MEMORY);
+  return NS_OK;
 }
 
 // Returns nsMsgKey_None if none found.
 nsresult GlobalDB::FindMsgByMessageID(nsACString const& messageID,
                                       nsMsgKey* msgKey) {
+  printf("XYZZY GlobalDB::FindMsgByMessageID(%s)\n",
+         nsPromiseFlatCString(messageID).get());
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT rowid FROM msg WHERE messageID=:messageID");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
@@ -1366,21 +1476,32 @@ nsresult GlobalDB::ThreadNewMsg(nsMsgKey
     rv = stmt->Execute();
     NS_ENSURE_SUCCESS(rv, rv);
 
     printf(
         "XYZZY: GlobalDB::ThreadNewMsg() -> msg=%d parent=%d thread=%d "
         "depth=%d\n",
         (int)msgKey, (int)parentKey, (int)*threadID, (int)depth);
   }
+  // Invalidate relevant cached data.
+  mThreadMemberCountCache.remove(*threadID);
+  mThreadMembersCache.remove(*threadID);
+  mMsgChildrenCache.remove(msgKey);
   return NS_OK;
 }
 
 // Count the total number of messages belonging to this thread.
 nsresult GlobalDB::ThreadMemberCount(nsMsgKey threadKey, uint32_t* total) {
+  auto p = mThreadMemberCountCache.lookup(threadKey);
+  if (p) {
+    *total = p->value();
+    return NS_OK;
+  }
+
+  printf("XYZZY GlobalDB::ThreadMemberCount(threadKey=%d)\n", (int)threadKey);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT count(*) FROM msg_thread WHERE thread=:threadKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("threadKey"_ns, (int64_t)threadKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   bool exists;
@@ -1388,22 +1509,33 @@ nsresult GlobalDB::ThreadMemberCount(nsM
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists,
                  NS_MSG_MESSAGE_NOT_FOUND);  // really thread not found...
 
   int64_t tmp;
   rv = stmt->GetInt64(0, &tmp);
   NS_ENSURE_SUCCESS(rv, rv);
   *total = (uint32_t)tmp;
+
+  // Add to cache.
+  NS_ENSURE_TRUE(mThreadMemberCountCache.putNew(threadKey, *total),
+                 NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 // Get child messages ordered by date.
-nsresult GlobalDB::ThreadChildren(nsMsgKey parentKey,
-                                  nsTArray<nsMsgKey>& children) {
+nsresult GlobalDB::FetchMsgChildren(nsMsgKey parentKey,
+                                    nsTArray<nsMsgKey>& children) {
+  auto p = mMsgChildrenCache.lookup(parentKey);
+  if (p) {
+    children = p->value().Clone();
+    return NS_OK;
+  }
+
+  printf("XYZZY GlobalDB::FetchMsgChildren(parentKey=%d)\n", (int)parentKey);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
       "WHERE t.parent=:parentKey ORDER BY m.date ASC");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("parentKey"_ns, (int64_t)parentKey);
   NS_ENSURE_SUCCESS(rv, rv);
   children.Clear();
@@ -1414,21 +1546,30 @@ nsresult GlobalDB::ThreadChildren(nsMsgK
     if (!exists) {
       break;
     }
     int64_t tmp;
     rv = stmt->GetInt64(0, &tmp);
     NS_ENSURE_SUCCESS(rv, rv);
     children.AppendElement((nsMsgKey)tmp);
   }
+  // Cache it.
+  NS_ENSURE_TRUE(mMsgChildrenCache.putNew(parentKey, children.Clone()),
+                 NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
 // Get all messages belonging to thread, ordered by date.
 nsresult GlobalDB::ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs) {
+  if (auto p = mThreadMembersCache.lookup(threadKey)) {
+    msgs = p->value().Clone();
+    return NS_OK;
+  }
+
+  printf("XYZZY GlobalDB::ThreadMembers(threadKey=%d)\n", (int)threadKey);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
       "WHERE t.thread=:threadKey ORDER BY m.date ASC");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("threadKey"_ns, (int64_t)threadKey);
   NS_ENSURE_SUCCESS(rv, rv);
   msgs.Clear();
@@ -1439,25 +1580,36 @@ nsresult GlobalDB::ThreadMembers(nsMsgKe
     if (!exists) {
       break;
     }
     int64_t tmp;
     rv = stmt->GetInt64(0, &tmp);
     NS_ENSURE_SUCCESS(rv, rv);
     msgs.AppendElement((nsMsgKey)tmp);
   }
+
+  // Cache it.
+  NS_ENSURE_TRUE(mThreadMembersCache.putNew(threadKey, msgs.Clone()),
+                 NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
-// Get a list of all threads.
-nsresult GlobalDB::AllThreads(nsTArray<nsMsgKey>& threadKeys) {
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT distinct thread FROM msg_thread");
+// List all the threads with root messages in the specified folder.
+nsresult GlobalDB::FetchFolderThreads(nsFolderKey folderKey,
+                                      nsTArray<nsMsgKey>& threadKeys) {
+  printf("XYZZY GlobalDB::FetchFolderThreads(folderKey=%d)\n", (int)folderKey);
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT DISTINCT t.thread FROM msg_thread t INNER JOIN msg_folder f ON "
+      "t.msg = f.msg_id WHERE f.folder_id = :folderKey");
   NS_ENSURE_STATE(stmt);
+
   mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   threadKeys.Clear();
   while (1) {
     bool exists;
     nsresult rv = stmt->ExecuteStep(&exists);
     NS_ENSURE_SUCCESS(rv, rv);
     if (!exists) {
       break;
     }
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -7,23 +7,26 @@
 #ifndef GlobalDB_h_
 #define GlobalDB_h_
 
 #include "mozilla/storage.h"
 #include "mozilla/HashTable.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
-
+// #include "nsHashKeys.h"
+#include "mozilla/PairHash.h"
 typedef uint32_t nsFolderKey;
 
 namespace mozilla::intl {
 class Collator;
 }
 
+// Used for mork import, but should be trimmed down and used
+// when adding messages to the system.
 struct RawHdr {
   // nsMsgKey id{0};
   nsCString messageID;
   nsCString references;
   uint64_t date{0};
   uint64_t received{0};
   nsCString subject;
   nsCString sender;
@@ -33,16 +36,17 @@ struct RawHdr {
   nsCString replyTo;
   uint32_t flags{0};
   int32_t priority{0};
   uint64_t msgSize{0};
   nsCString storeToken;
   uint64_t offlineMsgSize{0};
   uint32_t numLines{0};
   nsCString preview;
+  uint32_t junkscore{0};
   nsCString junkscoreorigin;
   nsCString junkpercent;
   nsCString senderName;
   nsCString prevkeywords;
   nsCString keywords;
   int remoteContentPolicy{0};
   int protoThreadFlags{0};
   int glodaId{0};
@@ -87,16 +91,18 @@ class GlobalDB {
   nsresult FetchMsgBCCList(nsMsgKey key, nsACString& bccList);
   nsresult FetchMsgSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgOfflineSize(nsMsgKey key, uint64_t* size);
   nsresult FetchMsgLineCount(nsMsgKey key, uint32_t* lineCount);
   nsresult FetchMsgDate(nsMsgKey key, uint32_t* seconds);
   nsresult FetchMsgPriority(nsMsgKey key, nsMsgPriorityValue* priority);
   nsresult FetchMsgAccountKey(nsMsgKey key, nsACString& accountKey);
   nsresult FetchMsgStoreToken(nsMsgKey key, nsACString& storeToken);
+  nsresult FetchMsgKeywords(nsMsgKey key, nsACString& keywords);
+  nsresult FetchMsgJunkscore(nsMsgKey key, uint32_t* junkscore);
 
   nsresult FetchMsgThreadID(nsMsgKey key, nsMsgKey* threadKey);
   nsresult FetchMsgThreadParent(nsMsgKey key, nsMsgKey* parentKey);
 
   // Hmm. Feels like these shouldn't exist.
   nsresult FetchMsgMime2DecodedSender(nsMsgKey key, nsAString& author);
   nsresult FetchMsgMime2DecodedSubject(nsMsgKey key, nsAString& subject);
   nsresult FetchMsgMime2DecodedRecipients(nsMsgKey key, nsAString& recipients);
@@ -121,16 +127,18 @@ class GlobalDB {
   nsresult SetMsgSize(nsMsgKey key, uint64_t size);
   nsresult SetMsgOfflineSize(nsMsgKey key, uint64_t offlineSize);
   nsresult SetMsgLineCount(nsMsgKey key, uint32_t lineCount);
   nsresult SetMsgDate(nsMsgKey key, uint32_t seconds);
   nsresult SetMsgThreadID(nsMsgKey key, nsMsgKey threadID);
   nsresult SetMsgPriority(nsMsgKey key, nsMsgPriorityValue priority);
   nsresult SetMsgAccountKey(nsMsgKey key, nsACString const& accountKey);
   nsresult SetMsgStoreToken(nsMsgKey key, nsACString const& storeToken);
+  nsresult SetMsgKeywords(nsMsgKey key, nsACString const& keywords);
+  nsresult SetMsgJunkscore(nsMsgKey key, uint32_t junkscore);
 
   // odd flag-twiddling ones
   nsresult FetchMsgIsRead(nsMsgKey key, bool* isRead);
   nsresult FetchMsgIsMarked(nsMsgKey key, bool* isMarked);
   nsresult FetchMsgHasAttachments(nsMsgKey key, bool* hasAttachments);
 
   // return true if the msg is in a thread with Ignored flag.
   nsresult FetchMsgIsIgnored(nsMsgKey key, bool* isIgnored);
@@ -162,78 +170,130 @@ class GlobalDB {
   nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
                               nsIDBChangeListener* instigator, bool commit,
                               bool notify);
 
   nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
-#if 0
-  nsresult FolderEnumerateMsgs(nsFolderKey folderID, nsIMsgEnumerator** result);
-  nsresult FolderReverseEnumerateMsgs(nsFolderKey folderID,
-                                      nsIMsgEnumerator** result);
-  nsresult FolderEnumerateMsgsFiltered(
-      nsFolderKey folderID,
-      const nsTArray<RefPtr<nsIMsgSearchTerm>>& searchTerms, bool aReverse,
-      nsIMsgEnumerator** aResult);
-  nsresult FolderEnumerateMsgsWithFlag(nsFolderKey folderID, uint32_t flag,
-                                       nsIMsgEnumerator** result);
-  nsresult FolderEnumerateThreads(nsFolderKey folderID,
-                                  nsIMsgThreadEnumerator** result);
-#endif
-
   // Icky random-property stuff on folder and message.
   nsresult FolderSetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString const& value);
   nsresult FolderGetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString& value);
   nsresult MsgSetProperty(nsMsgKey key, nsACString const& name,
                           nsACString const& value);
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
 
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   // Thread stuff.
-#if 0
-  nsresult ThreadEnumerateMessages(nsMsgKey parentKey,
-                                   nsIMsgEnumerator** enumerator);
-#endif
+
   // Return key of message with matching messageID.
   // Returns nsMsgKey_None if not found.
   nsresult FindMsgByMessageID(nsACString const& messageID, nsMsgKey* msgKey);
 
   // Return all direct children of parentKey.
-  nsresult ThreadChildren(nsMsgKey parentKey, nsTArray<nsMsgKey>& children);
+  nsresult FetchMsgChildren(nsMsgKey parentKey, nsTArray<nsMsgKey>& children);
   // Return all messages belonging to thread.
   nsresult ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs);
   // Number of messages belonging to thread.
   nsresult ThreadMemberCount(nsMsgKey threadKey, uint32_t* total);
 
   // Inserts a message into the threading system.
   nsresult ThreadNewMsg(nsMsgKey msgKey, nsMsgKey* threadID);
 
-  // List all the threads in the DB.
-  nsresult AllThreads(nsTArray<nsMsgKey>& threadKeys);
+  // List all the threads with root messages in the specified folder.
+  nsresult FetchFolderThreads(nsFolderKey folderKey,
+                              nsTArray<nsMsgKey>& threadKeys);
 
  private:
   nsresult InitSchema();
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
   mutable mozilla::storage::StatementCache<mozIStorageStatement> mStmtCache;
 
   mozilla::UniquePtr<mozilla::intl::Collator> mCollator;
 
-  // Noddy caching system
-  mozilla::HashMap<nsMsgKey, nsAutoCString> mSubjectCache;
-  mozilla::HashMap<nsMsgKey, nsAutoCString> mSenderCache;
-  mozilla::HashMap<nsMsgKey, uint32_t> mFlagsCache;
+  // ----------------- Noddy caching system -----------------
+
+  // By rights, CachedHdr should be just be the nsIMsgDBHdr object...
+  // But nsIMsgDBHdr is tied to a single folder, so you can have multiple
+  // nsIMsgDBHdr objects referring to the same message. So, no good for
+  // caching.
+  struct CachedHdr {
+    nsAutoCString messageID;
+    nsAutoCString references;
+    uint32_t date{0};  // in seconds
+    nsAutoCString subject;
+    nsAutoCString sender;
+    nsAutoCString recipients;
+    nsAutoCString ccList;
+    nsAutoCString bccList;
+    uint32_t flags{0};
+    uint32_t size{0};
+    nsAutoCString storeToken;
+    uint32_t offlineSize{0};
+    uint32_t lineCount{0};
+    uint32_t junkscore{0};
+    nsAutoCString keywords;
+
+    // derived fields
+    nsAutoString subjectDecoded;
+    nsAutoString senderDecoded;
+    nsAutoString recipientsDecoded;
+  };
+
+  nsresult FetchMsg(nsMsgKey msgKey, CachedHdr& hdr);
+  nsresult GetCachedHdr(nsMsgKey key, CachedHdr** hdr);
+
+  mozilla::HashMap<nsMsgKey, CachedHdr> mHdrCache;
+  // The rest is pretty ad-hoc.
+  mozilla::HashMap<nsMsgKey, uint32_t> mThreadMemberCountCache;
+  mozilla::HashMap<nsMsgKey, nsMsgKey> mMsgThreadIDCache;
+
+  mozilla::HashMap<nsMsgKey, nsTArray<nsMsgKey>> mMsgChildrenCache;
+  mozilla::HashMap<nsMsgKey, nsTArray<nsMsgKey>> mThreadMembersCache;
+  //
+  struct FolderMsgPair {
+    nsFolderKey folderKey;
+    nsMsgKey msgKey;
+
+    typedef FolderMsgPair Lookup;
+    static mozilla::HashNumber hash(FolderMsgPair const& k) {
+      mozilla::HashNumber h = mozilla::HashGeneric(k.folderKey);
+      return mozilla::AddToHash(h, k.msgKey);
+    }
+    static bool match(const FolderMsgPair& a, const FolderMsgPair& b) {
+      return a.folderKey == b.folderKey && a.msgKey == b.msgKey;
+    }
+  };
+
+  mozilla::HashSet<FolderMsgPair, FolderMsgPair> mFolderContainsKeyCache;
+
+  //
+  struct MsgPropPair {
+    nsMsgKey msgKey;
+    nsCString prop;
+    MsgPropPair(nsMsgKey k, nsACString const& propName)
+        : msgKey(k), prop(propName) {}
+
+    typedef MsgPropPair Lookup;
+    static mozilla::HashNumber hash(MsgPropPair const& k) {
+      return mozilla::HashGeneric(mozilla::HashString(k.prop), k.msgKey);
+    }
+    static bool match(const MsgPropPair& a, const MsgPropPair& b) {
+      return a.msgKey == b.msgKey && a.prop == b.prop;
+    }
+  };
+  mozilla::HashMap<MsgPropPair, nsCString, MsgPropPair> mMsgPropertyCache;
 };
 
 #endif  // GlobalDB_h_
diff --git a/mailnews/db/msgdb/src/MSFSlurp.cpp b/mailnews/db/msgdb/src/MSFSlurp.cpp
--- a/mailnews/db/msgdb/src/MSFSlurp.cpp
+++ b/mailnews/db/msgdb/src/MSFSlurp.cpp
@@ -419,17 +419,17 @@ nsresult MSFSlurper::dumpum(nsACString c
         // IGNORE
       } else if (name.EqualsLiteral("storeToken")) {
         msg.storeToken = v;
       } else if (name.EqualsLiteral("offlineMsgSize")) {
         msg.offlineMsgSize = hexToU64(v);
       } else if (name.EqualsLiteral("numLines")) {
         msg.numLines = hexToU32(v);
       } else if (name.EqualsLiteral("junkscore")) {
-        // ?
+        msg.junkscore = hexToU32(v);  // ?
       } else if (name.EqualsLiteral("junkscoreorigin")) {
         msg.junkscoreorigin = v;
       } else if (name.EqualsLiteral("junkpercent")) {
         msg.junkpercent = v;
       } else if (name.EqualsLiteral("label")) {
         // ?
       } else if (name.EqualsLiteral("gloda-dirty")) {
         // ?
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -764,21 +764,18 @@ nsresult nsMsgDatabase2::EnumerateMessag
 }
 
 NS_IMETHODIMP nsMsgDatabase2::ListAllKeys(nsTArray<nsMsgKey>& keys) {
   return DB().FolderListAllKeys(mFolderID, keys);
 }
 
 NS_IMETHODIMP
 nsMsgDatabase2::EnumerateThreads(nsIMsgThreadEnumerator** result) {
-  // TODO
   nsTArray<nsMsgKey> threadIDs;
-
-  // TODO: limit to folder!
-  nsresult rv = DB().AllThreads(threadIDs);
+  nsresult rv = DB().FetchFolderThreads(mFolderID, threadIDs);
   NS_ENSURE_SUCCESS(rv, rv);
   RefPtr<ThreadEnumerator> e = new ThreadEnumerator(this, threadIDs);
   e.forget(result);
   return NS_OK;
 }
 
 // Helper fn for nsMsgThread2
 // TODO: is parentKey root message of thread? Or any message?
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -498,32 +498,59 @@ NS_IMETHODIMP nsMsgHdr2::GetIsKilled(boo
   *isKilled = false;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetStringProperty(char const* name,
                                            char const* value) {
   nsDependentCString n(name);
   nsDependentCString v(value);
-  // storeToken is part of the permanent schema.
+  // These special cases should be made part of the nsIMsgDBHdr interface.
   if (n.EqualsLiteral("storeToken")) {
     // printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
     return DB().SetMsgStoreToken(mKey, v);
   }
+  if (n.EqualsLiteral("keywords")) {
+    // printf("XYZZY: SetStringProperty(%s, %s)\n", name, value);
+    return DB().SetMsgKeywords(mKey, v);
+  }
+  if (n.EqualsLiteral("imageSize")) {
+    // I don't think imageSize is actually used anywhere.
+    // It's set to "1" msgMail3PaneWindow.js if an imap message has
+    // an "X-image-size" header.
+    // It's read in nsMsgDBView::GetCellProperties(), and used to
+    // add a "hasimage" property to the cell, which doesn't seem to be
+    // used anywhere.
+    // So... we shall quietly ignore it!
+    return NS_OK;
+  }
+  if (n.EqualsLiteral("junkscore")) {
+    nsresult rv;
+    int64_t i = v.ToInteger64(&rv);
+    return DB().SetMsgJunkscore(mKey, (uint32_t)i);
+  }
 
   return DB().MsgSetProperty(mKey, n, v);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetStringProperty(char const* name, char** value) {
   nsDependentCString n(name);
   nsAutoCString tmp;
   nsresult rv = NS_OK;
   // storeToken is part of the permanent schema.
   if (n.EqualsLiteral("storeToken")) {
     rv = DB().FetchMsgStoreToken(mKey, tmp);
+  } else if (n.EqualsLiteral("keywords")) {
+    rv = DB().FetchMsgKeywords(mKey, tmp);
+  } else if (n.EqualsLiteral("junkscore")) {
+    uint32_t junkscore;
+    rv = DB().FetchMsgJunkscore(mKey, &junkscore);
+    tmp.AppendInt(junkscore);
+  } else if (n.EqualsLiteral("imageSize")) {
+    // See note in GetStringProperty(). Return empty string.
   } else {
     rv = DB().MsgGetProperty(mKey, n, tmp);
   }
   *value = moz_xstrdup(tmp.get());
   return rv;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetUint32Property(char const* name,
diff --git a/mailnews/db/msgdb/src/nsMsgThread2.cpp b/mailnews/db/msgdb/src/nsMsgThread2.cpp
--- a/mailnews/db/msgdb/src/nsMsgThread2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgThread2.cpp
@@ -162,17 +162,17 @@ NS_IMETHODIMP nsMsgThread2::MarkChildRea
 }
 
 NS_IMETHODIMP nsMsgThread2::EnumerateMessages(nsMsgKey parentKey,
                                               nsIMsgEnumerator** result) {
   printf("XYZZY [threadID=%d] nsMsgThread2::EnumerateMessages(parentKey=%d)\n",
          mThreadID, (int)parentKey);
 
   nsTArray<nsMsgKey> childKeys;
-  nsresult rv = DB().ThreadChildren(parentKey, childKeys);
+  nsresult rv = DB().FetchMsgChildren(parentKey, childKeys);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (parentKey == nsMsgKey_None) {
     parentKey = mThreadID;
   }
   printf(" -> %d messages to enumerate\n", (int)childKeys.Length());
   NS_ADDREF(*result = new ChildEnumerator(mFolderDB, childKeys));
   return NS_OK;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1671757838 -46800
#      Fri Dec 23 14:10:38 2022 +1300
# Node ID 5278bd11d01e067c6b0c43fb368858925ef9511c
# Parent  dada94158a1486976fc3059f417c1386f98ba037
WIP: add some indexes to various columns

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -4,17 +4,17 @@
 #include "mozilla/intl/Collator.h"
 #include "mozilla/intl/LocaleService.h"
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
-#include "nsMsgEnumerator.h"
+// #include "nsMsgEnumerator.h"
 #include "nsWhitespaceTokenizer.h"
 
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
@@ -142,31 +142,41 @@ nsresult GlobalDB::InitSchema() {
         "xGmLabels TEXT NOT NULL DEFAULT '', "
         "pseudoHdr INTEGER NOT NULL DEFAULT 0, "  // KILL KILL KILL!
         "enigmail INTEGER NOT NULL DEFAULT 0, "
         "notAPhishMessage INTEGER NOT NULL DEFAULT 0 "
         ")");
     rv = mConn->ExecuteSimpleSQL(create_msg);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    const nsLiteralCString create_idx_msg_messageid(
+        "CREATE INDEX idx_msg_messageid ON msg(messageID)");
+    rv = mConn->ExecuteSimpleSQL(create_idx_msg_messageid);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     const nsLiteralCString create_folder(
         "CREATE TABLE folder ( "
         "uri TEXT NOT NULL DEFAULT '' "
         ")");
     rv = mConn->ExecuteSimpleSQL(create_folder);
     NS_ENSURE_SUCCESS(rv, rv);
 
     const nsLiteralCString create_msg_folder(
         "CREATE TABLE msg_folder ( "
         "msg_id INTEGER NOT NULL, "
         "folder_id INTEGER NOT NULL "
         ")");
     rv = mConn->ExecuteSimpleSQL(create_msg_folder);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    const nsLiteralCString create_idx_msg_folder_folder_id(
+        "CREATE INDEX idx_msg_folder_folder_id ON msg_folder(folder_id)");
+    rv = mConn->ExecuteSimpleSQL(create_idx_msg_folder_folder_id);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     // Generic message properties table (ugh).
     const nsLiteralCString create_msg_prop(
         "CREATE TABLE msg_prop ( "
         "msg_id INTEGER NOT NULL, "
         "name TEXT NOT NULL, "
         "value TEXT NOT NULL, "
         "UNIQUE (msg_id, name)"
         ")");
@@ -190,16 +200,31 @@ nsresult GlobalDB::InitSchema() {
         "msg INTEGER NOT NULL, "
         "parent INTEGER, "           // null = root
         "thread INTEGER NOT NULL, "  // root msgkey
         "depth INTEGER NOT NULL "    // 0=root (implies threadID==msg)
         ")");
     rv = mConn->ExecuteSimpleSQL(create_msg_thread);
     NS_ENSURE_SUCCESS(rv, rv);
 
+    const nsLiteralCString create_idx_msg_thread_msg(
+        "CREATE INDEX idx_msg_thread_msg ON msg_thread(msg)");
+    rv = mConn->ExecuteSimpleSQL(create_idx_msg_thread_msg);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    const nsLiteralCString create_idx_msg_thread_thread(
+        "CREATE INDEX idx_msg_thread_thread ON msg_thread(thread)");
+    rv = mConn->ExecuteSimpleSQL(create_idx_msg_thread_thread);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    const nsLiteralCString create_idx_msg_thread_parent(
+        "CREATE INDEX idx_msg_thread_parent ON msg_thread(parent)");
+    rv = mConn->ExecuteSimpleSQL(create_idx_msg_thread_parent);
+    NS_ENSURE_SUCCESS(rv, rv);
+
   } else {
     // Migrations go here...
   }
 
   rv = mConn->SetSchemaVersion(latestSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return NS_OK;
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1682484628 -43200
#      Wed Apr 26 16:50:28 2023 +1200
# Node ID 9b85001327e9329675a4818562c55787f3e4b2d4
# Parent  5278bd11d01e067c6b0c43fb368858925ef9511c
bitrot fixups

diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -1028,17 +1028,17 @@ nsresult nsMsgDatabase2::DumpContents() 
     nsCOMPtr<nsIMsgDBHdr> msgHdr;
     rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
     if (NS_SUCCEEDED(rv)) {
       nsCString author;
       nsCString subject;
 
       msgHdr->GetMessageKey(&key);
       msgHdr->GetAuthor(getter_Copies(author));
-      msgHdr->GetSubject(getter_Copies(subject));
+      msgHdr->GetSubject(subject);
       printf("hdr key = %u, author = %s subject = %s\n", key, author.get(),
              subject.get());
     }
   }
 #  if 0
   nsCOMPtr<nsIMsgThreadEnumerator> threads;
   rv = EnumerateThreads(getter_AddRefs(threads));
   NS_ENSURE_SUCCESS(rv, rv);
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -165,18 +165,18 @@ NS_IMETHODIMP nsMsgHdr2::SetMessageId(co
     nsAutoCString tempMessageID(messageID + 1);
     if (tempMessageID.CharAt(tempMessageID.Length() - 1) == '>')
       tempMessageID.SetLength(tempMessageID.Length() - 1);
     return DB().SetMsgMessageID(mKey, tempMessageID);
   }
   return DB().SetMsgMessageID(mKey, nsDependentCString(messageID));
 }
 
-NS_IMETHODIMP nsMsgHdr2::SetSubject(const char* subject) {
-  return DB().SetMsgSubject(mKey, nsDependentCString(subject));
+NS_IMETHODIMP nsMsgHdr2::SetSubject(const nsACString& subject) {
+  return DB().SetMsgSubject(mKey, subject);
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetAuthor(const char* author) {
   return DB().SetMsgSender(mKey, nsDependentCString(author));
 }
 
 NS_IMETHODIMP nsMsgHdr2::SetReferences(const nsACString& references) {
   m_references.Clear();
@@ -281,23 +281,18 @@ NS_IMETHODIMP nsMsgHdr2::GetLineCount(ui
 
 NS_IMETHODIMP nsMsgHdr2::GetAuthor(char** sender) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgSender(mKey, tmp);
   *sender = moz_xstrdup(tmp.get());
   return rv;
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetSubject(char** subject) {
-  nsAutoCString tmp;
-  nsresult rv = DB().FetchMsgSubject(mKey, tmp);
-  *subject = moz_xstrdup(tmp.get());
-  // printf("XYZZY: [key=%d] nsMsgHdr2::GetSubject() => '%s'\n", (int)mKey,
-  //        *subject);
-  return rv;
+NS_IMETHODIMP nsMsgHdr2::GetSubject(nsACString& subject) {
+  return DB().FetchMsgSubject(mKey, subject);
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetRecipients(char** recipients) {
   nsAutoCString tmp;
   nsresult rv = DB().FetchMsgRecipients(mKey, tmp);
   *recipients = moz_xstrdup(tmp.get());
   return rv;
 }
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1683098772 -43200
#      Wed May 03 19:26:12 2023 +1200
# Node ID 786b5f831b322246f83cb1638df26cadba7b5487
# Parent  9b85001327e9329675a4818562c55787f3e4b2d4
Fix up per-msg property access. sigh.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -1340,16 +1340,76 @@ nsresult GlobalDB::FolderGetProperty(nsF
   if (!exists) {
     return NS_OK;
   }
   return stmt->GetUTF8String(0, value);
 }
 
 nsresult GlobalDB::MsgSetProperty(nsMsgKey key, nsACString const& name,
                                   nsACString const& value) {
+  if (name.EqualsLiteral("storeToken")) {
+    return SetMsgStoreToken(key, value);
+  } else if (name.EqualsLiteral("flags")) {
+    nsresult rv;
+    uint32_t flags = value.ToInteger(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgFlags(key, flags);
+  } else if (name.EqualsLiteral("sender")) {
+    return SetMsgSender(key, value);
+  } else if (name.EqualsLiteral("recipients")) {
+    return SetMsgRecipients(key, value);
+  } else if (name.EqualsLiteral("ccList")) {
+    return SetMsgCCList(key, value);
+  } else if (name.EqualsLiteral("bccList")) {  // TODO: unconfirmed name
+    return SetMsgBCCList(key, value);
+  } else if (name.EqualsLiteral("subject")) {
+    return SetMsgSubject(key, value);
+  } else if (name.EqualsLiteral("message-id")) {
+    return SetMsgMessageID(key, value);
+  } else if (name.EqualsLiteral("account")) {
+    return SetMsgAccountKey(key, value);
+  } else if (name.EqualsLiteral("references")) {
+    return SetMsgReferences(key, value);
+  } else if (name.EqualsLiteral("keywords")) {
+    return SetMsgKeywords(key, value);
+  } else if (name.EqualsLiteral("size")) {
+    nsresult rv;
+    uint64_t s = value.ToInteger64(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgSize(key, s);
+  } else if (name.EqualsLiteral("offlineSize")) {
+    nsresult rv;
+    uint64_t s = value.ToInteger64(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgOfflineSize(key, s);
+  } else if (name.EqualsLiteral("threadParent")) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  } else if (name.EqualsLiteral("msgThreadID")) {
+    return NS_ERROR_NOT_IMPLEMENTED;
+  } else if (name.EqualsLiteral("date")) {
+    nsresult rv;
+    uint32_t secs = value.ToInteger(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgDate(key, secs);
+  } else if (name.EqualsLiteral("numLines")) {
+    nsresult rv;
+    uint32_t n = value.ToInteger(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgLineCount(key, n);
+  } else if (name.EqualsLiteral("priority")) {
+    nsresult rv;
+    nsMsgPriorityValue pri = value.ToInteger(&rv);
+    NS_ENSURE_SUCCESS(rv, rv);
+    return SetMsgPriority(key, pri);
+  }
+  // TODO: these are not handled, but maybe should be?
+  // "msgOffset", "dateReceived", "msgCharSet", "ProtoThreadFlags"
+
+  // If we get this far, treat it as a 'soft' property.
+
   // oooh, an UPSERT!
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO msg_prop (msg_id, name, value) VALUES(:msgKey, :name, "
       ":value) ON CONFLICT(msg_id, name) DO UPDATE SET value=excluded.value;");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
@@ -1363,23 +1423,95 @@ nsresult GlobalDB::MsgSetProperty(nsMsgK
 
   // Invalidate cache
   mMsgPropertyCache.remove(MsgPropPair(key, name));
   return NS_OK;
 }
 
 nsresult GlobalDB::MsgGetProperty(nsMsgKey key, nsACString const& name,
                                   nsACString& value) {
+  if (name.EqualsLiteral("storeToken")) {
+    return FetchMsgStoreToken(key, value);
+  } else if (name.EqualsLiteral("flags")) {
+    uint32_t flags;
+    nsresult rv = FetchMsgFlags(key, &flags);
+    value.Truncate();
+    value.AppendInt(flags);
+    return rv;
+  } else if (name.EqualsLiteral("sender")) {
+    return FetchMsgSender(key, value);
+  } else if (name.EqualsLiteral("recipients")) {
+    return FetchMsgRecipients(key, value);
+  } else if (name.EqualsLiteral("ccList")) {
+    return FetchMsgCCList(key, value);
+  } else if (name.EqualsLiteral("bccList")) {  // TODO: unconfirmed name
+    return FetchMsgBCCList(key, value);
+  } else if (name.EqualsLiteral("subject")) {
+    return FetchMsgSubject(key, value);
+  } else if (name.EqualsLiteral("message-id")) {
+    return FetchMsgMessageID(key, value);
+  } else if (name.EqualsLiteral("account")) {
+    return FetchMsgAccountKey(key, value);
+  } else if (name.EqualsLiteral("references")) {
+    return FetchMsgReferences(key, value);
+  } else if (name.EqualsLiteral("keywords")) {
+    return FetchMsgKeywords(key, value);
+  } else if (name.EqualsLiteral("size")) {
+    uint64_t s;
+    nsresult rv = FetchMsgSize(key, &s);
+    value.Truncate();
+    value.AppendInt(s);
+    return rv;
+  } else if (name.EqualsLiteral("offlineSize")) {
+    uint64_t s;
+    nsresult rv = FetchMsgOfflineSize(key, &s);
+    value.Truncate();
+    value.AppendInt(s);
+    return rv;
+  } else if (name.EqualsLiteral("threadParent")) {
+    nsMsgKey parentKey;
+    nsresult rv = FetchMsgThreadParent(key, &parentKey);
+    value.Truncate();
+    value.AppendInt(parentKey);
+    return rv;
+  } else if (name.EqualsLiteral("msgThreadID")) {
+    nsMsgKey threadID;
+    nsresult rv = FetchMsgThreadID(key, &threadID);
+    value.Truncate();
+    value.AppendInt(threadID);
+    return rv;
+  } else if (name.EqualsLiteral("date")) {
+    uint32_t secs;
+    nsresult rv = FetchMsgDate(key, &secs);
+    value.Truncate();
+    value.AppendInt(secs);
+    return rv;
+  } else if (name.EqualsLiteral("numLines")) {
+    uint32_t n;
+    nsresult rv = FetchMsgLineCount(key, &n);
+    value.Truncate();
+    value.AppendInt(n);
+    return rv;
+  } else if (name.EqualsLiteral("priority")) {
+    nsMsgPriorityValue pri;
+    nsresult rv = FetchMsgPriority(key, &pri);
+    value.Truncate();
+    value.AppendInt((int32_t)pri);
+    return rv;
+  }
+  // TODO: these are not handled, but maybe should be?
+  // "msgOffset", "dateReceived", "msgCharSet", "ProtoThreadFlags"
+
+  // If we get this far, treat it as a 'soft' property.
+
   if (auto p = mMsgPropertyCache.lookup(MsgPropPair(key, name))) {
     value = p->value();
     return NS_OK;
   }
 
-  printf("XYZZY GlobalDB::MsgGetProperty(msgKey=%d '%s')\n", (int)key,
-         nsPromiseFlatCString(name).get());
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT value FROM msg_prop WHERE msg_id=:msgKey AND name=:name");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindUTF8StringByName("name"_ns, name);
@@ -1395,16 +1527,55 @@ nsresult GlobalDB::MsgGetProperty(nsMsgK
   }
 
   // Cache it
   NS_ENSURE_TRUE(mMsgPropertyCache.putNew(MsgPropPair(key, name), value),
                  NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
+nsresult GlobalDB::MsgPropertyNames(nsMsgKey key,
+                                    nsTArray<nsCString>& propNames) {
+  nsTArray<nsTString<char>> builtIns({
+      "msgOffset"_ns, "storeToken"_ns, "flags"_ns, "sender"_ns, "recipients"_ns,
+      "ccList"_ns, "subject"_ns, "message-id"_ns, "account"_ns, "references"_ns,
+      "date"_ns, "priority"_ns, "keywords"_ns, "size"_ns, "offlineSize"_ns,
+      "numLines"_ns, "threadParent"_ns, "msgThreadId"_ns,
+      // TODO?
+      //  "dateReceived"_ns,
+      //  "msgCharSet"_ns,
+      //  "ProtoThreadFlags"_ns,
+  });
+
+  // Start with inherent properties, then query for additional 'soft' ones.
+  propNames = builtIns.Clone();
+
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("SELECT DISTINCT name FROM msg_prop WHERE msg_id=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv;
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  while (1) {
+    bool exists;
+    rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    nsAutoCString tmp;
+    rv = stmt->GetUTF8String(0, tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    propNames.AppendElement(tmp);
+  }
+  return NS_OK;
+}
+
 // Returns nsMsgKey_None if none found.
 nsresult GlobalDB::FindMsgByMessageID(nsACString const& messageID,
                                       nsMsgKey* msgKey) {
   printf("XYZZY GlobalDB::FindMsgByMessageID(%s)\n",
          nsPromiseFlatCString(messageID).get());
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT rowid FROM msg WHERE messageID=:messageID");
   NS_ENSURE_STATE(stmt);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -175,23 +175,28 @@ class GlobalDB {
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
   // Icky random-property stuff on folder and message.
   nsresult FolderSetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString const& value);
   nsresult FolderGetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString& value);
+  // These properties access the core per-message fields (subject, sender,
+  // etc...), but also allow _any_ field to be tacked onto a message.
+  // We need to get a handle on this and enforce a proper schema.
+  // Would be nice to ditch these entirely (and maybe replace them with
+  // a mechanism for addons to attach their own metadata to messages?)
   nsresult MsgSetProperty(nsMsgKey key, nsACString const& name,
                           nsACString const& value);
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
+  nsresult MsgPropertyNames(nsMsgKey key, nsTArray<nsCString>& propNames);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
-
   nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   // Thread stuff.
 
   // Return key of message with matching messageID.
   // Returns nsMsgKey_None if not found.
   nsresult FindMsgByMessageID(nsACString const& messageID, nsMsgKey* msgKey);
 
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -569,12 +569,35 @@ NS_IMETHODIMP nsMsgHdr2::GetUint32Proper
 
 NS_IMETHODIMP nsMsgHdr2::SetUint32Property(char const* name,
                                            unsigned int value) {
   nsAutoCString s;
   s.AppendInt(value);
   return DB().MsgSetProperty(mKey, nsDependentCString(name), s);
 }
 
-NS_IMETHODIMP nsMsgHdr2::GetProperties(nsTArray<nsTString<char>>&) {
-  printf("XYZZY: NOT IMPLEMENTED nsMsgHdr2::GetProperties()\n");
-  return NS_ERROR_NOT_IMPLEMENTED;
+// according to comm/mailnews/db/msgdb/test/unit/test_propertyEnumerator.js
+/*
+msgOffset
+storeToken
+flags
+sender
+recipients
+ccList
+subject
+message-id
+account
+references
+dateReceived
+date
+priority
+keywords
+msgCharSet
+size
+numLines
+threadParent
+msgThreadId
+ProtoThreadFlags
+*/
+
+NS_IMETHODIMP nsMsgHdr2::GetProperties(nsTArray<nsCString>& propNames) {
+  return DB().MsgPropertyNames(mKey, propNames);
 }
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1683246705 -43200
#      Fri May 05 12:31:45 2023 +1200
# Node ID ad35cdb9e8b7962de7f36c8b4c5b11ad01acf5db
# Parent  786b5f831b322246f83cb1638df26cadba7b5487
handle msg delete (and undo)

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -333,41 +333,57 @@ nsresult GlobalDB::StashMsg(RawHdr const
   int64_t rowid;
   rv = mConn->GetLastInsertRowID(&rowid);
   NS_ENSURE_SUCCESS(rv, rv);
   *newKey = (nsMsgKey)rowid;
   printf("XYZZY: StashMsg() - new msg %d\n", *newKey);
   return NS_OK;
 }
 
-nsresult GlobalDB::AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID) {
+nsresult GlobalDB::FolderAddMsg(nsFolderKey folderID, nsMsgKey msgKey) {
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO msg_folder (msg_id, folder_id) VALUES (:msgID, :folderID)");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("msgID"_ns, (int64_t)msgKey);
   if (NS_FAILED(rv)) return rv;
   rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
   if (NS_FAILED(rv)) return rv;
   rv = stmt->Execute();
   if (NS_FAILED(rv)) return rv;
   return NS_OK;
 }
 
+nsresult GlobalDB::FolderRemoveMsg(nsFolderKey folderID, nsMsgKey msgKey) {
+  printf("XYZZY GlobalDB::FolderRemoveMsg(folderID=%d msgKey=%d)\n",
+         (int)folderID, (int)msgKey);
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "DELETE FROM msg_folder WHERE msg_id=:msgID AND folder_id=:folderID");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("msgID"_ns, (int64_t)msgKey);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
+  if (NS_FAILED(rv)) return rv;
+  rv = stmt->Execute();
+  if (NS_FAILED(rv)) return rv;
+  return NS_OK;
+}
+
 nsresult GlobalDB::StashMsgs(nsTArray<RawHdr> const& msgs,
                              nsFolderKey folderID) {
   mozStorageTransaction transaction(mConn, false);
   nsresult rv = transaction.Start();
   NS_ENSURE_SUCCESS(rv, rv);
   for (RawHdr const& msg : msgs) {
     nsMsgKey newKey;
     rv = StashMsg(msg, &newKey);
     NS_ENSURE_SUCCESS(rv, rv);
 
-    rv = AddMsgToFolder(newKey, folderID);
+    rv = FolderAddMsg(folderID, newKey);
     NS_ENSURE_SUCCESS(rv, rv);
   }
   return transaction.Commit();
 }
 
 nsCString GlobalDB::LastErr() {
   nsCString err;
   mConn->GetLastErrorString(err);
@@ -1195,26 +1211,16 @@ nsresult GlobalDB::FolderContainsKey(nsF
   rv = stmt->ExecuteStep(containsKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   NS_ENSURE_TRUE(mFolderContainsKeyCache.put(FolderMsgPair{folderID, key}),
                  NS_ERROR_OUT_OF_MEMORY);
   return NS_OK;
 }
 
-nsresult GlobalDB::FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
-                                      nsIDBChangeListener* instigator,
-                                      bool commit, bool notify) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
-nsresult GlobalDB::FolderUndoDelete(nsFolderKey folderID, nsMsgKey key) {
-  return NS_ERROR_NOT_IMPLEMENTED;
-}
-
 nsresult GlobalDB::FolderListAllKeys(nsFolderKey folderID,
                                      nsTArray<nsMsgKey>& keys) {
   printf("XYZZY GlobalDB::FolderListAllKeys(folderID=%d)\n", (int)folderID);
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("SELECT msg_id FROM msg_folder WHERE folder_id=:folderKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderID);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -162,21 +162,18 @@ class GlobalDB {
 
   // Find a folderID, given a URI. Create folder if it doesn't already exist.
   nsresult FolderFindOrCreate(nsACString const& folderURI,
                               nsFolderKey* folderID);
 
   // Ones to evalutate:
   nsresult FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                              bool* containsKey);
-  nsresult FolderDeleteHeader(nsFolderKey folderID, nsMsgKey key,
-                              nsIDBChangeListener* instigator, bool commit,
-                              bool notify);
-
-  nsresult FolderUndoDelete(nsFolderKey folderID, nsMsgKey key);
+  nsresult FolderAddMsg(nsFolderKey folderID, nsMsgKey msgKey);
+  nsresult FolderRemoveMsg(nsFolderKey folderID, nsMsgKey msgKey);
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
   // Icky random-property stuff on folder and message.
   nsresult FolderSetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString const& value);
   nsresult FolderGetProperty(nsFolderKey folderID, nsACString const& name,
                              nsACString& value);
@@ -187,17 +184,16 @@ class GlobalDB {
   // a mechanism for addons to attach their own metadata to messages?)
   nsresult MsgSetProperty(nsMsgKey key, nsACString const& name,
                           nsACString const& value);
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
   nsresult MsgPropertyNames(nsMsgKey key, nsTArray<nsCString>& propNames);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
-  nsresult AddMsgToFolder(nsMsgKey msgKey, nsFolderKey folderID);
 
   // Thread stuff.
 
   // Return key of message with matching messageID.
   // Returns nsMsgKey_None if not found.
   nsresult FindMsgByMessageID(nsACString const& messageID, nsMsgKey* msgKey);
 
   // Return all direct children of parentKey.
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -347,16 +347,22 @@ NS_IMETHODIMP nsMsgDatabase2::DeleteMess
   rv = DeleteHeader(msgHdr, instigator, commit, true);
   return rv;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::DeleteMessages(
     nsTArray<nsMsgKey> const& nsMsgKeys, nsIDBChangeListener* instigator) {
   nsresult err = NS_OK;
 
+  printf("XYZZY: nsMsgDatabase2::DeleteMessages({");
+  for (auto k : nsMsgKeys) {
+    printf("%d,", (int)k);
+  }
+  printf("});\n");
+
   uint32_t kindex;
   for (kindex = 0; kindex < nsMsgKeys.Length(); kindex++) {
     nsMsgKey key = nsMsgKeys[kindex];
     nsCOMPtr<nsIMsgDBHdr> msgHdr;
 
     bool hasKey;
 
     if (NS_SUCCEEDED(ContainsKey(key, &hasKey)) && hasKey) {
@@ -368,32 +374,71 @@ NS_IMETHODIMP nsMsgDatabase2::DeleteMess
       if (msgHdr)
         err = DeleteHeader(msgHdr, instigator, kindex % 300 == 0, true);
       if (NS_FAILED(err)) break;
     }
   }
   return err;
 }
 
+// TODO: commit not needed
 NS_IMETHODIMP nsMsgDatabase2::DeleteHeader(nsIMsgDBHdr* msg,
                                            nsIDBChangeListener* instigator,
                                            bool commit, bool notify) {
   nsMsgKey key;
   nsresult rv = msg->GetMessageKey(&key);
   NS_ENSURE_SUCCESS(rv, rv);
-  return DB().FolderDeleteHeader(mFolderID, key, instigator, commit, notify);
+
+  // TODO: old code set expunged flag...
+  // SetHdrFlag(msg, true, nsMsgMessageFlags::Expunged);
+
+  if (m_dbFolderInfo) {
+    m_dbFolderInfo->ChangeNumMessages(-1);
+    bool isRead;
+    rv = DB().FetchMsgIsRead(key, &isRead);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!isRead) {
+      m_dbFolderInfo->ChangeNumUnreadMessages(-1);
+    }
+
+    uint64_t msgSize;
+    rv = DB().FetchMsgSize(key, &msgSize);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = m_dbFolderInfo->ChangeExpungedBytes(msgSize);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+
+  if (notify) {
+    uint32_t flags;
+    nsMsgKey threadParent;
+    (void)msg->GetFlags(&flags);
+    msg->GetThreadParent(&threadParent);
+
+    // TODO? INVESTIGATE
+    // If deleted hdr was new, restore the new flag on flags
+    // so saved searches will know to reduce their new msg count.
+    // bool hdrWasNew = m_newSet.BinaryIndexOf(key) != m_newSet.NoIndex;
+    // if (hdrWasNew) flags |= nsMsgMessageFlags::New;
+
+    NotifyHdrDeletedAll(msg, threadParent, flags,
+                        instigator);  // tell listeners
+  }
+
+  // Detach the message from the folder.
+  return DB().FolderRemoveMsg(mFolderID, key);
 }
 
 NS_IMETHODIMP nsMsgDatabase2::UndoDelete(nsIMsgDBHdr* aMsgHdr) {
   nsMsgKey key;
   nsresult rv = aMsgHdr->GetMessageKey(&key);
   NS_ENSURE_SUCCESS(rv, rv);
-  return DB().FolderUndoDelete(mFolderID, key);
+  return DB().FolderAddMsg(mFolderID, key);
 }
 
+// TODO: Is this the _real_ delete?
 NS_IMETHODIMP nsMsgDatabase2::RemoveHeaderMdbRow(nsIMsgDBHdr* msg) {
   // TODO
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::IsRead(nsMsgKey key, bool* isRead) {
   return DB().FetchMsgIsRead(key, isRead);
 }
@@ -805,21 +850,22 @@ nsMsgDatabase2::SyncCounts() {
  * TODO: this needs some proper sorting out.
  */
 NS_IMETHODIMP nsMsgDatabase2::CreateNewHdr(nsMsgKey key, nsIMsgDBHdr** result) {
   NS_ENSURE_ARG_POINTER(result);
 
   // printf("XYZZY: CreateNewHdr(key=%d)\n", (int)key);
 
   MOZ_ASSERT(key == nsMsgKey_None);
-  // TODO: ++elegance;
   RawHdr blank;
+  // Create an (empty!) message. Ugh!
   nsresult rv = DB().StashMsg(blank, &key);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = DB().AddMsgToFolder(key, mFolderID);
+  // Associate it with the folder.
+  rv = DB().FolderAddMsg(mFolderID, key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(result);
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1683598959 -43200
#      Tue May 09 14:22:39 2023 +1200
# Node ID dba9430b2f748fda310c0b48722acce1e860e4ab
# Parent  ad35cdb9e8b7962de7f36c8b4c5b11ad01acf5db
Artificially restrict threading to folders for now.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -100,21 +100,19 @@ nsresult GlobalDB::InitSchema() {
 
   if (currentSchemaVersion == latestSchemaVersion) {
     printf("Schema is up to date.\n");
     return NS_OK;  // All up to date.
   }
 
   if (currentSchemaVersion == 0) {
     printf("Loading initial schema\n");
-    // NOTES:
-    // - we use the automatic rowid colum as our primary key
-    //   presenting it as nsMsgKey.
     const nsLiteralCString create_msg(
         "CREATE TABLE msg ( "
+        "id INTEGER PRIMARY KEY, "  // (alias for sqlite rowid)
         "messageID TEXT NOT NULL DEFAULT '', "
         "refs TEXT NOT NULL DEFAULT '', "        // REFERENCES is reserved word
         "date INTEGER NOT NULL DEFAULT 0, "      // use proper datetime type?
         "received INTEGER NOT NULL DEFAULT 0, "  // ditto
         "subject TEXT NOT NULL DEFAULT '', "
         "sender TEXT NOT NULL DEFAULT '', "  // (NOTE: FROM is reserved word)
         "recipients TEXT NOT NULL DEFAULT '', "
         "ccList TEXT NOT NULL DEFAULT '', "
@@ -149,16 +147,17 @@ nsresult GlobalDB::InitSchema() {
 
     const nsLiteralCString create_idx_msg_messageid(
         "CREATE INDEX idx_msg_messageid ON msg(messageID)");
     rv = mConn->ExecuteSimpleSQL(create_idx_msg_messageid);
     NS_ENSURE_SUCCESS(rv, rv);
 
     const nsLiteralCString create_folder(
         "CREATE TABLE folder ( "
+        "id INTEGER PRIMARY KEY, "  // (alias for sqlite rowid)
         "uri TEXT NOT NULL DEFAULT '' "
         ")");
     rv = mConn->ExecuteSimpleSQL(create_folder);
     NS_ENSURE_SUCCESS(rv, rv);
 
     const nsLiteralCString create_msg_folder(
         "CREATE TABLE msg_folder ( "
         "msg_id INTEGER NOT NULL, "
@@ -325,20 +324,20 @@ nsresult GlobalDB::StashMsg(RawHdr const
   rv = stmt->BindInt32ByName("notAPhishMessage"_ns, msg.notAPhishMessage);
   if (NS_FAILED(rv)) return rv;
 
   rv = stmt->Execute();
   if (NS_FAILED(rv)) {
     return rv;
   }
 
-  int64_t rowid;
-  rv = mConn->GetLastInsertRowID(&rowid);
+  int64_t id;
+  rv = mConn->GetLastInsertRowID(&id);
   NS_ENSURE_SUCCESS(rv, rv);
-  *newKey = (nsMsgKey)rowid;
+  *newKey = (nsMsgKey)id;
   printf("XYZZY: StashMsg() - new msg %d\n", *newKey);
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderAddMsg(nsFolderKey folderID, nsMsgKey msgKey) {
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "INSERT INTO msg_folder (msg_id, folder_id) VALUES (:msgID, :folderID)");
   NS_ENSURE_STATE(stmt);
@@ -413,20 +412,20 @@ already_AddRefed<mozIStorageStatement> G
 
 // private helper
 nsresult GlobalDB::FetchMsg(nsMsgKey key, CachedHdr& hdr) {
   printf("XYZZY GlobalDB::FetchMsg(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT messageID, refs, date, subject, sender, sender, "
       "recipients, ccList, bccList, flags, msgSize, storeToken, "
       "offlineMsgSize, numLines, junkscore, keywords FROM msg "
-      "WHERE rowid=:rowid");
+      "WHERE id=:id");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  nsresult rv = stmt->BindInt64ByName("id"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
 
   // Unmarshall row into CachedHdr struct
@@ -659,20 +658,20 @@ nsresult GlobalDB::FetchMsgThreadParent(
   *parentKey = (nsMsgKey)tmp;
   return NS_OK;
 }
 
 nsresult GlobalDB::FetchMsgPriority(nsMsgKey key,
                                     nsMsgPriorityValue* priority) {
   printf("XYZZY GlobalDB::FetchMsgPriority(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT priority FROM msg WHERE rowid=:rowid");
+      Stmt("SELECT priority FROM msg WHERE id=:id");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
-  nsresult rv = stmt->BindInt64ByName("rowid"_ns, (int64_t)key);
+  nsresult rv = stmt->BindInt64ByName("id"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   NS_ENSURE_TRUE(exists, NS_MSG_MESSAGE_NOT_FOUND);
   return stmt->GetInt32(0, (int32_t*)priority);
 }
 
@@ -769,17 +768,17 @@ nsresult GlobalDB::CreateCollationKey(co
   }
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgFlags(nsMsgKey key, uint32_t flags) {
   MOZ_ASSERT(flags < INT32_MAX);
   // Update the DB.
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET flags=:flags WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET flags=:flags WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("flags"_ns, (int32_t)flags);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -789,17 +788,17 @@ nsresult GlobalDB::SetMsgFlags(nsMsgKey 
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->flags = flags;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET messageID=:messageID WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET messageID=:messageID WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -810,17 +809,17 @@ nsresult GlobalDB::SetMsgMessageID(nsMsg
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->messageID = messageID;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgReferences(nsMsgKey key,
                                     nsACString const& references) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET refs=:refs WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET refs=:refs WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("refs"_ns, references);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -830,17 +829,17 @@ nsresult GlobalDB::SetMsgReferences(nsMs
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->references = references;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSender(nsMsgKey key, nsACString const& sender) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET sender=:sender WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET sender=:sender WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("sender"_ns, sender);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -850,17 +849,17 @@ nsresult GlobalDB::SetMsgSender(nsMsgKey
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->sender = sender;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSubject(nsMsgKey key, nsACString const& subject) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET subject=:subject WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET subject=:subject WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("subject"_ns, subject);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -871,17 +870,17 @@ nsresult GlobalDB::SetMsgSubject(nsMsgKe
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->subject = subject;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgRecipients(nsMsgKey key,
                                     nsACString const& recipients) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET recipients=:recipients WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET recipients=:recipients WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("recipients"_ns, recipients);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -891,17 +890,17 @@ nsresult GlobalDB::SetMsgRecipients(nsMs
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->recipients = recipients;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgCCList(nsMsgKey key, nsACString const& ccList) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET ccList=:ccList WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET ccList=:ccList WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("ccList"_ns, ccList);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -911,17 +910,17 @@ nsresult GlobalDB::SetMsgCCList(nsMsgKey
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->ccList = ccList;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgBCCList(nsMsgKey key, nsACString const& bccList) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET bccList=:bccList WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET bccList=:bccList WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("bccList"_ns, bccList);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -932,17 +931,17 @@ nsresult GlobalDB::SetMsgBCCList(nsMsgKe
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->bccList = bccList;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgSize(nsMsgKey key, uint64_t msgSize) {
   MOZ_ASSERT(msgSize < INT64_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET msgSize=:msgSize WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET msgSize=:msgSize WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("msgSize"_ns, (int64_t)msgSize);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -953,17 +952,17 @@ nsresult GlobalDB::SetMsgSize(nsMsgKey k
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->size = msgSize;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgOfflineSize(nsMsgKey key, uint64_t offlineMsgSize) {
   MOZ_ASSERT(offlineMsgSize < INT64_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET offlineMsgSize=:offlineMsgSize WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET offlineMsgSize=:offlineMsgSize WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv =
       stmt->BindInt64ByName("offlineMsgSize"_ns, (int64_t)offlineMsgSize);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
@@ -975,17 +974,17 @@ nsresult GlobalDB::SetMsgOfflineSize(nsM
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->offlineSize = offlineMsgSize;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgLineCount(nsMsgKey key, uint32_t lineCount) {
   MOZ_ASSERT(lineCount < INT32_MAX);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET numLines=:lineCount WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET numLines=:lineCount WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("lineCount"_ns, (int32_t)lineCount);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -998,17 +997,17 @@ nsresult GlobalDB::SetMsgLineCount(nsMsg
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgDate(nsMsgKey key, uint32_t seconds) {
   //  MOZ_ASSERT(seconds < INT32_MAX);  // This was triggering...
   //  printf("XYZZY SetMsgDate(key=%d seconds=0x%" PRIx32 ")\n", (int)key,
   //  seconds);
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET date=:seconds WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET date=:seconds WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt32ByName("seconds"_ns, (int32_t)seconds);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1032,17 +1031,17 @@ nsresult GlobalDB::SetMsgPriority(nsMsgK
 nsresult GlobalDB::SetMsgAccountKey(nsMsgKey key,
                                     nsACString const& accountKey) {
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 nsresult GlobalDB::SetMsgStoreToken(nsMsgKey key,
                                     nsACString const& storeToken) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET storeToken=:storeToken WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET storeToken=:storeToken WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("storeToken"_ns, storeToken);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1052,17 +1051,17 @@ nsresult GlobalDB::SetMsgStoreToken(nsMs
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->storeToken = storeToken;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgKeywords(nsMsgKey key, nsACString const& keywords) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET keywords=:keywords WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET keywords=:keywords WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("keywords"_ns, keywords);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1072,17 +1071,17 @@ nsresult GlobalDB::SetMsgKeywords(nsMsgK
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->keywords = keywords;
   return NS_OK;
 }
 
 nsresult GlobalDB::SetMsgJunkscore(nsMsgKey key, uint32_t junkscore) {
   nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("UPDATE msg SET junkscore=:junkscore WHERE rowid=:msgKey");
+      Stmt("UPDATE msg SET junkscore=:junkscore WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("junkscore"_ns, (int64_t)junkscore);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->Execute();
   NS_ENSURE_SUCCESS(rv, rv);
@@ -1258,51 +1257,51 @@ nsresult GlobalDB::GetMsgHdrForMessageID
 }
 
 nsresult GlobalDB::FolderFindOrCreate(nsACString const& folderURI,
                                       nsFolderKey* folderID) {
   MOZ_ASSERT(folderID);
 
   {
     nsCOMPtr<mozIStorageStatement> stmt =
-        Stmt("SELECT rowid FROM folder WHERE uri=:uri");
+        Stmt("SELECT id FROM folder WHERE uri=:uri");
     NS_ENSURE_STATE(stmt);
     mozStorageStatementScoper scoper(stmt);
 
     nsresult rv = stmt->BindUTF8StringByName("uri"_ns, folderURI);
     NS_ENSURE_SUCCESS(rv, rv);
 
     bool exists;
     rv = stmt->ExecuteStep(&exists);
     NS_ENSURE_SUCCESS(rv, rv);
     if (exists) {
-      int64_t rowid;
-      rv = stmt->GetInt64(0, &rowid);
+      int64_t id;
+      rv = stmt->GetInt64(0, &id);
       NS_ENSURE_SUCCESS(rv, rv);
-      *folderID = (nsFolderKey)rowid;
+      *folderID = (nsFolderKey)id;
       printf("Found existing folder (key='%d' uri='%s')\n", (int)(*folderID),
              nsPromiseFlatCString(folderURI).get());
       return NS_OK;
     }
   }
 
   // need to create it.
   {
     nsCOMPtr<mozIStorageStatement> stmt =
         Stmt("INSERT INTO folder (uri) VALUES (:uri)");
     NS_ENSURE_STATE(stmt);
     mozStorageStatementScoper scoper(stmt);
     nsresult rv = stmt->BindUTF8StringByName("uri"_ns, folderURI);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = stmt->Execute();
     NS_ENSURE_SUCCESS(rv, rv);
-    int64_t rowid;
-    rv = mConn->GetLastInsertRowID(&rowid);
+    int64_t id;
+    rv = mConn->GetLastInsertRowID(&id);
     NS_ENSURE_SUCCESS(rv, rv);
-    *folderID = (nsFolderKey)rowid;
+    *folderID = (nsFolderKey)id;
     printf("Created Folder (key='%d' uri='%s')\n", (int)(*folderID),
            nsPromiseFlatCString(folderURI).get());
   }
   return NS_OK;
 }
 
 nsresult GlobalDB::FolderSetProperty(nsFolderKey folderID,
                                      nsACString const& name,
@@ -1388,16 +1387,19 @@ nsresult GlobalDB::MsgSetProperty(nsMsgK
     return SetMsgOfflineSize(key, s);
   } else if (name.EqualsLiteral("threadParent")) {
     return NS_ERROR_NOT_IMPLEMENTED;
   } else if (name.EqualsLiteral("msgThreadID")) {
     return NS_ERROR_NOT_IMPLEMENTED;
   } else if (name.EqualsLiteral("date")) {
     nsresult rv;
     uint32_t secs = value.ToInteger(&rv);
+    if (NS_FAILED(rv)) {
+      printf("XYZYY: BAD date '%s'\n", nsPromiseFlatCString(value).get());
+    }
     NS_ENSURE_SUCCESS(rv, rv);
     return SetMsgDate(key, secs);
   } else if (name.EqualsLiteral("numLines")) {
     nsresult rv;
     uint32_t n = value.ToInteger(&rv);
     NS_ENSURE_SUCCESS(rv, rv);
     return SetMsgLineCount(key, n);
   } else if (name.EqualsLiteral("priority")) {
@@ -1573,27 +1575,31 @@ nsresult GlobalDB::MsgPropertyNames(nsMs
     rv = stmt->GetUTF8String(0, tmp);
     NS_ENSURE_SUCCESS(rv, rv);
     propNames.AppendElement(tmp);
   }
   return NS_OK;
 }
 
 // Returns nsMsgKey_None if none found.
-nsresult GlobalDB::FindMsgByMessageID(nsACString const& messageID,
-                                      nsMsgKey* msgKey) {
-  printf("XYZZY GlobalDB::FindMsgByMessageID(%s)\n",
+nsresult GlobalDB::FolderFindMsgByMessageID(nsFolderKey folderID,
+                                            nsACString const& messageID,
+                                            nsMsgKey* msgKey) {
+  printf("XYZZY GlobalDB::FolderFindMsgByMessageID(%d %s)\n", (int)folderID,
          nsPromiseFlatCString(messageID).get());
-  nsCOMPtr<mozIStorageStatement> stmt =
-      Stmt("SELECT rowid FROM msg WHERE messageID=:messageID");
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT id FROM msg m INNER JOIN msg_folder f ON m.id=f.msg_id WHERE "
+      "m.messageID=:messageID AND f.folder_id=:folderID");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv;
   rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
   NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("folderID"_ns, (int64_t)folderID);
+  NS_ENSURE_SUCCESS(rv, rv);
   bool exists;
   rv = stmt->ExecuteStep(&exists);
   NS_ENSURE_SUCCESS(rv, rv);
   if (!exists) {
     *msgKey = nsMsgKey_None;
     return NS_OK;
   }
   int64_t tmp;
@@ -1619,29 +1625,34 @@ static nsTArray<nsCString> SplitReferenc
     } else {
       out.AppendElement(ref);
     }
   }
 
   return out;
 }
 
-// Insert msg into the threading system.
-nsresult GlobalDB::ThreadNewMsg(nsMsgKey msgKey, nsMsgKey* threadID) {
+// Insert msg into the threading system, restricting to single folder.
+// (eventually we'll allow proper cross-folder threading when messages
+// can appear in multiple folders).
+// This is pretty noddy right now, and doesn't handle repairing threads
+// with missing messages, but it's a starting point.
+nsresult GlobalDB::FolderThreadNewMsg(nsFolderKey folderID, nsMsgKey msgKey,
+                                      nsMsgKey* threadID) {
   nsAutoCString unParsedReferences;
   nsresult rv = FetchMsgReferences(msgKey, unParsedReferences);
   NS_ENSURE_SUCCESS(rv, rv);
   auto refs = SplitReferences(unParsedReferences);
 
   // Resolve all the refs. If any are missing, treat them as if they
   // just don't exist.
   nsTArray<nsMsgKey> refKeys(refs.Length());
   for (auto const& ref : refs) {
     nsMsgKey k;
-    rv = FindMsgByMessageID(ref, &k);
+    rv = FolderFindMsgByMessageID(folderID, ref, &k);
     NS_ENSURE_SUCCESS(rv, rv);
     if (k == nsMsgKey_None) {
       printf("XYZZY: UHOH - messageID '%s' not found (referenced by %d\n)\n",
              ref.get(), msgKey);
       continue;
     }
     refKeys.AppendElement(k);
   }
@@ -1674,19 +1685,20 @@ nsresult GlobalDB::ThreadNewMsg(nsMsgKey
     rv = stmt->BindInt64ByName("thread"_ns, (int64_t)*threadID);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = stmt->BindInt32ByName("depth"_ns, depth);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = stmt->Execute();
     NS_ENSURE_SUCCESS(rv, rv);
 
     printf(
-        "XYZZY: GlobalDB::ThreadNewMsg() -> msg=%d parent=%d thread=%d "
+        "XYZZY: GlobalDB::FolderThreadNewMsg() -> folder=%d msg=%d parent=%d "
+        "thread=%d "
         "depth=%d\n",
-        (int)msgKey, (int)parentKey, (int)*threadID, (int)depth);
+        (int)folderID, (int)msgKey, (int)parentKey, (int)*threadID, (int)depth);
   }
   // Invalidate relevant cached data.
   mThreadMemberCountCache.remove(*threadID);
   mThreadMembersCache.remove(*threadID);
   mMsgChildrenCache.remove(msgKey);
   return NS_OK;
 }
 
@@ -1729,17 +1741,17 @@ nsresult GlobalDB::FetchMsgChildren(nsMs
   auto p = mMsgChildrenCache.lookup(parentKey);
   if (p) {
     children = p->value().Clone();
     return NS_OK;
   }
 
   printf("XYZZY GlobalDB::FetchMsgChildren(parentKey=%d)\n", (int)parentKey);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
-      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
+      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.id "
       "WHERE t.parent=:parentKey ORDER BY m.date ASC");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("parentKey"_ns, (int64_t)parentKey);
   NS_ENSURE_SUCCESS(rv, rv);
   children.Clear();
   while (1) {
     bool exists;
@@ -1761,19 +1773,20 @@ nsresult GlobalDB::FetchMsgChildren(nsMs
 
 // Get all messages belonging to thread, ordered by date.
 nsresult GlobalDB::ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs) {
   if (auto p = mThreadMembersCache.lookup(threadKey)) {
     msgs = p->value().Clone();
     return NS_OK;
   }
 
+  // The msg join is needed to sort by date.
   printf("XYZZY GlobalDB::ThreadMembers(threadKey=%d)\n", (int)threadKey);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
-      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.rowid "
+      "SELECT t.msg FROM msg_thread t INNER JOIN msg m ON t.msg=m.id "
       "WHERE t.thread=:threadKey ORDER BY m.date ASC");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("threadKey"_ns, (int64_t)threadKey);
   NS_ENSURE_SUCCESS(rv, rv);
   msgs.Clear();
   while (1) {
     bool exists;
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -11,16 +11,18 @@
 #include "mozilla/HashTable.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 // #include "nsHashKeys.h"
 #include "mozilla/PairHash.h"
 typedef uint32_t nsFolderKey;
 
+const nsFolderKey nsFolderKey_None = 0;
+
 namespace mozilla::intl {
 class Collator;
 }
 
 // Used for mork import, but should be trimmed down and used
 // when adding messages to the system.
 struct RawHdr {
   // nsMsgKey id{0};
@@ -187,29 +189,32 @@ class GlobalDB {
   nsresult MsgGetProperty(nsMsgKey key, nsACString const& name,
                           nsACString& value);
   nsresult MsgPropertyNames(nsMsgKey key, nsTArray<nsCString>& propNames);
 
   nsresult StashMsg(RawHdr const& msg, nsMsgKey* newKey);
 
   // Thread stuff.
 
-  // Return key of message with matching messageID.
+  // Return key of message with matching messageID in the given folder.
   // Returns nsMsgKey_None if not found.
-  nsresult FindMsgByMessageID(nsACString const& messageID, nsMsgKey* msgKey);
+  nsresult FolderFindMsgByMessageID(nsFolderKey folderID,
+                                    nsACString const& messageID,
+                                    nsMsgKey* msgKey);
 
   // Return all direct children of parentKey.
   nsresult FetchMsgChildren(nsMsgKey parentKey, nsTArray<nsMsgKey>& children);
   // Return all messages belonging to thread.
   nsresult ThreadMembers(nsMsgKey threadKey, nsTArray<nsMsgKey>& msgs);
   // Number of messages belonging to thread.
   nsresult ThreadMemberCount(nsMsgKey threadKey, uint32_t* total);
 
   // Inserts a message into the threading system.
-  nsresult ThreadNewMsg(nsMsgKey msgKey, nsMsgKey* threadID);
+  nsresult FolderThreadNewMsg(nsFolderKey folderID, nsMsgKey msgKey,
+                              nsMsgKey* threadID);
 
   // List all the threads with root messages in the specified folder.
   nsresult FetchFolderThreads(nsFolderKey folderKey,
                               nsTArray<nsMsgKey>& threadKeys);
 
  private:
   nsresult InitSchema();
 
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -869,17 +869,19 @@ NS_IMETHODIMP nsMsgDatabase2::CreateNewH
 }
 
 NS_IMETHODIMP nsMsgDatabase2::AddNewHdrToDB(nsIMsgDBHdr* newHdr, bool notify) {
   printf("XYZZY: AddnewHdrToDB(%s)\n", notify ? "notify" : "no notify");
   // Sort out threading.
   nsMsgKey threadID;
   nsMsgKey key;
   newHdr->GetMessageKey(&key);
-  DB().ThreadNewMsg(key, &threadID);
+  // We restrict the threading calculations to only consider messages in
+  // this folder. But GlobalDB threading data ignores folders.
+  DB().FolderThreadNewMsg(mFolderID, key, &threadID);
   if (notify) {
     uint32_t flags;
     nsMsgKey threadParent;
     newHdr->GetFlags(&flags);
     newHdr->GetThreadParent(&threadParent);
     NotifyHdrAddedAll(newHdr, threadParent, flags, NULL);
   }
   return NS_OK;  // TODO
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1684196366 -43200
#      Tue May 16 12:19:26 2023 +1200
# Node ID 8edccbd86c87dbaf4f4c2a8337d69d7afb68165f
# Parent  dba9430b2f748fda310c0b48722acce1e860e4ab
GlobalDB - add shutdown handler to stop storage layer barfing.

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -6,27 +6,159 @@
 #include "msgCore.h"
 #include "nsIFile.h"
 #include "nsAppDirectoryServiceDefs.h"
 #include "nsDirectoryServiceUtils.h"
 #include "nsMsgHdr2.h"
 #include "nsMsgThread2.h"
 // #include "nsMsgEnumerator.h"
 #include "nsWhitespaceTokenizer.h"
+// #include "nsIThreadManager.h"
+
+#include "nsThreadUtils.h"
+#include "nsIAsyncShutdown.h"
+#include "mozilla/AppShutdown.h"
+#include "mozilla/Services.h"
+
+//
+// Shutdown hoop-jumping
+//
+// Based on toolkit/components/places/Shutdown.(h|cpp).
+// And dom/file/uri/BlobURLProtocolHandler.cpp ReleasingTimerHolder
+//
+// TODO: explain!
+
+// storage/mozStorageService.cpp:752 asserts/crashes if there are still
+// open connections at 'xpcom-shutdown-threads' time.
+
+class GlobalDBShutdownBlocker final : public nsIAsyncShutdownBlocker {
+  //                                public mozIStorageCompletionCallback {
+ public:
+  NS_DECL_THREADSAFE_ISUPPORTS
+
+  explicit GlobalDBShutdownBlocker() {
+    MOZ_ASSERT(NS_IsMainThread());
+    printf("XYZZY: GlobalDBShutdownBlocker()\n");
+  }
+
+  nsresult Install() {
+    printf("XYZZY: GlobalDBShutdownBlocke::Install()\n");
+    nsCOMPtr<nsIAsyncShutdownService> svc =
+        mozilla::services::GetAsyncShutdownService();
+    NS_ENSURE_TRUE(svc, NS_ERROR_FAILURE);
+
+    nsCOMPtr<nsIAsyncShutdownClient> phase;
+    nsresult rv = svc->GetProfileBeforeChange(getter_AddRefs(phase));
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = phase->AddBlocker(this, NS_LITERAL_STRING_FROM_CSTRING(__FILE__),
+                           __LINE__, u""_ns);
+    NS_ENSURE_SUCCESS(rv, rv);
+    printf("XYZZY: GlobalDBShutdownBlocke::Install() OK\n");
+    return NS_OK;
+  }
+
+  // nsIAsyncShutdownBlocker interfaces
+
+  NS_IMETHODIMP GetName(nsAString& aName) override {
+    aName.AssignLiteral("GlobalDBShutdownBlocker");
+    return NS_OK;
+  }
+
+  NS_IMETHOD BlockShutdown(nsIAsyncShutdownClient* aParentClient) override {
+    MOZ_ASSERT(NS_IsMainThread());
+    printf("XYZZY GlobalDBShutdownBlocker::BlockShutdown()\n");
+    // TODO: Don't use this path, which may create new singleton!
+    GlobalDB::get().Shutdown();
+    aParentClient->RemoveBlocker(this);
+    printf("XYZZY GlobalDBShutdownBlocker::BlockShutdown() all done\n");
+
+    /*
+    mParentClient = new nsMainThreadPtrHolder<nsIAsyncShutdownClient>(
+        "ClientsShutdownBlocker::mParentClient", aParentClient);
+    mState = RECEIVED_BLOCK_SHUTDOWN;
+
+    if (NS_WARN_IF(!mBarrier)) {
+      return NS_ERROR_NOT_AVAILABLE;
+    }
+
+    // Wait until all the clients have removed their blockers.
+    MOZ_ALWAYS_SUCCEEDS(mBarrier->Wait(this));
+
+    mState = CALLED_WAIT_CLIENTS;
+    */
+    return NS_OK;
+  }
+
+  NS_IMETHOD GetState(nsIPropertyBag**) override { return NS_OK; }
+  /*
+    // nsIAsyncShutdownCompletionCallback interfaces
+
+    NS_IMETHOD Done() override {
+      // At this point all the clients are done, we can stop blocking the
+    shutdown
+      // phase.
+      mState = RECEIVED_DONE;
+
+      // At this stage, any use of this database is forbidden. Get rid of
+      // `gDatabase`. Note, however, that the database could be
+      // resurrected.  This can happen in particular during tests.
+      MOZ_ASSERT(Database::gDatabase == nullptr ||
+                Database::gDatabase == mDatabase);
+      Database::gDatabase = nullptr;
+
+      // Database::Shutdown will invoke Complete once the connection is closed.
+      mDatabase->Shutdown();
+      mState = CALLED_STORAGESHUTDOWN;
+      mBarrier = nullptr;
+      return NS_OK;
+    }
+  */
+  /*
+  // mozIStorageCompletionCallback
+  NS_IMETHODIMP
+  GlobalDBShutdownBlocker::Complete(nsresult, nsISupports*) {
+    MOZ_ASSERT(NS_IsMainThread());
+    mState = RECEIVED_STORAGESHUTDOWN_COMPLETE;
+
+    // The connection is closed, the Database has no more use, so we can break
+    // possible cycles.
+    mDatabase = nullptr;
+
+    // mParentClient is nullptr in tests
+    if (mParentClient) {
+      nsresult rv = mParentClient->RemoveBlocker(this);
+      if (NS_WARN_IF(NS_FAILED(rv))) return rv;
+      mParentClient = nullptr;
+    }
+    return NS_OK;
+  }
+  */
+ private:
+  virtual ~GlobalDBShutdownBlocker() {
+    printf("XYZZY: ~GlobalDBShutdownBlocker()\n");
+  };
+};
+
+NS_IMPL_ISUPPORTS(GlobalDBShutdownBlocker, nsIAsyncShutdownBlocker)
 
 // **********************************************************************
 // GlobalDB
 //
 
 GlobalDB::GlobalDB() : mStmtCache(mConn) {}
 
-GlobalDB::~GlobalDB() {
+GlobalDB::~GlobalDB() { Shutdown(); }
+
+// called by dtor and by GlobalDBShutdownBlocker
+void GlobalDB::Shutdown() {
   mStmtCache.FinalizeStatements();
   if (mConn) {
     mConn->Close();
+    mConn = nullptr;
   }
 }
 
 nsresult GlobalDB::Init() {
   nsCOMPtr<mozIStorageService> storage =
       do_GetService(MOZ_STORAGE_SERVICE_CONTRACTID);
   NS_ENSURE_STATE(storage);
 
@@ -84,16 +216,21 @@ nsresult GlobalDB::Init() {
     options.sensitivity = Collator::Sensitivity::Base;
     auto optResult = mCollator->SetOptions(options);
     if (optResult.isErr()) {
       NS_WARNING("Could not configure the mozilla::intl::Collation.");
       mCollator = nullptr;
       return NS_ERROR_FAILURE;
     }
   }
+
+  mShutdownBlocker = new GlobalDBShutdownBlocker();
+  rv = mShutdownBlocker->Install();
+  NS_ENSURE_SUCCESS(rv, rv);
+
   return NS_OK;
 }
 
 nsresult GlobalDB::InitSchema() {
   const int32_t latestSchemaVersion = 1;
   int32_t currentSchemaVersion;
   nsresult rv = mConn->GetSchemaVersion(&currentSchemaVersion);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -384,25 +521,29 @@ nsresult GlobalDB::StashMsgs(nsTArray<Ra
 }
 
 nsCString GlobalDB::LastErr() {
   nsCString err;
   mConn->GetLastErrorString(err);
   return err;
 }
 
-// Just use a shonky singleton for now.
+// Shonky singleton until we figure out the bigger picture.
+
+// static
+mozilla::StaticAutoPtr<GlobalDB> GlobalDB::sSingleton;
+
 // static
 GlobalDB& GlobalDB::get() {
-  static GlobalDB instance;
-  if (!instance.mConn) {
-    nsresult rv = instance.Init();
+  if (!sSingleton) {
+    sSingleton = new GlobalDB();
+    nsresult rv = sSingleton->Init();
     MOZ_ASSERT(NS_SUCCEEDED(rv));
   }
-  return instance;
+  return *(sSingleton.get());
 }
 
 already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(nsACString const& query) {
   return mStmtCache.GetCachedStatement(query);
 }
 
 already_AddRefed<mozIStorageStatement> GlobalDB::Stmt(const char* query) {
   return Stmt(nsDependentCString(query));
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -9,16 +9,18 @@
 
 #include "mozilla/storage.h"
 #include "mozilla/HashTable.h"
 #include "MailNewsTypes2.h"
 #include "nsMsgMessageFlags.h"
 #include "nsTArray.h"
 // #include "nsHashKeys.h"
 #include "mozilla/PairHash.h"
+#include "mozilla/StaticPtr.h"
+
 typedef uint32_t nsFolderKey;
 
 const nsFolderKey nsFolderKey_None = 0;
 
 namespace mozilla::intl {
 class Collator;
 }
 
@@ -61,25 +63,23 @@ struct RawHdr {
 };
 
 class nsIMsgDBHdr;
 class nsIDBChangeListener;
 class nsMsgHdr2;
 // class nsIMsgEnumerator;
 // class nsIMsgThreadEnumerator;
 class nsIMsgSearchTerm;
+class GlobalDBShutdownBlocker;
 
 class GlobalDB {
  public:
+  // Shonky singleton until we figure out the bigger picture.
   static GlobalDB& get();
 
-  GlobalDB();
-  ~GlobalDB();
-  nsresult Init();
-
   nsresult StashMsgs(nsTArray<RawHdr> const& msgs, nsFolderKey folderID);
 
   // Get the last DB error message.
   nsCString LastErr();
 
   // -------------- data access ---------------
 
   // to support nsMsgHdr2
@@ -210,17 +210,27 @@ class GlobalDB {
   // Inserts a message into the threading system.
   nsresult FolderThreadNewMsg(nsFolderKey folderID, nsMsgKey msgKey,
                               nsMsgKey* threadID);
 
   // List all the threads with root messages in the specified folder.
   nsresult FetchFolderThreads(nsFolderKey folderKey,
                               nsTArray<nsMsgKey>& threadKeys);
 
+  void Shutdown();  // For shutdown hoop-jumping.
+  ~GlobalDB();
+
  private:
+  static mozilla::StaticAutoPtr<GlobalDB> sSingleton;
+
+  RefPtr<GlobalDBShutdownBlocker> mShutdownBlocker;
+
+  GlobalDB();
+
+  nsresult Init();
   nsresult InitSchema();
 
   already_AddRefed<mozIStorageStatement> Stmt(nsACString const& query);
   // TODO: Add a templated version to speed up for literals?
   already_AddRefed<mozIStorageStatement> Stmt(const char* query);
   already_AddRefed<mozIStorageStatement> MsgKeyStmt(nsMsgKey key,
                                                     const char* query);
   nsCOMPtr<mozIStorageConnection> mConn;
diff --git a/mailnews/db/msgdb/src/MSFSlurp.cpp b/mailnews/db/msgdb/src/MSFSlurp.cpp
--- a/mailnews/db/msgdb/src/MSFSlurp.cpp
+++ b/mailnews/db/msgdb/src/MSFSlurp.cpp
@@ -272,22 +272,20 @@ static uint64_t hexToU64(nsACString cons
   if (PR_sscanf(PromiseFlatCString(val).get(), "%" PRIx64, &i) != 1) {
     return 0;
   }
   return i;
 }
 
 nsresult MSFSlurper::dumpum(nsACString const& folderURI) {
   PRTime start = PR_Now();
+  nsresult rv;
 
-  GlobalDB db;
-  nsresult rv = db.Init();
-  if (NS_FAILED(rv)) {
-    NS_WARNING("GlobalDB failed");
-  }
+  // Hmm. would be nice to ditch the singleton crap.
+  GlobalDB& db = GlobalDB::get();
 
   nsFolderKey folderID;
   rv = db.FolderFindOrCreate(folderURI, &folderID);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mdb_count nRows;
   rv = mAllMsgHeadersTable->GetCount(mEnv, &nRows);
   NS_ENSURE_SUCCESS(rv, rv);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1684729067 -43200
#      Mon May 22 16:17:47 2023 +1200
# Node ID 2f6b3b6b82594b6768ccbfc3e9d75059ba838bd9
# Parent  8edccbd86c87dbaf4f4c2a8337d69d7afb68165f
add nsIMsgHdr.imapUID attr

diff --git a/mailnews/base/public/nsIMsgHdr.idl b/mailnews/base/public/nsIMsgHdr.idl
--- a/mailnews/base/public/nsIMsgHdr.idl
+++ b/mailnews/base/public/nsIMsgHdr.idl
@@ -100,10 +100,13 @@ interface nsIMsgDBHdr : nsISupports
      */
     readonly attribute ACString effectiveCharset;
 
     attribute string accountKey;
     readonly attribute nsIMsgFolder folder;
 
     /// Array of names of all database properties in the header.
     readonly attribute Array<AUTF8String> properties;
+
+    /// If this is a message on an IMAP server, this holds its UID.
+    attribute unsigned long imapUID;
 };
 /* *******************************************************************************/
diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -272,18 +272,22 @@ nsresult GlobalDB::InitSchema() {
         "protoThreadFlags INTEGER NOT NULL DEFAULT 0, "
         //  "account TEXT NOT NULL DEFAULT '', "    // ACCOUNT is reserved word
         "glodaId INTEGER NOT NULL DEFAULT 0, "
         "xGmMsgId TEXT NOT NULL DEFAULT '', "
         "xGmThrId TEXT NOT NULL DEFAULT '', "
         "xGmLabels TEXT NOT NULL DEFAULT '', "
         "pseudoHdr INTEGER NOT NULL DEFAULT 0, "  // KILL KILL KILL!
         "enigmail INTEGER NOT NULL DEFAULT 0, "
-        "notAPhishMessage INTEGER NOT NULL DEFAULT 0 "
+        "notAPhishMessage INTEGER NOT NULL DEFAULT 0, "
+        "imapUID INTEGER NOT NULL DEFAULT 0 "
         ")");
+    // NOTE: linkage to an IMAP message should probably be handled by a
+    // separate table, but for now we'll just shove it in with all the other
+    // stuff. IMAP UIDs are non-zero, so 0 means no imap linkage.
     rv = mConn->ExecuteSimpleSQL(create_msg);
     NS_ENSURE_SUCCESS(rv, rv);
 
     const nsLiteralCString create_idx_msg_messageid(
         "CREATE INDEX idx_msg_messageid ON msg(messageID)");
     rv = mConn->ExecuteSimpleSQL(create_idx_msg_messageid);
     NS_ENSURE_SUCCESS(rv, rv);
 
@@ -552,17 +556,17 @@ already_AddRefed<mozIStorageStatement> G
 // -------------- data access ---------------
 
 // private helper
 nsresult GlobalDB::FetchMsg(nsMsgKey key, CachedHdr& hdr) {
   printf("XYZZY GlobalDB::FetchMsg(key=%d)\n", (int)key);
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT messageID, refs, date, subject, sender, sender, "
       "recipients, ccList, bccList, flags, msgSize, storeToken, "
-      "offlineMsgSize, numLines, junkscore, keywords FROM msg "
+      "offlineMsgSize, numLines, junkscore, keywords, imapUID FROM msg "
       "WHERE id=:id");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("id"_ns, (int64_t)key);
   NS_ENSURE_SUCCESS(rv, rv);
 
   bool exists;
   rv = stmt->ExecuteStep(&exists);
@@ -619,16 +623,20 @@ nsresult GlobalDB::FetchMsg(nsMsgKey key
 
   rv = stmt->GetInt64(pos++, &tmp64);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr.junkscore = (uint32_t)tmp64;
 
   rv = stmt->GetUTF8String(pos++, hdr.keywords);
   NS_ENSURE_SUCCESS(rv, rv);
 
+  rv = stmt->GetInt64(pos++, &tmp64);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr.IMAPUID = (uint32_t)tmp64;
+
   return NS_OK;
 }
 
 // Probably a little naughty returning a pointer to fiddle the
 // data in-place. It's unclear if HashMap moves values around
 // I think not, but you never know.
 nsresult GlobalDB::GetCachedHdr(nsMsgKey key, CachedHdr** hdr) {
   auto p = mHdrCache.lookupForAdd(key);
@@ -649,16 +657,24 @@ nsresult GlobalDB::GetCachedHdr(nsMsgKey
 nsresult GlobalDB::FetchMsgFlags(nsMsgKey key, uint32_t* flags) {
   CachedHdr* hdr;
   nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   *flags = hdr->flags;
   return NS_OK;
 }
 
+nsresult GlobalDB::FetchMsgIMAPUID(nsMsgKey key, uint32_t* flags) {
+  CachedHdr* hdr;
+  nsresult rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *flags = hdr->IMAPUID;
+  return NS_OK;
+}
+
 nsresult GlobalDB::FetchMsgMessageID(nsMsgKey key, nsACString& messageID) {
   CachedHdr* hdr;
   nsresult rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   messageID = hdr->messageID;
   return NS_OK;
 }
 
@@ -927,16 +943,37 @@ nsresult GlobalDB::SetMsgFlags(nsMsgKey 
   // Update the cached hdr.
   CachedHdr* hdr;
   rv = GetCachedHdr(key, &hdr);
   NS_ENSURE_SUCCESS(rv, rv);
   hdr->flags = flags;
   return NS_OK;
 }
 
+nsresult GlobalDB::SetMsgIMAPUID(nsMsgKey key, uint32_t imapUID) {
+  MOZ_ASSERT(imapUID < INT32_MAX);
+  nsCOMPtr<mozIStorageStatement> stmt =
+      Stmt("UPDATE msg SET imapUID=:uid WHERE id=:msgKey");
+  NS_ENSURE_STATE(stmt);
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt32ByName("uid"_ns, (int32_t)imapUID);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = stmt->Execute();
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  // Update the cached hdr.
+  CachedHdr* hdr;
+  rv = GetCachedHdr(key, &hdr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  hdr->IMAPUID = imapUID;
+  return NS_OK;
+}
+
 nsresult GlobalDB::SetMsgMessageID(nsMsgKey key, nsACString const& messageID) {
   nsCOMPtr<mozIStorageStatement> stmt =
       Stmt("UPDATE msg SET messageID=:messageID WHERE id=:msgKey");
   NS_ENSURE_STATE(stmt);
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindUTF8StringByName("messageID"_ns, messageID);
   NS_ENSURE_SUCCESS(rv, rv);
   rv = stmt->BindInt64ByName("msgKey"_ns, (int64_t)key);
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -78,16 +78,17 @@ class GlobalDB {
   nsresult StashMsgs(nsTArray<RawHdr> const& msgs, nsFolderKey folderID);
 
   // Get the last DB error message.
   nsCString LastErr();
 
   // -------------- data access ---------------
 
   // to support nsMsgHdr2
+  nsresult FetchMsgIMAPUID(nsMsgKey key, uint32_t* uid);
   nsresult FetchMsgFlags(nsMsgKey key, uint32_t* flags);
   nsresult FetchMsgMessageID(nsMsgKey key, nsACString& messageID);
   nsresult FetchMsgReferences(nsMsgKey key, nsACString& refs);
   nsresult FetchMsgSender(nsMsgKey key, nsACString& sender);
   nsresult FetchMsgSubject(nsMsgKey key, nsACString& subject);
   nsresult FetchMsgRecipients(nsMsgKey key, nsACString& recipients);
   nsresult FetchMsgCCList(nsMsgKey key, nsACString& ccList);
   nsresult FetchMsgBCCList(nsMsgKey key, nsACString& bccList);
@@ -113,16 +114,18 @@ class GlobalDB {
   nsresult FetchMsgSenderCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
   nsresult FetchMsgSubjectCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
   nsresult FetchMsgRecipientsCollationKey(nsMsgKey key, nsTArray<uint8_t>& buf);
 
   nsresult CompareCollationKeys(const nsTArray<uint8_t>& key1,
                                 const nsTArray<uint8_t>& key2, int32_t* result);
   nsresult CreateCollationKey(const nsAString& sourceString,
                               nsTArray<uint8_t>& buf);
+  // Set msg fields.
+  nsresult SetMsgIMAPUID(nsMsgKey key, uint32_t imapUID);
   nsresult SetMsgFlags(nsMsgKey key, uint32_t flags);
   nsresult SetMsgMessageID(nsMsgKey key, nsACString const& messageID);
   nsresult SetMsgReferences(nsMsgKey key, nsACString const& references);
   nsresult SetMsgSender(nsMsgKey key, nsACString const& sender);
   nsresult SetMsgSubject(nsMsgKey key, nsACString const& subject);
   nsresult SetMsgRecipients(nsMsgKey key, nsACString const& recipients);
   nsresult SetMsgCCList(nsMsgKey key, nsACString const& ccList);
   nsresult SetMsgBCCList(nsMsgKey key, nsACString const& bccList);
@@ -260,16 +263,18 @@ class GlobalDB {
     uint32_t lineCount{0};
     uint32_t junkscore{0};
     nsAutoCString keywords;
 
     // derived fields
     nsAutoString subjectDecoded;
     nsAutoString senderDecoded;
     nsAutoString recipientsDecoded;
+
+    uint32_t IMAPUID;
   };
 
   nsresult FetchMsg(nsMsgKey msgKey, CachedHdr& hdr);
   nsresult GetCachedHdr(nsMsgKey key, CachedHdr** hdr);
 
   mozilla::HashMap<nsMsgKey, CachedHdr> mHdrCache;
   // The rest is pretty ad-hoc.
   mozilla::HashMap<nsMsgKey, uint32_t> mThreadMemberCountCache;
diff --git a/mailnews/db/msgdb/src/nsMsgHdr.cpp b/mailnews/db/msgdb/src/nsMsgHdr.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr.cpp
@@ -117,16 +117,26 @@ NS_IMETHODIMP nsMsgHdr::GetThreadId(nsMs
   return NS_ERROR_NULL_POINTER;
 }
 
 NS_IMETHODIMP nsMsgHdr::SetThreadId(nsMsgKey inKey) {
   m_threadId = inKey;
   return SetUInt32Column(m_threadId, m_mdb->m_messageThreadIdColumnToken);
 }
 
+NS_IMETHODIMP nsMsgHdr::GetImapUID(uint32_t* result) {
+  MOZ_CRASH("Not implemented in mork version");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgHdr::SetImapUID(uint32_t uid) {
+  MOZ_CRASH("Not implemented in mork version");
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 NS_IMETHODIMP nsMsgHdr::SetMessageKey(nsMsgKey value) {
   m_messageKey = value;
   return NS_OK;
 }
 
 nsresult nsMsgHdr::GetRawFlags(uint32_t* result) {
   if (!(m_initedValues & FLAGS_INITED)) InitFlags();
   *result = m_flags;
diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -38,16 +38,24 @@ NS_IMETHODIMP nsMsgHdr2::GetThreadId(nsM
 
 NS_IMETHODIMP nsMsgHdr2::SetThreadId(nsMsgKey threadID) {
   printf("XYZZY: nsMsgHdr2::SetThreadId(%d) - NOT IMPLEMENTED\n",
          (int)threadID);
   // return DB().SetMsgThreadID(mKey, threadID);
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+NS_IMETHODIMP nsMsgHdr2::GetImapUID(uint32_t* result) {
+  return DB().FetchMsgIMAPUID(mKey, result);
+}
+
+NS_IMETHODIMP nsMsgHdr2::SetImapUID(uint32_t uid) {
+  return DB().SetMsgIMAPUID(mKey, uid);
+}
+
 // TODO: should be read-only?
 NS_IMETHODIMP nsMsgHdr2::SetMessageKey(nsMsgKey value) {
   printf("XYZZY: NOT IMPLEMENTED nsMsgHdr2::SetMessageKey()\n");
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP nsMsgHdr2::GetFlags(uint32_t* result) {
   nsresult rv = DB().FetchMsgFlags(mKey, result);
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -2528,16 +2528,17 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm
   // remember what the supported user flags are.
   uint32_t supportedUserFlags;
   aSpec->GetSupportedUserFlags(&supportedUserFlags);
   SetSupportedUserFlags(supportedUserFlags);
 
   m_uidValidity = folderValidity;
 
   if (imapUIDValidity != folderValidity) {
+    // TODO: rewrite this!
     NS_ASSERTION(imapUIDValidity == kUidUnknown,
                  "uid validity seems to have changed, blowing away db");
     nsCOMPtr<nsIFile> pathFile;
     rv = GetFilePath(getter_AddRefs(pathFile));
     if (NS_FAILED(rv)) return rv;
 
     nsCOMPtr<nsIMsgDBService> msgDBService =
         do_GetService("@mozilla.org/msgDatabase/msgDBService;1", &rv);
diff --git a/mailnews/local/src/nsMsgFileHdr.cpp b/mailnews/local/src/nsMsgFileHdr.cpp
--- a/mailnews/local/src/nsMsgFileHdr.cpp
+++ b/mailnews/local/src/nsMsgFileHdr.cpp
@@ -161,16 +161,24 @@ NS_IMETHODIMP nsMsgFileHdr::OrFlags(uint
 NS_IMETHODIMP nsMsgFileHdr::AndFlags(uint32_t flags, uint32_t* _retval) {
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgFileHdr::GetThreadId(nsMsgKey* aThreadId) { return NS_OK; }
 
 NS_IMETHODIMP nsMsgFileHdr::SetThreadId(nsMsgKey aThreadId) { return NS_OK; }
 
+NS_IMETHODIMP nsMsgFileHdr::GetImapUID(uint32_t* result) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgFileHdr::SetImapUID(uint32_t uid) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 NS_IMETHODIMP nsMsgFileHdr::GetMessageKey(nsMsgKey* aMessageKey) {
   return NS_OK;
 }
 
 NS_IMETHODIMP nsMsgFileHdr::SetMessageKey(nsMsgKey aMessageKey) {
   return NS_OK;
 }
 
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1685987642 -43200
#      Tue Jun 06 05:54:02 2023 +1200
# Node ID 8356188d476e3984042a178f7842ca20f435e0be
# Parent  2f6b3b6b82594b6768ccbfc3e9d75059ba838bd9
Don't use IMAP UID as msgdb key.

diff --git a/mailnews/base/src/nsMsgDBView.cpp b/mailnews/base/src/nsMsgDBView.cpp
--- a/mailnews/base/src/nsMsgDBView.cpp
+++ b/mailnews/base/src/nsMsgDBView.cpp
@@ -2804,17 +2804,16 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg
   nsresult rv = GetFolderForViewIndex(selection[0], getter_AddRefs(folder));
   nsCOMPtr<nsIMsgWindow> msgWindow(do_QueryReferent(mMsgWindowWeak));
   if (command == nsMsgViewCommandType::deleteMsg)
     return DeleteMessages(msgWindow, selection, false);
 
   if (command == nsMsgViewCommandType::deleteNoTrash)
     return DeleteMessages(msgWindow, selection, true);
 
-  nsTArray<nsMsgKey> imapUids;
   nsCOMPtr<nsIMsgImapMailFolder> imapFolder = do_QueryInterface(folder);
   bool thisIsImapFolder = (imapFolder != nullptr);
   nsCOMPtr<nsIJunkMailPlugin> junkPlugin;
 
   // If this is a junk command, get the junk plugin.
   if (command == nsMsgViewCommandType::junk ||
       command == nsMsgViewCommandType::unjunk) {
     // Get the folder from the first item; we assume that
@@ -2831,39 +2830,38 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg
 
     junkPlugin = do_QueryInterface(filterPlugin, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   folder->EnableNotifications(nsIMsgFolder::allMessageCountNotifications,
                               false);
 
+  nsTArray<nsMsgKey> msgKeys;
   // No sense going through the code that handles messages in collasped threads
   // for mark thread read.
   if (command == nsMsgViewCommandType::markThreadRead) {
     for (nsMsgViewIndex viewIndex : selection) {
-      SetThreadOfMsgReadByIndex(viewIndex, imapUids, true);
+      SetThreadOfMsgReadByIndex(viewIndex, msgKeys, true);
     }
   } else {
     // Turn the selection into an array of msg hdrs. This may include messages
     // in collapsed threads
     AutoTArray<RefPtr<nsIMsgDBHdr>, 1> messages;
     rv = GetHeadersFromSelection(selection, messages);
     NS_ENSURE_SUCCESS(rv, rv);
     uint32_t length = messages.Length();
 
-    if (thisIsImapFolder) {
-      imapUids.SetLength(length);
-    }
+    msgKeys.SetLength(length);
 
     for (uint32_t i = 0; i < length; i++) {
       nsMsgKey msgKey;
       nsCOMPtr<nsIMsgDBHdr> msgHdr(messages[i]);
       msgHdr->GetMessageKey(&msgKey);
-      if (thisIsImapFolder) imapUids[i] = msgKey;
+      msgKeys[i] = msgKey;
 
       switch (command) {
         case nsMsgViewCommandType::junk:
           mNumMessagesRemainingInBatch++;
           mJunkHdrs.AppendElement(msgHdr);
           rv = SetMsgHdrJunkStatus(junkPlugin.get(), msgHdr,
                                    nsIJunkMailPlugin::JUNK);
           break;
@@ -2934,37 +2932,37 @@ nsMsgDBView::ApplyCommandToIndices(nsMsg
         addFlags = true;
         break;
       case nsMsgViewCommandType::undeleteMsg:
         flags = kImapMsgDeletedFlag;
         addFlags = false;
         break;
       case nsMsgViewCommandType::junk:
         return imapFolder->StoreCustomKeywords(msgWindow, "Junk"_ns,
-                                               "NonJunk"_ns, imapUids, nullptr);
+                                               "NonJunk"_ns, msgKeys, nullptr);
       case nsMsgViewCommandType::unjunk: {
         nsCOMPtr<nsIMsgDBHdr> msgHdr;
         GetHdrForFirstSelectedMessage(getter_AddRefs(msgHdr));
         uint32_t msgFlags = 0;
         if (msgHdr) msgHdr->GetFlags(&msgFlags);
 
         if (msgFlags & nsMsgMessageFlags::IMAPDeleted)
-          imapFolder->StoreImapFlags(kImapMsgDeletedFlag, false, imapUids,
+          imapFolder->StoreImapFlags(kImapMsgDeletedFlag, false, msgKeys,
                                      nullptr);
 
         return imapFolder->StoreCustomKeywords(msgWindow, "NonJunk"_ns,
-                                               "Junk"_ns, imapUids, nullptr);
+                                               "Junk"_ns, msgKeys, nullptr);
       }
       default:
         break;
     }
 
     // Can't get here without thisIsImapThreadPane == TRUE.
     if (flags != kNoImapMsgFlag) {
-      imapFolder->StoreImapFlags(flags, addFlags, imapUids, nullptr);
+      imapFolder->StoreImapFlags(flags, addFlags, msgKeys, nullptr);
     }
   }
 
   return rv;
 }
 
 /**
  * View modifications methods by index.
@@ -3413,24 +3411,24 @@ nsresult nsMsgDBView::PerformActionsOnJu
           rv = srcFolder->DeleteMessages(hdrsToDelete, msgWindow, false, false,
                                          nullptr, true);
       } else {
         rv = srcFolder->DeleteMessages(mJunkHdrs, msgWindow, false, false,
                                        nullptr, true);
       }
     } else if (mDeleteModel == nsMsgImapDeleteModels::IMAPDelete) {
       nsCOMPtr<nsIMsgImapMailFolder> imapFolder(do_QueryInterface(srcFolder));
-      nsTArray<nsMsgKey> imapUids(numJunkHdrs);
+      nsTArray<nsMsgKey> msgKeys(numJunkHdrs);
       for (nsIMsgDBHdr* msgHdr : mJunkHdrs) {
         nsMsgKey key;
         msgHdr->GetMessageKey(&key);
-        imapUids.AppendElement(key);
+        msgKeys.AppendElement(key);
       }
 
-      imapFolder->StoreImapFlags(kImapMsgDeletedFlag, false, imapUids, nullptr);
+      imapFolder->StoreImapFlags(kImapMsgDeletedFlag, false, msgKeys, nullptr);
     }
 
     NoteChange(0, 0, nsMsgViewNotificationCode::none);
 
     NS_ASSERTION(NS_SUCCEEDED(rv),
                  "move or deletion of message marked-as-junk/non junk failed");
   }
 
diff --git a/mailnews/db/msgdb/public/nsIMsgDatabase.idl b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
--- a/mailnews/db/msgdb/public/nsIMsgDatabase.idl
+++ b/mailnews/db/msgdb/public/nsIMsgDatabase.idl
@@ -245,16 +245,25 @@ interface nsIMsgDatabase : nsIDBChangeAn
    * @param {string} aGmailMessageID - The ID of the message to find.
    *
    * @returns the message, or null if not found (without throwing an error).
    */
   nsIMsgDBHdr getMsgHdrForGMMsgID(in string aGmailMessageID);
   //Returns whether or not this database contains the given key
   boolean containsKey(in nsMsgKey key);
 
+
+  /*
+   * UID fudge
+   */
+  Array<nsMsgKey> getMsgKeysForUIDs(in Array<unsigned long> uids);
+  Array<unsigned long> getMsgUIDsForKeys(in Array<nsMsgKey> keys);
+  boolean containsUID(in unsigned long uid);
+  nsIMsgDBHdr getMsgHdrForUID(in unsigned long uid);
+
 /**
  * Must call AddNewHdrToDB after creating. The idea is that you create
  * a new header, fill in its properties, and then call AddNewHdrToDB.
  * AddNewHdrToDB will send notifications to any listeners.
  *
  * @param aKey msgKey for the new header. If aKey is nsMsgKey_None,
  *             we will auto-assign a new key.
  */
diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -2008,8 +2008,84 @@ nsresult GlobalDB::FetchFolderThreads(ns
     }
     int64_t tmp;
     rv = stmt->GetInt64(0, &tmp);
     NS_ENSURE_SUCCESS(rv, rv);
     threadKeys.AppendElement((nsMsgKey)tmp);
   }
   return NS_OK;
 }
+
+nsresult GlobalDB::FolderGetKeysForUIDs(nsFolderKey folderKey,
+                                        nsTArray<uint32_t> const& uids,
+                                        nsTArray<nsMsgKey>& keys) {
+  const auto toCString = [](nsACString& dest, uint32_t uid) {
+    dest.AppendInt(uid);
+  };
+  nsAutoCString uidList = StringJoin(","_ns, uids, toCString);
+
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT m.id FROM msg m INNER JOIN msg_folder f ON "
+      "m.id = f.msg_id WHERE f.folder_id = :folderKey AND m.imapUID IN ("_ns +
+      uidList + ")"_ns);
+  NS_ENSURE_STATE(stmt);
+
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  keys.Clear();
+  while (1) {
+    bool exists;
+    nsresult rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    int64_t tmp;
+    rv = stmt->GetInt64(0, &tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    keys.AppendElement((nsMsgKey)tmp);
+  }
+  // Fail if we don't map all of them!
+  if (keys.Length() != uids.Length()) {
+    return NS_MSG_MESSAGE_NOT_FOUND;
+  }
+  return NS_OK;
+}
+
+nsresult GlobalDB::FolderGetUIDsForKeys(nsFolderKey folderKey,
+                                        nsTArray<nsMsgKey> const& keys,
+                                        nsTArray<nsMsgKey>& uids) {
+  const auto toCString = [](nsACString& dest, nsMsgKey key) {
+    dest.AppendInt(key);
+  };
+  nsAutoCString keyList = StringJoin(","_ns, keys, toCString);
+
+  nsCOMPtr<mozIStorageStatement> stmt = Stmt(
+      "SELECT m.imapUID FROM msg m INNER JOIN msg_folder f ON "
+      "m.id = f.msg_id WHERE f.folder_id = :folderKey AND m.id IN ("_ns +
+      keyList + ")"_ns);
+  NS_ENSURE_STATE(stmt);
+
+  mozStorageStatementScoper scoper(stmt);
+  nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  uids.Clear();
+  while (1) {
+    bool exists;
+    nsresult rv = stmt->ExecuteStep(&exists);
+    NS_ENSURE_SUCCESS(rv, rv);
+    if (!exists) {
+      break;
+    }
+    int64_t tmp;
+    rv = stmt->GetInt64(0, &tmp);
+    NS_ENSURE_SUCCESS(rv, rv);
+    uids.AppendElement((uint32_t)tmp);
+  }
+  // Fail if we don't map all of them!
+  if (uids.Length() != keys.Length()) {
+    return NS_MSG_MESSAGE_NOT_FOUND;
+  }
+  return NS_OK;
+}
diff --git a/mailnews/db/msgdb/src/GlobalDB.h b/mailnews/db/msgdb/src/GlobalDB.h
--- a/mailnews/db/msgdb/src/GlobalDB.h
+++ b/mailnews/db/msgdb/src/GlobalDB.h
@@ -164,17 +164,17 @@ class GlobalDB {
                                  nsMsgHdr2** found);
 
   // Folder functions
 
   // Find a folderID, given a URI. Create folder if it doesn't already exist.
   nsresult FolderFindOrCreate(nsACString const& folderURI,
                               nsFolderKey* folderID);
 
-  // Ones to evalutate:
+  // Ones to evaluate:
   nsresult FolderContainsKey(nsFolderKey folderID, nsMsgKey key,
                              bool* containsKey);
   nsresult FolderAddMsg(nsFolderKey folderID, nsMsgKey msgKey);
   nsresult FolderRemoveMsg(nsFolderKey folderID, nsMsgKey msgKey);
 
   nsresult FolderListAllKeys(nsFolderKey folderID, nsTArray<nsMsgKey>& keys);
 
   // Icky random-property stuff on folder and message.
@@ -213,16 +213,24 @@ class GlobalDB {
   // Inserts a message into the threading system.
   nsresult FolderThreadNewMsg(nsFolderKey folderID, nsMsgKey msgKey,
                               nsMsgKey* threadID);
 
   // List all the threads with root messages in the specified folder.
   nsresult FetchFolderThreads(nsFolderKey folderKey,
                               nsTArray<nsMsgKey>& threadKeys);
 
+  // For looking up messages by IMAP UID.
+  nsresult FolderGetKeysForUIDs(nsFolderKey folderKey,
+                                nsTArray<uint32_t> const& uids,
+                                nsTArray<nsMsgKey>& keys);
+  nsresult FolderGetUIDsForKeys(nsFolderKey folderKey,
+                                nsTArray<nsMsgKey> const& keys,
+                                nsTArray<nsMsgKey>& uids);
+
   void Shutdown();  // For shutdown hoop-jumping.
   ~GlobalDB();
 
  private:
   static mozilla::StaticAutoPtr<GlobalDB> sSingleton;
 
   RefPtr<GlobalDBShutdownBlocker> mShutdownBlocker;
 
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase.cpp b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase.cpp
@@ -1711,16 +1711,34 @@ NS_IMETHODIMP nsMsgDatabase::GetMsgHdrFo
         err = CreateMsgHdr(hdrRow, key, pmsgHdr);
       }
     }
   }
 
   return err;
 }
 
+NS_IMETHODIMP nsMsgDatabase::GetMsgKeysForUIDs(nsTArray<uint32_t> const& uids,
+                                               nsTArray<nsMsgKey>& keys) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase::GetMsgUIDsForKeys(nsTArray<nsMsgKey> const& keys,
+                                               nsTArray<uint32_t>& uids) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase::ContainsUID(uint32_t uid, bool* found) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP nsMsgDatabase::GetMsgHdrForUID(uint32_t uid, nsIMsgDBHdr** hdr) {
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 NS_IMETHODIMP nsMsgDatabase::DeleteMessage(nsMsgKey key,
                                            nsIDBChangeListener* instigator,
                                            bool commit) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
 
   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
   if (!msgHdr) return NS_MSG_MESSAGE_NOT_FOUND;
 
@@ -2697,16 +2715,19 @@ NS_IMETHODIMP nsMsgDatabase::AddNewHdrTo
   NS_ASSERTION(NS_SUCCEEDED(err), "error creating thread");
   return err;
 }
 
 NS_IMETHODIMP nsMsgDatabase::CopyHdrFromExistingHdr(nsMsgKey key,
                                                     nsIMsgDBHdr* existingHdr,
                                                     bool addHdrToDB,
                                                     nsIMsgDBHdr** newHdr) {
+  MOZ_CRASH("CopyHdrFromExistingHdr() needs a revamp");
+  // TODO: database should assign keys. Outside code shouldn't be demanding
+  // specific key values.
   nsresult err = NS_OK;
 
   if (existingHdr) {
     nsMsgHdr* sourceMsgHdr =
         static_cast<nsMsgHdr*>(existingHdr);  // closed system, cast ok
     nsMsgHdr* destMsgHdr = nullptr;
     CreateNewHdr(key, (nsIMsgDBHdr**)&destMsgHdr);
     nsIMdbRow* sourceRow = sourceMsgHdr->GetMDBRow();
diff --git a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
--- a/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgDatabase2.cpp
@@ -331,16 +331,46 @@ NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrF
   if (!exists) {
     return NS_MSG_MESSAGE_NOT_FOUND;
   }
   RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, key);
   msgHdr.forget(pmsgHdr);
   return NS_OK;
 }
 
+NS_IMETHODIMP nsMsgDatabase2::GetMsgKeysForUIDs(nsTArray<uint32_t> const& uids,
+                                                nsTArray<nsMsgKey>& keys) {
+  return DB().FolderGetKeysForUIDs(mFolderID, uids, keys);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgUIDsForKeys(nsTArray<nsMsgKey> const& keys,
+                                                nsTArray<uint32_t>& uids) {
+  return DB().FolderGetUIDsForKeys(mFolderID, keys, uids);
+}
+
+NS_IMETHODIMP nsMsgDatabase2::ContainsUID(uint32_t uid, bool* found) {
+  nsTArray<nsMsgKey> keys;
+  nsresult rv = DB().FolderGetKeysForUIDs(mFolderID, {uid}, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  *found = !keys.IsEmpty();
+  return NS_OK;
+}
+
+NS_IMETHODIMP nsMsgDatabase2::GetMsgHdrForUID(uint32_t uid, nsIMsgDBHdr** hdr) {
+  nsTArray<nsMsgKey> keys(1);
+  nsresult rv = DB().FolderGetKeysForUIDs(mFolderID, {uid}, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (keys.IsEmpty()) {
+    return NS_MSG_MESSAGE_NOT_FOUND;
+  }
+  RefPtr<nsMsgHdr2> msgHdr = new nsMsgHdr2(this, keys[0]);
+  msgHdr.forget(hdr);
+  return NS_OK;
+}
+
 NS_IMETHODIMP nsMsgDatabase2::DeleteMessage(nsMsgKey key,
                                             nsIDBChangeListener* instigator,
                                             bool commit) {
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
 
   nsresult rv = GetMsgHdrForKey(key, getter_AddRefs(msgHdr));
   if (!msgHdr) return NS_MSG_MESSAGE_NOT_FOUND;
 
diff --git a/mailnews/imap/public/nsIImapHeaderXferInfo.idl b/mailnews/imap/public/nsIImapHeaderXferInfo.idl
--- a/mailnews/imap/public/nsIImapHeaderXferInfo.idl
+++ b/mailnews/imap/public/nsIImapHeaderXferInfo.idl
@@ -3,17 +3,17 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 #include "MailNewsTypes2.idl"
 
 [scriptable, uuid(38f8f784-b092-11d6-ba4b-00108335942a)]
 interface nsIImapHeaderInfo : nsISupports {
-    attribute nsMsgKey  msgUid;
+    attribute unsigned long  msgUid;
     attribute long      msgSize;
     readonly attribute ACString msgHdrs;
     void cacheLine(in string line, in unsigned long uid);
     void resetCache();
 };
 
 [scriptable, uuid(f0842eda-af29-4ecd-82e1-fba91bd65d66)]
 interface nsIImapHeaderXferInfo : nsISupports {
diff --git a/mailnews/imap/public/nsIImapMailFolderSink.idl b/mailnews/imap/public/nsIImapMailFolderSink.idl
--- a/mailnews/imap/public/nsIImapMailFolderSink.idl
+++ b/mailnews/imap/public/nsIImapMailFolderSink.idl
@@ -78,26 +78,26 @@ interface nsIImapMailFolderSink : nsISup
                              in nsIMailboxSpec aSpec);
   void UpdateImapMailboxStatus(in nsIImapProtocol aProtocol,
                                in nsIMailboxSpec aSpec);
   /**
    * Used when downloading headers in chunks.
    * @param aSpec Mailbox spec of folder we're downloading headers for.
    * @returns true if more to download, false otherwise.
    * @returns total count of headers to download (across all chunks)
-   * @returns an array of msg keys to download, array size is this chunk's size
+   * @returns an array of msg UIDs to download, array size is this chunk's size
    */
   void getMsgHdrsToDownload(out boolean aMore, out long aTotalCount,
-                            out Array<nsMsgKey> aKeys);
+                            out Array<unsigned long> uids);
   void parseMsgHdrs(in nsIImapProtocol aProtocol, in nsIImapHeaderXferInfo aHdrXferInfo);
   void AbortHeaderParseStream(in nsIImapProtocol aProtocol) ;
 
   void OnlineCopyCompleted(in nsIImapProtocol aProtocol, in ImapOnlineCopyState aCopyState);
   void StartMessage(in nsIMsgMailNewsUrl aUrl);
-  void EndMessage(in nsIMsgMailNewsUrl aUrl, in nsMsgKey uidOfMessage);
+  void EndMessage(in nsIMsgMailNewsUrl aUrl, in unsigned long uidOfMessage);
 
   void NotifySearchHit(in nsIMsgMailNewsUrl aUrl, in string hitLine);
 
   void copyNextStreamMessage(in boolean copySucceeded, in nsISupports copyState);
   void closeMockChannel(in nsIImapMockChannel aChannel);
   void setUrlState(in nsIImapProtocol aProtocol, in nsIMsgMailNewsUrl aUrl,
                    in boolean isRunning, in boolean aSuspend,
                    in nsresult status);
@@ -108,12 +108,12 @@ interface nsIImapMailFolderSink : nsISup
   void progressStatusString(in nsIImapProtocol aProtocol, in string aMsgId, in wstring extraInfo);
   void percentProgress(in nsIImapProtocol aProtocol,
                        in ACString aFmtStringName, in AString aMailboxName,
                        in long long aCurrentProgress, in long long aMaxProgressProgressInfo);
 
   void clearFolderRights();
   void setCopyResponseUid(in string msgIdString,
                                 in nsIImapUrl aUrl);
-  void setAppendMsgUid(in nsMsgKey newKey,
+  void setAppendMsgUid(in unsigned long uid,
                              in nsIImapUrl aUrl);
   ACString getMessageId(in nsIImapUrl aUrl);
 };
diff --git a/mailnews/imap/public/nsIImapMessageSink.idl b/mailnews/imap/public/nsIImapMessageSink.idl
--- a/mailnews/imap/public/nsIImapMessageSink.idl
+++ b/mailnews/imap/public/nsIImapMessageSink.idl
@@ -30,48 +30,48 @@ interface nsIImapMessageSink : nsISuppor
    * Used by the imap protocol code to notify the core backend code about
    * downloaded imap messages.
    *
    * @param aAdoptedMsgLine  a string with a lot of message lines,
    *                         separated by native line terminators.
    * @param aUidOfMsg        IMAP UID of the fetched message.
    * @param aImapUrl         IMAP Url used to fetch the message.
    */
-  void parseAdoptedMsgLine(in string aAdoptedMsgLine, in nsMsgKey aUidOfMsg,
+  void parseAdoptedMsgLine(in string aAdoptedMsgLine, in unsigned long aUidOfMsg,
                            in nsIImapUrl aImapUrl);
 
   /**
    * Notify the backend that the imap protocol is done downloading a message
    *
    * @param aUidOfMsg           IMAP UID of the fetched message.
    * @param aMarkMsgRead        Set the SEEN flag on the message.
    * @param aImapUrl            IMAP Url used to fetch the message.
    * @param aUpdatedMessageSize if this parameter is not -1, the stored size of the message
    *                            should be set to this value to reflect the actual size of
    *                            the downloaded message.
    */
-  void normalEndMsgWriteStream(in nsMsgKey aUidOfMessage,
+  void normalEndMsgWriteStream(in unsigned long aUidOfMessage,
                                in boolean aMarkMsgRead, in nsIImapUrl aImapUrl,
                                in long aUpdatedMessageSize);
 
   void abortMsgWriteStream();
 
   void beginMessageUpload();
 
   /**
    *  Notify the message sink that one or more flags have changed
    *  For Condstore servers, also update the highestMod Sequence
    *  @param   aFlags         - The new flags for the message
-   *  @param   aKeywords        keywords for the message
-   *  @param   aMessageKey    - The UID of the message that changed
+   *  @param   aKeywords      - keywords for the message
+   *  @param   msgUID         - The UID of the message that changed
    *  @param   aHighestModSeq - The highest mod seq the parser has seen
    *                            for this folder
   **/
   void notifyMessageFlags(in unsigned long aFlags, in ACString aKeywords,
-                          in nsMsgKey aMessageKey,
+                          in unsigned long msgUID,
                           in unsigned long long aHighestModSeq);
 
   void notifyMessageDeleted(in string aOnlineFolderName,in boolean aDeleteAllMsgs,in string aMsgIdString);
 
   void getMessageSizeFromDB(in string aId, out unsigned long aSize);
 
   /**
    * For a message stored in a file, get the message metadata needed to copy
diff --git a/mailnews/imap/public/nsIImapProtocol.idl b/mailnews/imap/public/nsIImapProtocol.idl
--- a/mailnews/imap/public/nsIImapProtocol.idl
+++ b/mailnews/imap/public/nsIImapProtocol.idl
@@ -1,15 +1,14 @@
 /* -*- Mode: IDL; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
-#include "MailNewsTypes2.idl"  // for nsMsgKey
 
 interface nsIURI;
 interface nsIImapUrl;
 interface nsIImapIncomingServer;
 interface nsIMsgFolder;
 interface nsIMsgWindow;
 interface nsIImapFlagAndUidState;
 
@@ -49,17 +48,17 @@ interface nsIImapProtocol : nsISupports 
 
   /**
    * Initialize a protocol object.
    * @param aHostSessionList host session list service
    * @param aServer imap server the protocol object will be talking to
    */
   void Initialize(in nsIImapHostSessionList aHostSessionList, in nsIImapIncomingServer aServer);
 
-  void NotifyBodysToDownload(in Array<nsMsgKey> keys);
+  void NotifyBodysToDownload(in Array<unsigned long> uids);
 
   // methods to get data from the imap parser flag state.
   void GetFlagsForUID(in unsigned long uid, out boolean foundIt, out unsigned short flags, out string customFlags);
   void GetSupportedUserFlags(out unsigned short flags);
 
   void GetRunningImapURL(out nsIImapUrl aImapUrl);
 
   void GetRunningUrl(out nsIURI aUrl);
diff --git a/mailnews/imap/src/nsAutoSyncState.cpp b/mailnews/imap/src/nsAutoSyncState.cpp
--- a/mailnews/imap/src/nsAutoSyncState.cpp
+++ b/mailnews/imap/src/nsAutoSyncState.cpp
@@ -1,14 +1,15 @@
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsAutoSyncState.h"
 #include "nsImapMailFolder.h"
+#include "nsImapUtils.h"
 #include "nsIImapService.h"
 #include "nsIMsgMailNewsUrl.h"
 #include "nsIMsgMailSession.h"
 #include "nsMsgFolderFlags.h"
 #include "nsIAutoSyncManager.h"
 #include "nsIAutoSyncMsgStrategy.h"
 #include "nsServiceManagerUtils.h"
 #include "nsComponentManagerUtils.h"
@@ -663,20 +664,33 @@ NS_IMETHODIMP nsAutoSyncState::IsDownloa
 NS_IMETHODIMP nsAutoSyncState::DownloadMessagesForOffline(
     nsTArray<RefPtr<nsIMsgDBHdr>> const& messages) {
   nsresult rv;
   nsCOMPtr<nsIImapService> imapService =
       do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoCString messageIds;
-  nsTArray<nsMsgKey> msgKeys;
+  {
+    nsTArray<uint32_t> uids(messages.Length());
+    for (nsIMsgDBHdr* msg : messages) {
+      uint32_t uid;
+      rv = msg->GetImapUID(&uid);
+      NS_ENSURE_SUCCESS(rv, rv);
+    }
+    if (uids.IsEmpty()) {
+      return NS_OK;
+    }
 
-  rv = nsImapMailFolder::BuildIdsAndKeyArray(messages, messageIds, msgKeys);
-  if (NS_FAILED(rv) || messageIds.IsEmpty()) return rv;
+    rv = BuildUIDSet(uids, messageIds);
+    NS_ENSURE_SUCCESS(rv, rv);
+  }
+  if (messageIds.IsEmpty()) {
+    return NS_OK;
+  }
 
   // acquire semaphore for offline store. If it fails, we won't download
   nsCOMPtr<nsIMsgFolder> folder = do_QueryReferent(mOwnerFolder, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = folder->AcquireSemaphore(folder);
   NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -985,21 +985,20 @@ NS_IMETHODIMP nsImapMailFolder::CreateCl
 
       // store the online name as the mailbox name in the db folder info
       // I don't think anyone uses the mailbox name, so we'll use it
       // to restore the online name when blowing away an imap db.
       if (folderInfo)
         folderInfo->SetMailboxName(NS_ConvertUTF8toUTF16(onlineName));
     }
 
-    unusedDB->SetSummaryValid(true);
-    unusedDB->Commit(nsMsgDBCommitType::kLargeCommit);
-    unusedDB->Close(true);
-    // don't want to hold onto this newly created db.
-    child->SetMsgDatabase(nullptr);
+    childDB->SetSummaryValid(true);
+    childDB->Commit(nsMsgDBCommitType::kLargeCommit);
+    childDB->Close(true);
+    child->SetMsgDatabase(childDB);
   }
 
   if (!suppressNotification) {
     if (NS_SUCCEEDED(rv) && child) {
       NotifyFolderAdded(child);
       child->NotifyFolderEvent(kFolderCreateCompleted);
       nsCOMPtr<nsIMsgFolderNotificationService> notifier(
           do_GetService("@mozilla.org/messenger/msgnotificationservice;1"));
@@ -1804,20 +1803,22 @@ nsImapMailFolder::AddMessageDispositionS
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::MarkMessagesRead(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& messages, bool markRead) {
   // tell the folder to do it, which will mark them read in the db.
   nsresult rv = nsMsgDBFolder::MarkMessagesRead(messages, markRead);
   if (NS_SUCCEEDED(rv)) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> keysToMarkRead;
-    rv = BuildIdsAndKeyArray(messages, messageIds, keysToMarkRead);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsTArray<nsMsgKey> keysToMarkRead(messages.Length());
+    for (nsIMsgDBHdr* msg : messages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      keysToMarkRead.AppendElement(key);
+    }
 
     StoreImapFlags(kImapMsgSeenFlag, markRead, keysToMarkRead, nullptr);
     rv = GetDatabase();
     if (NS_SUCCEEDED(rv)) mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   return rv;
 }
 
@@ -1914,20 +1915,22 @@ NS_IMETHODIMP nsImapMailFolder::WriteToF
 
 NS_IMETHODIMP
 nsImapMailFolder::MarkMessagesFlagged(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& messages, bool markFlagged) {
   nsresult rv;
   // tell the folder to do it, which will mark them read in the db.
   rv = nsMsgDBFolder::MarkMessagesFlagged(messages, markFlagged);
   if (NS_SUCCEEDED(rv)) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> keysToMarkFlagged;
-    rv = BuildIdsAndKeyArray(messages, messageIds, keysToMarkFlagged);
-    if (NS_FAILED(rv)) return rv;
+    nsTArray<nsMsgKey> keysToMarkFlagged(messages.Length());
+    for (nsIMsgDBHdr* msg : messages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      keysToMarkFlagged.AppendElement(key);
+    }
     rv = StoreImapFlags(kImapMsgFlaggedFlag, markFlagged, keysToMarkFlagged,
                         nullptr);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = GetDatabase();
     NS_ENSURE_SUCCESS(rv, rv);
     mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   return rv;
@@ -2008,71 +2011,16 @@ nsImapMailFolder::GetDBFolderInfoAndDB(n
       m_onlineFolderName.Assign(onlineCName);
       CopyUTF8toUTF16(onlineCName, autoOnlineName);
     }
     (*folderInfo)->SetProperty("onlineName", autoOnlineName);
   }
   return rv;
 }
 
-/* static */
-nsresult nsImapMailFolder::BuildIdsAndKeyArray(
-    const nsTArray<RefPtr<nsIMsgDBHdr>>& messages, nsCString& msgIds,
-    nsTArray<nsMsgKey>& keyArray) {
-  keyArray.Clear();
-  keyArray.SetCapacity(messages.Length());
-  // build up message keys.
-  for (auto msgDBHdr : messages) {
-    nsMsgKey key;
-    nsresult rv = msgDBHdr->GetMessageKey(&key);
-    if (NS_SUCCEEDED(rv)) keyArray.AppendElement(key);
-  }
-  return AllocateUidStringFromKeys(keyArray, msgIds);
-}
-
-/* static */
-nsresult nsImapMailFolder::AllocateUidStringFromKeys(
-    const nsTArray<nsMsgKey>& keys, nsCString& msgIds) {
-  if (keys.IsEmpty()) return NS_ERROR_INVALID_ARG;
-  nsresult rv = NS_OK;
-  uint32_t startSequence;
-  startSequence = keys[0];
-  uint32_t curSequenceEnd = startSequence;
-  uint32_t total = keys.Length();
-  // sort keys and then generate ranges instead of singletons!
-  nsTArray<nsMsgKey> sorted(keys.Clone());
-  sorted.Sort();
-  for (uint32_t keyIndex = 0; keyIndex < total; keyIndex++) {
-    uint32_t curKey = sorted[keyIndex];
-    uint32_t nextKey =
-        (keyIndex + 1 < total) ? sorted[keyIndex + 1] : 0xFFFFFFFF;
-    bool lastKey = (nextKey == 0xFFFFFFFF);
-
-    if (lastKey) curSequenceEnd = curKey;
-    if (nextKey == (uint32_t)curSequenceEnd + 1 && !lastKey) {
-      curSequenceEnd = nextKey;
-      continue;
-    }
-    if (curSequenceEnd > startSequence) {
-      AppendUid(msgIds, startSequence);
-      msgIds += ':';
-      AppendUid(msgIds, curSequenceEnd);
-      if (!lastKey) msgIds += ',';
-      startSequence = nextKey;
-      curSequenceEnd = startSequence;
-    } else {
-      startSequence = nextKey;
-      curSequenceEnd = startSequence;
-      AppendUid(msgIds, sorted[keyIndex]);
-      if (!lastKey) msgIds += ',';
-    }
-  }
-  return rv;
-}
-
 nsresult nsImapMailFolder::MarkMessagesImapDeleted(nsTArray<nsMsgKey>* keyArray,
                                                    bool deleted,
                                                    nsIMsgDatabase* db) {
   for (uint32_t kindex = 0; kindex < keyArray->Length(); kindex++) {
     nsMsgKey key = keyArray->ElementAt(kindex);
     db->MarkImapDeleted(key, deleted, nullptr);
   }
   return NS_OK;
@@ -2080,18 +2028,16 @@ nsresult nsImapMailFolder::MarkMessagesI
 
 NS_IMETHODIMP nsImapMailFolder::DeleteMessages(
     nsTArray<RefPtr<nsIMsgDBHdr>> const& msgHeaders, nsIMsgWindow* msgWindow,
     bool deleteStorage, bool isMove, nsIMsgCopyServiceListener* listener,
     bool allowUndo) {
   // *** jt - assuming delete is move to the trash folder for now
   nsAutoCString uri;
   bool deleteImmediatelyNoTrash = false;
-  nsAutoCString messageIds;
-  nsTArray<nsMsgKey> srcKeyArray;
   bool deleteMsgs = true;  // used for toggling delete status - default is true
   nsMsgImapDeleteModel deleteModel = nsMsgImapDeleteModels::MoveToTrash;
   imapMessageFlagsType messageFlags = kImapMsgDeletedFlag;
 
   nsCOMPtr<nsIImapIncomingServer> imapServer;
   nsresult rv = GetFlag(nsMsgFolderFlags::Trash, &deleteImmediatelyNoTrash);
   rv = GetImapIncomingServer(getter_AddRefs(imapServer));
 
@@ -2100,18 +2046,22 @@ NS_IMETHODIMP nsImapMailFolder::DeleteMe
     if (deleteModel != nsMsgImapDeleteModels::MoveToTrash || deleteStorage)
       deleteImmediatelyNoTrash = true;
     // if we're deleting a message, we should pseudo-interrupt the msg
     // load of the current message.
     bool interrupted = false;
     imapServer->PseudoInterruptMsgLoad(this, msgWindow, &interrupted);
   }
 
-  rv = BuildIdsAndKeyArray(msgHeaders, messageIds, srcKeyArray);
-  if (NS_FAILED(rv)) return rv;
+  nsTArray<nsMsgKey> srcKeyArray(msgHeaders.Length());
+  for (nsIMsgDBHdr* msg : msgHeaders) {
+    nsMsgKey key;
+    msg->GetMessageKey(&key);
+    srcKeyArray.AppendElement(key);
+  }
 
   nsCOMPtr<nsIMsgFolder> rootFolder;
   nsCOMPtr<nsIMsgFolder> trashFolder;
 
   if (!deleteImmediatelyNoTrash) {
     rv = GetRootFolder(getter_AddRefs(rootFolder));
     if (NS_SUCCEEDED(rv) && rootFolder) {
       rootFolder->GetFolderWithFlags(nsMsgFolderFlags::Trash,
@@ -2123,21 +2073,18 @@ NS_IMETHODIMP nsImapMailFolder::DeleteMe
     }
   }
 
   if ((NS_SUCCEEDED(rv) && deleteImmediatelyNoTrash) ||
       deleteModel == nsMsgImapDeleteModels::IMAPDelete) {
     if (allowUndo) {
       // need to take care of these two delete models
       RefPtr<nsImapMoveCopyMsgTxn> undoMsgTxn = new nsImapMoveCopyMsgTxn;
-      if (!undoMsgTxn ||
-          NS_FAILED(undoMsgTxn->Init(this, &srcKeyArray, messageIds.get(),
-                                     nullptr, true, isMove)))
-        return NS_ERROR_OUT_OF_MEMORY;
-
+      rv = undoMsgTxn->Init(this, &srcKeyArray, nullptr, true, isMove);
+      MOZ_ASSERT(NS_SUCCEEDED(rv));
       undoMsgTxn->SetTransactionType(nsIMessenger::eDeleteMsg);
       // we're adding this undo action before the delete is successful. This is
       // evil, but 4.5 did it as well.
       nsCOMPtr<nsITransactionManager> txnMgr;
       if (msgWindow) msgWindow->GetTransactionManager(getter_AddRefs(txnMgr));
       if (txnMgr) txnMgr->DoTransaction(undoMsgTxn);
     }
 
@@ -2486,18 +2433,18 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm
   ChangeNumPendingUnread(-mNumPendingUnreadMessages);
   m_numServerRecentMessages = 0;  // clear this since we selected the folder.
 
   if (!mDatabase) GetDatabase();
 
   bool folderSelected;
   rv = aSpec->GetFolderSelected(&folderSelected);
   NS_ENSURE_SUCCESS(rv, rv);
-  nsTArray<nsMsgKey> existingKeys;
-  nsTArray<nsMsgKey> keysToDelete;
+  nsTArray<uint32_t> existingUIDs;
+  nsTArray<uint32_t> uidsToDelete;
   uint32_t numNewUnread;
   nsCOMPtr<nsIDBFolderInfo> dbFolderInfo;
   int32_t imapUIDValidity = 0;
   if (mDatabase) {
     rv = mDatabase->GetDBFolderInfo(getter_AddRefs(dbFolderInfo));
     if (NS_SUCCEEDED(rv) && dbFolderInfo) {
       dbFolderInfo->GetImapUidValidity(&imapUIDValidity);
       uint64_t mailboxHighestModSeq;
@@ -2509,36 +2456,50 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm
       char intStrBuf[40];
       PR_snprintf(intStrBuf, sizeof(intStrBuf), "%llu", mailboxHighestModSeq);
       dbFolderInfo->SetCharProperty(kModSeqPropertyName,
                                     nsDependentCString(intStrBuf));
     }
     nsTArray<nsMsgKey> keys;
     rv = mDatabase->ListAllKeys(keys);
     NS_ENSURE_SUCCESS(rv, rv);
-    existingKeys.AppendElements(keys);
+    rv = mDatabase->GetMsgUIDsForKeys(keys, existingUIDs);
+    NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIMsgOfflineOpsDatabase> opsDb =
         do_QueryInterface(mDatabase, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
-    opsDb->ListAllOfflineDeletes(existingKeys);
+    {
+      nsTArray<uint32_t> offlineDeleteUIDs;
+      nsTArray<nsMsgKey> offlineDeleteKeys;
+      opsDb->ListAllOfflineDeletes(offlineDeleteKeys);
+      rv = mDatabase->GetMsgUIDsForKeys(offlineDeleteKeys, offlineDeleteUIDs);
+      NS_ENSURE_SUCCESS(rv, rv);
+      existingUIDs.AppendElements(offlineDeleteUIDs);
+    }
   }
   int32_t folderValidity;
   aSpec->GetFolder_UIDVALIDITY(&folderValidity);
   nsCOMPtr<nsIImapFlagAndUidState> flagState;
   aSpec->GetFlagState(getter_AddRefs(flagState));
 
   // remember what the supported user flags are.
   uint32_t supportedUserFlags;
   aSpec->GetSupportedUserFlags(&supportedUserFlags);
   SetSupportedUserFlags(supportedUserFlags);
 
   m_uidValidity = folderValidity;
 
-  if (imapUIDValidity != folderValidity) {
-    // TODO: rewrite this!
+  // Previously, this code would run on first use (because we had no
+  // UIDVALIDITY).
+  if (imapUIDValidity != kUidUnknown && imapUIDValidity != folderValidity) {
+    // TODO: Are there servers in the wild which do change UIDVALIDITY?
+    // Or can we ditch this?
+    // If we need to do handle it, it needs a lot of work.
+    MOZ_CRASH("UIDVALIDITY change not supported (yet)");
+#if 0
     NS_ASSERTION(imapUIDValidity == kUidUnknown,
                  "uid validity seems to have changed, blowing away db");
     nsCOMPtr<nsIFile> pathFile;
     rv = GetFilePath(getter_AddRefs(pathFile));
     if (NS_FAILED(rv)) return rv;
 
     nsCOMPtr<nsIMsgDBService> msgDBService =
         do_GetService("@mozilla.org/msgDatabase/msgDBService;1", &rv);
@@ -2595,41 +2556,44 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm
               ("UpdateImapMailboxInfo(): UIDVALIDITY changed, reset highest "
                "MODSEQ and UID for folder=%s",
                m_onlineFolderName.get()));
       dbFolderInfo->SetCharProperty(kModSeqPropertyName, EmptyCString());
       dbFolderInfo->SetUint32Property(kHighestRecordedUIDPropertyName, 0);
     }
     // delete all my msgs, the keys are bogus now
     // add every message in this folder
-    existingKeys.Clear();
-    //      keysToDelete.CopyArray(&existingKeys);
+    existingUIDs.Clear();
+    //      uidsToDelete.CopyArray(&existingUIDs);
 
     if (flagState) {
-      nsTArray<nsMsgKey> no_existingKeys;
-      FindKeysToAdd(no_existingKeys, m_keysToFetch, numNewUnread, flagState);
+      FindUIDsToAdd({}, m_uidsToFetch, numNewUnread, flagState);
     }
     if (NS_FAILED(rv)) pathFile->Remove(false);
-
+#endif
   } else if (!flagState /*&& !NET_IsOffline() */)  // if there are no messages
                                                    // on the server
-    keysToDelete = existingKeys.Clone();
+    uidsToDelete = existingUIDs.Clone();
   else /* if ( !NET_IsOffline()) */
   {
     uint32_t boxFlags;
     aSpec->GetBox_flags(&boxFlags);
-    // FindKeysToDelete and FindKeysToAdd require sorted lists
-    existingKeys.Sort();
-    FindKeysToDelete(existingKeys, keysToDelete, flagState, boxFlags);
+    // FindUIDsToDelete and FindUIDsToAdd require sorted lists
+    existingUIDs.Sort();
+    FindUIDsToDelete(existingUIDs, uidsToDelete, flagState, boxFlags);
     // if this is the result of an expunge then don't grab headers
-    if (!(boxFlags & kJustExpunged))
-      FindKeysToAdd(existingKeys, m_keysToFetch, numNewUnread, flagState);
-  }
-  m_totalKeysToFetch = m_keysToFetch.Length();
-  if (!keysToDelete.IsEmpty() && mDatabase) {
+    if (!(boxFlags & kJustExpunged)) {
+      FindUIDsToAdd(existingUIDs, m_uidsToFetch, numNewUnread, flagState);
+    }
+  }
+  m_totalUIDsToFetch = m_uidsToFetch.Length();
+  if (!uidsToDelete.IsEmpty() && mDatabase) {
+    nsTArray<nsMsgKey> keysToDelete;
+    rv = mDatabase->GetMsgKeysForUIDs(uidsToDelete, keysToDelete);
+    NS_ENSURE_SUCCESS(rv, rv);
     nsTArray<RefPtr<nsIMsgDBHdr>> hdrsToDelete;
     MsgGetHeadersFromKeys(mDatabase, keysToDelete, hdrsToDelete);
     // Notify nsIMsgFolderListeners of a mass delete, but only if we actually
     // have headers
     if (!hdrsToDelete.IsEmpty()) {
       nsCOMPtr<nsIMsgFolderNotificationService> notifier(
           do_GetService("@mozilla.org/messenger/msgnotificationservice;1"));
       if (notifier) notifier->NotifyMsgsDeleted(hdrsToDelete);
@@ -2659,21 +2623,21 @@ NS_IMETHODIMP nsImapMailFolder::UpdateIm
     // Otherwise the stand-alone biff won't fire.
     nsCOMPtr<nsIMsgIncomingServer> server;
     if (NS_SUCCEEDED(GetServer(getter_AddRefs(server))) && server)
       server->SetPerformingBiff(true);
     SetNumNewMessages(numNewUnread);
   }
   SyncFlags(flagState);
   if (mDatabase && numUnreadFromServer > -1 &&
-      (int32_t)(mNumUnreadMessages + m_keysToFetch.Length()) >
+      (int32_t)(mNumUnreadMessages + m_uidsToFetch.Length()) >
           numUnreadFromServer)
     mDatabase->SyncCounts();
 
-  if (!m_keysToFetch.IsEmpty() && aProtocol)
+  if (!m_uidsToFetch.IsEmpty() && aProtocol)
     PrepareToAddHeadersToMailDB(aProtocol);
   else {
     bool gettingNewMessages;
     GetGettingNewMessages(&gettingNewMessages);
     if (gettingNewMessages)
       ProgressStatusString(aProtocol, "imapNoNewMessages", nullptr);
     SetPerformingBiff(false);
   }
@@ -2768,47 +2732,46 @@ NS_IMETHODIMP nsImapMailFolder::ParseMsg
     (void)aProtocol->GetRunningImapURL(getter_AddRefs(aImapUrl));
     if (aImapUrl) aImapUrl->GetImapAction(&imapAction);
   }
   for (uint32_t i = 0; NS_SUCCEEDED(rv) && (int32_t)i < numHdrs; i++) {
     rv = aHdrXferInfo->GetHeader(i, getter_AddRefs(headerInfo));
     NS_ENSURE_SUCCESS(rv, rv);
     if (!headerInfo) break;
     int32_t msgSize;
-    nsMsgKey msgKey;
-    bool containsKey;
+    nsMsgKey msgUID;
     nsCString msgHdrs;
     headerInfo->GetMsgSize(&msgSize);
-    headerInfo->GetMsgUid(&msgKey);
-    if (msgKey == nsMsgKey_None)  // not a valid uid.
+    headerInfo->GetMsgUid(&msgUID);
+    if (msgUID == 0)  // not a valid uid.
       continue;
     if (imapAction == nsIImapUrl::nsImapMsgPreview) {
-      nsCOMPtr<nsIMsgDBHdr> msgHdr;
       headerInfo->GetMsgHdrs(msgHdrs);
       // create an input stream based on the hdr string.
       nsCOMPtr<nsIStringInputStream> inputStream =
           do_CreateInstance("@mozilla.org/io/string-input-stream;1", &rv);
       NS_ENSURE_SUCCESS(rv, rv);
       inputStream->ShareData(msgHdrs.get(), msgHdrs.Length());
-      GetMessageHeader(msgKey, getter_AddRefs(msgHdr));
+      nsCOMPtr<nsIMsgDBHdr> msgHdr;
+      rv = mDatabase->GetMsgHdrForUID(msgUID, getter_AddRefs(msgHdr));
       if (msgHdr) {
         GetMsgPreviewTextFromStream(msgHdr, inputStream);
       }
       continue;
     }
-    if (mDatabase &&
-        NS_SUCCEEDED(mDatabase->ContainsKey(msgKey, &containsKey)) &&
-        containsKey) {
+    bool gotMsg;
+    if (mDatabase && NS_SUCCEEDED(mDatabase->ContainsUID(msgUID, &gotMsg)) &&
+        gotMsg) {
       NS_ERROR("downloading hdrs for hdr we already have");
       continue;
     }
     nsresult rv = SetupHeaderParseStream(msgSize, EmptyCString(), nullptr);
     NS_ENSURE_SUCCESS(rv, rv);
     headerInfo->GetMsgHdrs(msgHdrs);
-    rv = ParseAdoptedHeaderLine(msgHdrs.get(), msgKey);
+    rv = ParseAdoptedHeaderLine(msgHdrs.get(), msgUID);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = NormalEndHeaderParseStream(aProtocol, aImapUrl);
   }
   return rv;
 }
 
 nsresult nsImapMailFolder::SetupHeaderParseStream(
     uint32_t aSize, const nsACString& content_type, nsIMailboxSpec* boxSpec) {
@@ -2822,24 +2785,21 @@ nsresult nsImapMailFolder::SetupHeaderPa
     m_msgParser->Clear();
 
   m_msgParser->SetMailDB(mDatabase);
   if (mBackupDatabase) m_msgParser->SetBackupMailDB(mBackupDatabase);
   return m_msgParser->SetState(nsIMsgParseMailMsgState::ParseHeadersState);
 }
 
 nsresult nsImapMailFolder::ParseAdoptedHeaderLine(const char* aMessageLine,
-                                                  nsMsgKey aMsgKey) {
+                                                  uint32_t msgUID) {
   // we can get blocks that contain more than one line,
   // but they never contain partial lines
   const char* str = aMessageLine;
-  m_curMsgUid = aMsgKey;
-  m_msgParser->SetNewKey(m_curMsgUid);
-  // m_envelope_pos, for local folders,
-  // is the msg key. Setting this will set the msg key for the new header.
+  m_curMsgUid = msgUID;
 
   int32_t len = strlen(str);
   char* currentEOL = PL_strstr(str, MSG_LINEBREAK);
   const char* currentLine = str;
   while (currentLine < (str + len)) {
     if (currentEOL) {
       m_msgParser->ParseAFolderLine(
           currentLine, (currentEOL + MSG_LINEBREAK_LEN) - currentLine);
@@ -2861,16 +2821,19 @@ nsresult nsImapMailFolder::NormalEndHead
 
   nsMailboxParseState parseState;
   m_msgParser->GetState(&parseState);
   if (parseState == nsIMsgParseMailMsgState::ParseHeadersState)
     m_msgParser->ParseAFolderLine(CRLF, 2);
   rv = m_msgParser->GetNewMsgHdr(getter_AddRefs(newMsgHdr));
   NS_ENSURE_SUCCESS(rv, rv);
 
+  nsMsgKey newMsgKey;
+  newMsgHdr->GetMessageKey(&newMsgKey);
+
   char* headers;
   int32_t headersSize;
 
   nsCOMPtr<nsIMsgWindow> msgWindow;
   nsCOMPtr<nsIMsgMailNewsUrl> msgUrl;
   if (imapUrl) {
     msgUrl = do_QueryInterface(imapUrl, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -2880,24 +2843,24 @@ nsresult nsImapMailFolder::NormalEndHead
   nsCOMPtr<nsIMsgIncomingServer> server;
   rv = GetServer(getter_AddRefs(server));
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIImapIncomingServer> imapServer = do_QueryInterface(server);
   rv = imapServer->GetIsGMailServer(&m_isGmailServer);
   NS_ENSURE_SUCCESS(rv, rv);
 
-  newMsgHdr->SetMessageKey(m_curMsgUid);
+  newMsgHdr->SetImapUID(m_curMsgUid);
   TweakHeaderFlags(aProtocol, newMsgHdr);
   uint32_t messageSize;
   if (NS_SUCCEEDED(newMsgHdr->GetMessageSize(&messageSize)))
     mFolderSize += messageSize;
   m_msgMovedByFilter = false;
 
-  nsMsgKey highestUID = 0;
+  uint32_t highestUID = 0;
   nsCOMPtr<nsIDBFolderInfo> dbFolderInfo;
   if (mDatabase) mDatabase->GetDBFolderInfo(getter_AddRefs(dbFolderInfo));
   if (dbFolderInfo)
     dbFolderInfo->GetUint32Property(kHighestRecordedUIDPropertyName, 0,
                                     &highestUID);
 
   // If this is the inbox, try to apply filters. Otherwise, test the inherited
   // folder property "applyIncomingFilters" (which defaults to empty). If this
@@ -2942,34 +2905,34 @@ nsresult nsImapMailFolder::NormalEndHead
           // Same for deleting it or moving it to trash.
           switch (duplicateAction) {
             case nsIMsgIncomingServer::deleteDups: {
               uint32_t newFlags;
               newMsgHdr->OrFlags(
                   nsMsgMessageFlags::Read | nsMsgMessageFlags::IMAPDeleted,
                   &newFlags);
               StoreImapFlags(kImapMsgSeenFlag | kImapMsgDeletedFlag, true,
-                             {m_curMsgUid}, nullptr);
+                             {newMsgKey}, nullptr);
               m_msgMovedByFilter = true;
             } break;
             case nsIMsgIncomingServer::moveDupsToTrash: {
               nsCOMPtr<nsIMsgFolder> trash;
               GetTrashFolder(getter_AddRefs(trash));
               if (trash) {
                 nsCString trashUri;
                 trash->GetURI(trashUri);
                 nsresult err = MoveIncorporatedMessage(
                     newMsgHdr, mDatabase, trashUri, nullptr, msgWindow);
                 if (NS_SUCCEEDED(err)) m_msgMovedByFilter = true;
               }
             } break;
             case nsIMsgIncomingServer::markDupsRead: {
               uint32_t newFlags;
               newMsgHdr->OrFlags(nsMsgMessageFlags::Read, &newFlags);
-              StoreImapFlags(kImapMsgSeenFlag, true, {m_curMsgUid}, nullptr);
+              StoreImapFlags(kImapMsgSeenFlag, true, {newMsgKey}, nullptr);
             } break;
           }
           int32_t numNewMessages;
           GetNumNewMessages(false, &numNewMessages);
           SetNumNewMessages(numNewMessages - 1);
         }
       }
       rv = m_msgParser->GetAllHeaders(&headers, &headersSize);
@@ -3004,17 +2967,17 @@ nsresult nsImapMailFolder::NormalEndHead
         m_pseudoHdrs.MaybeGet(newMessageId).valueOr(nsMsgKey_None);
     if (notifier && pseudoKey != nsMsgKey_None) {
       notifier->NotifyMsgKeyChanged(pseudoKey, newMsgHdr);
       m_pseudoHdrs.Remove(newMessageId);
     }
     mDatabase->AddNewHdrToDB(newMsgHdr, true);
     if (notifier) notifier->NotifyMsgAdded(newMsgHdr);
     // mark the header as not yet reported classified
-    OrProcessingFlags(m_curMsgUid, nsMsgProcessingFlags::NotReportedClassified);
+    OrProcessingFlags(newMsgKey, nsMsgProcessingFlags::NotReportedClassified);
   }
   // adjust highestRecordedUID
   if (dbFolderInfo) {
     if (m_curMsgUid > highestUID) {
       MOZ_LOG(IMAP_CS, mozilla::LogLevel::Debug,
               ("NormalEndHeaderParseStream(): Store new highest UID=%" PRIu32
                " for folder=%s",
                m_curMsgUid, m_onlineFolderName.get()));
@@ -3024,16 +2987,18 @@ nsresult nsImapMailFolder::NormalEndHead
   }
 
   if (m_isGmailServer) {
     nsCOMPtr<nsIImapFlagAndUidState> flagState;
     aProtocol->GetFlagAndUidState(getter_AddRefs(flagState));
     nsCString msgIDValue;
     nsCString threadIDValue;
     nsCString labelsValue;
+    MOZ_CRASH("BenC - this needs work");
+    // BenC TODO: should be UIDs or msgKeys here?
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-MSGID"_ns, msgIDValue);
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-THRID"_ns, threadIDValue);
     flagState->GetCustomAttribute(m_curMsgUid, "X-GM-LABELS"_ns, labelsValue);
     newMsgHdr->SetStringProperty("X-GM-MSGID", msgIDValue.get());
     newMsgHdr->SetStringProperty("X-GM-THRID", threadIDValue.get());
     newMsgHdr->SetStringProperty("X-GM-LABELS", labelsValue.get());
   }
 
@@ -3200,17 +3165,17 @@ NS_IMETHODIMP nsImapMailFolder::EndCopy(
             ("EndCopy failed: %" PRIx32, static_cast<uint32_t>(rv)));
   return rv;
 }
 
 NS_IMETHODIMP nsImapMailFolder::EndMove(bool moveSucceeded) { return NS_OK; }
 // this is the beginning of the next message copied
 NS_IMETHODIMP nsImapMailFolder::StartMessage() { return NS_OK; }
 
-// just finished the current message.
+// nsICopyMessageListener.endMessage()
 NS_IMETHODIMP nsImapMailFolder::EndMessage(nsMsgKey key) { return NS_OK; }
 
 NS_IMETHODIMP nsImapMailFolder::ApplyFilterHit(nsIMsgFilter* filter,
                                                nsIMsgWindow* msgWindow,
                                                bool* applyMore) {
   //
   //  This routine is called indirectly from ApplyFiltersToHdr in two
   //  circumstances, controlled by m_filterListRequiresBody:
@@ -3226,20 +3191,22 @@ NS_IMETHODIMP nsImapMailFolder::ApplyFil
   //
 
   NS_ENSURE_ARG_POINTER(filter);
   NS_ENSURE_ARG_POINTER(applyMore);
 
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgDBHdr> msgHdr;
-  if (m_filterListRequiresBody)
-    GetMessageHeader(m_curMsgUid, getter_AddRefs(msgHdr));
-  else if (m_msgParser)
+  if (m_filterListRequiresBody) {
+    rv = mDatabase->GetMsgHdrForUID(m_curMsgUid, getter_AddRefs(msgHdr));
+    NS_ENSURE_SUCCESS(rv, rv);
+  } else if (m_msgParser) {
     m_msgParser->GetNewMsgHdr(getter_AddRefs(msgHdr));
+  }
   NS_ENSURE_TRUE(msgHdr,
                  NS_ERROR_NULL_POINTER);  // fatal error, cannot apply filters
 
   bool deleteToTrash = DeleteIsMoveToTrash();
 
   nsTArray<RefPtr<nsIMsgRuleAction>> filterActionList;
   rv = filter->GetSortedActionList(filterActionList);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -3667,19 +3634,21 @@ nsImapMailFolder::ReplayOfflineMoveCopy(
     // if we can't get the dst folder db, we should still try to playback
     // the offline move/copy.
   }
 
   nsCOMPtr<nsIImapService> imapService =
       do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIURI> resultUrl;
-  nsAutoCString uids;
-  AllocateUidStringFromKeys(aMsgKeys, uids);
-  rv = imapService->OnlineMessageCopy(this, uids, aDstFolder, true, isMove,
+
+  nsAutoCString uidSet;
+  rv = MsgKeysToUIDSet(mDatabase, aMsgKeys, uidSet);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = imapService->OnlineMessageCopy(this, uidSet, aDstFolder, true, isMove,
                                       aUrlListener, getter_AddRefs(resultUrl),
                                       nullptr, aWindow);
   if (resultUrl) {
     nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(resultUrl, &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIUrlListener> folderListener = do_QueryInterface(aDstFolder);
     if (folderListener) mailnewsUrl->RegisterListener(folderListener);
   }
@@ -3705,29 +3674,31 @@ NS_IMETHODIMP nsImapMailFolder::StoreIma
                                                const nsTArray<nsMsgKey>& keys,
                                                nsIUrlListener* aUrlListener) {
   nsresult rv;
   if (!WeAreOffline()) {
     nsCOMPtr<nsIImapService> imapService =
         do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsAutoCString msgIds;
-    AllocateUidStringFromKeys(keys, msgIds);
+    rv = MsgKeysToUIDSet(mDatabase, keys, msgIds);
+    NS_ENSURE_SUCCESS(rv, rv);
     if (addFlags)
       imapService->AddMessageFlags(this, aUrlListener ? aUrlListener : this,
                                    msgIds, flags, true);
     else
       imapService->SubtractMessageFlags(
           this, aUrlListener ? aUrlListener : this, msgIds, flags, true);
   } else {
     rv = GetDatabase();
     if (NS_SUCCEEDED(rv) && mDatabase) {
       nsCOMPtr<nsIMsgOfflineOpsDatabase> opsDb =
           do_QueryInterface(mDatabase, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
+
       for (auto key : keys) {
         nsCOMPtr<nsIMsgOfflineImapOperation> op;
         rv = opsDb->GetOfflineOpForKey(key, true, getter_AddRefs(op));
         SetFlag(nsMsgFolderFlags::OfflineEvents);
         if (NS_SUCCEEDED(rv) && op) {
           imapMessageFlagsType newFlags;
           op->GetNewFlags(&newFlags);
           op->SetFlagOperation(addFlags ? newFlags | flags : newFlags & ~flags);
@@ -3946,44 +3917,44 @@ nsresult nsImapMailFolder::MoveIncorpora
     rv = NS_ERROR_UNEXPECTED;
 
   // we have to return an error because we do not actually move the message
   // it is done async and that can fail
   return rv;
 }
 
 /**
- * This method assumes that key arrays and flag states are sorted by increasing
- * key.
+ * This method assumes that uid arrays and flag states are sorted by increasing
+ * uid.
  */
-void nsImapMailFolder::FindKeysToDelete(const nsTArray<nsMsgKey>& existingKeys,
-                                        nsTArray<nsMsgKey>& keysToDelete,
+void nsImapMailFolder::FindUIDsToDelete(const nsTArray<uint32_t>& existingUIDs,
+                                        nsTArray<uint32_t>& uidsToDelete,
                                         nsIImapFlagAndUidState* flagState,
                                         uint32_t boxFlags) {
   bool showDeletedMessages = ShowDeletedMessages();
   int32_t numMessageInFlagState;
   bool partialUIDFetch;
   uint32_t uidOfMessage;
   imapMessageFlagsType flags;
 
   flagState->GetNumberOfMessages(&numMessageInFlagState);
   flagState->GetPartialUIDFetch(&partialUIDFetch);
 
-  // if we're doing a partialUIDFetch, just delete the keys from the db
+  // if we're doing a partialUIDFetch, just delete the msgs from the db
   // that have the deleted flag set (if not using imap delete model)
   // and return.
   if (partialUIDFetch) {
     if (!showDeletedMessages) {
       for (uint32_t i = 0; (int32_t)i < numMessageInFlagState; i++) {
         flagState->GetUidOfMessage(i, &uidOfMessage);
         // flag state will be zero filled up to first real uid, so ignore those.
         if (uidOfMessage) {
           flagState->GetMessageFlags(i, &flags);
           if (flags & kImapMsgDeletedFlag)
-            keysToDelete.AppendElement(uidOfMessage);
+            uidsToDelete.AppendElement(uidOfMessage);
         }
       }
     } else if (boxFlags & kJustExpunged) {
       // we've just issued an expunge with a partial flag state. We should
       // delete headers with the imap deleted flag set, because we can't
       // tell from the expunge response which messages were deleted.
       nsCOMPtr<nsIMsgEnumerator> hdrs;
       nsresult rv = GetMessages(getter_AddRefs(hdrs));
@@ -3991,112 +3962,109 @@ void nsImapMailFolder::FindKeysToDelete(
       bool hasMore = false;
       while (NS_SUCCEEDED(rv = hdrs->HasMoreElements(&hasMore)) && hasMore) {
         nsCOMPtr<nsIMsgDBHdr> header;
         rv = hdrs->GetNext(getter_AddRefs(header));
         NS_ENSURE_SUCCESS_VOID(rv);
         uint32_t msgFlags;
         header->GetFlags(&msgFlags);
         if (msgFlags & nsMsgMessageFlags::IMAPDeleted) {
-          nsMsgKey msgKey;
-          header->GetMessageKey(&msgKey);
-          keysToDelete.AppendElement(msgKey);
+          uint32_t uid;
+          header->GetImapUID(&uid);
+          uidsToDelete.AppendElement(uid);
         }
       }
     }
     return;
   }
   // otherwise, we have a complete set of uid's and flags, so we delete
-  // anything that's in existingKeys but not in the flag state, as well
+  // anything that's in existingUIDs but not in the flag state, as well
   // as messages with the deleted flag set.
-  uint32_t total = existingKeys.Length();
   int onlineIndex = 0;  // current index into flagState
-  for (uint32_t keyIndex = 0; keyIndex < total; keyIndex++) {
+  for (uint32_t existingUID : existingUIDs) {
     while (
         (onlineIndex < numMessageInFlagState) &&
         NS_SUCCEEDED(flagState->GetUidOfMessage(onlineIndex, &uidOfMessage)) &&
-        (existingKeys[keyIndex] > uidOfMessage))
+        (existingUID > uidOfMessage)) {
       onlineIndex++;
+    }
 
     flagState->GetUidOfMessage(onlineIndex, &uidOfMessage);
     flagState->GetMessageFlags(onlineIndex, &flags);
-    // delete this key if it is not there or marked deleted
+    // Delete msg if it is not there or marked deleted.
     if ((onlineIndex >= numMessageInFlagState) ||
-        (existingKeys[keyIndex] != uidOfMessage) ||
+        (existingUID != uidOfMessage) ||
         ((flags & kImapMsgDeletedFlag) && !showDeletedMessages)) {
-      nsMsgKey doomedKey = existingKeys[keyIndex];
-      if ((int32_t)doomedKey <= 0 && doomedKey != nsMsgKey_None) continue;
-
-      keysToDelete.AppendElement(existingKeys[keyIndex]);
+      MOZ_ASSERT(existingUID != 0);
+      uidsToDelete.AppendElement(existingUID);
     }
 
     flagState->GetUidOfMessage(onlineIndex, &uidOfMessage);
-    if (existingKeys[keyIndex] == uidOfMessage) onlineIndex++;
-  }
-}
-
-void nsImapMailFolder::FindKeysToAdd(const nsTArray<nsMsgKey>& existingKeys,
-                                     nsTArray<nsMsgKey>& keysToFetch,
+    if (existingUID == uidOfMessage) onlineIndex++;
+  }
+}
+
+void nsImapMailFolder::FindUIDsToAdd(const nsTArray<uint32_t>& existingUIDs,
+                                     nsTArray<uint32_t>& uidsToFetch,
                                      uint32_t& numNewUnread,
                                      nsIImapFlagAndUidState* flagState) {
   bool showDeletedMessages = ShowDeletedMessages();
-  int dbIndex = 0;  // current index into existingKeys
-  int32_t existTotal, numberOfKnownKeys;
+  int dbIndex = 0;  // current index into existingUIDs
+  int32_t existTotal, numberOfKnownUIDs;
   int32_t messageIndex;
 
   numNewUnread = 0;
-  existTotal = numberOfKnownKeys = existingKeys.Length();
+  existTotal = numberOfKnownUIDs = existingUIDs.Length();
   flagState->GetNumberOfMessages(&messageIndex);
   bool partialUIDFetch;
   flagState->GetPartialUIDFetch(&partialUIDFetch);
 
   for (int32_t flagIndex = 0; flagIndex < messageIndex; flagIndex++) {
     uint32_t uidOfMessage;
     flagState->GetUidOfMessage(flagIndex, &uidOfMessage);
-    while ((flagIndex < numberOfKnownKeys) && (dbIndex < existTotal) &&
-           existingKeys[dbIndex] < uidOfMessage)
+    while ((flagIndex < numberOfKnownUIDs) && (dbIndex < existTotal) &&
+           existingUIDs[dbIndex] < uidOfMessage)
       dbIndex++;
 
-    if ((flagIndex >= numberOfKnownKeys) || (dbIndex >= existTotal) ||
-        (existingKeys[dbIndex] != uidOfMessage)) {
-      numberOfKnownKeys++;
+    if ((flagIndex >= numberOfKnownUIDs) || (dbIndex >= existTotal) ||
+        (existingUIDs[dbIndex] != uidOfMessage)) {
+      numberOfKnownUIDs++;
 
       imapMessageFlagsType flags;
       flagState->GetMessageFlags(flagIndex, &flags);
-      NS_ASSERTION(uidOfMessage != nsMsgKey_None, "got invalid msg key");
-      if (uidOfMessage && uidOfMessage != nsMsgKey_None &&
+      NS_ASSERTION(uidOfMessage != 0, "got invalid msg UID");
+      if (uidOfMessage &&
           (showDeletedMessages || !(flags & kImapMsgDeletedFlag))) {
         if (mDatabase) {
-          bool dbContainsKey;
-          if (NS_SUCCEEDED(
-                  mDatabase->ContainsKey(uidOfMessage, &dbContainsKey)) &&
-              dbContainsKey) {
+          bool got;
+          if (NS_SUCCEEDED(mDatabase->ContainsUID(uidOfMessage, &got)) && got) {
             // this is expected in the partial uid fetch case because the
             // flag state does not contain all messages, so the db has
             // messages the flag state doesn't know about.
             if (!partialUIDFetch) NS_ERROR("db has key - flagState messed up?");
             continue;
           }
         }
-        keysToFetch.AppendElement(uidOfMessage);
+        uidsToFetch.AppendElement(uidOfMessage);
         if (!(flags & kImapMsgSeenFlag)) numNewUnread++;
       }
     }
   }
 }
 
-NS_IMETHODIMP nsImapMailFolder::GetMsgHdrsToDownload(
-    bool* aMoreToDownload, int32_t* aTotalCount, nsTArray<nsMsgKey>& aKeys) {
+NS_IMETHODIMP nsImapMailFolder::GetMsgHdrsToDownload(bool* aMoreToDownload,
+                                                     int32_t* aTotalCount,
+                                                     nsTArray<uint32_t>& uids) {
   NS_ENSURE_ARG_POINTER(aMoreToDownload);
   NS_ENSURE_ARG_POINTER(aTotalCount);
-  aKeys.Clear();
+  uids.Clear();
 
   *aMoreToDownload = false;
-  *aTotalCount = m_totalKeysToFetch;
-  if (m_keysToFetch.IsEmpty()) {
+  *aTotalCount = m_totalUIDsToFetch;
+  if (m_uidsToFetch.IsEmpty()) {
     return NS_OK;
   }
 
   // if folder isn't open in a window, no reason to limit the number of headers
   // we download.
   nsCOMPtr<nsIMsgMailSession> session =
       do_GetService("@mozilla.org/messenger/services/session;1");
   bool folderOpen = false;
@@ -4106,42 +4074,41 @@ NS_IMETHODIMP nsImapMailFolder::GetMsgHd
   if (folderOpen) {
     nsresult rv;
     nsCOMPtr<nsIPrefBranch> prefBranch(
         do_GetService(NS_PREFSERVICE_CONTRACTID, &rv));
     NS_ENSURE_SUCCESS(rv, rv);
     if (prefBranch)
       prefBranch->GetIntPref("mail.imap.hdr_chunk_size", &hdrChunkSize);
   }
-  int32_t numKeysToFetch = m_keysToFetch.Length();
+  int32_t numUIDsToFetch = m_uidsToFetch.Length();
   int32_t startIndex = 0;
   if (folderOpen && hdrChunkSize > 0 &&
-      (int32_t)m_keysToFetch.Length() > hdrChunkSize) {
-    numKeysToFetch = hdrChunkSize;
+      (int32_t)m_uidsToFetch.Length() > hdrChunkSize) {
+    numUIDsToFetch = hdrChunkSize;
     *aMoreToDownload = true;
-    startIndex = m_keysToFetch.Length() - hdrChunkSize;
-  }
-  aKeys.AppendElements(&m_keysToFetch[startIndex], numKeysToFetch);
+    startIndex = m_uidsToFetch.Length() - hdrChunkSize;
+  }
+  uids.AppendElements(&m_uidsToFetch[startIndex], numUIDsToFetch);
   // Remove these for the incremental header download case, so that
   // we know we don't have to download them again.
-  m_keysToFetch.RemoveElementsAt(startIndex, numKeysToFetch);
+  m_uidsToFetch.RemoveElementsAt(startIndex, numUIDsToFetch);
 
   return NS_OK;
 }
 
 void nsImapMailFolder::PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol) {
   // now, tell it we don't need any bodies.
-  nsTArray<nsMsgKey> noBodies;
-  aProtocol->NotifyBodysToDownload(noBodies);
+  aProtocol->NotifyBodysToDownload({});
 }
 
 void nsImapMailFolder::TweakHeaderFlags(nsIImapProtocol* aProtocol,
                                         nsIMsgDBHdr* tweakMe) {
   if (mDatabase && aProtocol && tweakMe) {
-    tweakMe->SetMessageKey(m_curMsgUid);
+    tweakMe->SetImapUID(m_curMsgUid);
     tweakMe->SetMessageSize(m_nextMessageByteLength);
 
     bool foundIt = false;
 
     nsCOMPtr<nsIImapFlagAndUidState> flagState;
     nsresult rv = aProtocol->GetFlagAndUidState(getter_AddRefs(flagState));
     NS_ENSURE_SUCCESS_VOID(rv);
     rv = flagState->HasMessage(m_curMsgUid, &foundIt);
@@ -4241,45 +4208,48 @@ nsImapMailFolder::SetupMsgWriteStream(ns
     NS_ENSURE_SUCCESS(rv, rv);
     m_tempMessageStreamBytesWritten += writeCount;
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapMailFolder::DownloadMessagesForOffline(
     nsTArray<RefPtr<nsIMsgDBHdr>> const& messages, nsIMsgWindow* window) {
-  nsAutoCString messageIds;
-  nsTArray<nsMsgKey> srcKeyArray;
-  nsresult rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);
-  if (NS_FAILED(rv) || messageIds.IsEmpty()) return rv;
+  nsTArray<uint32_t> uids;
+  nsresult rv;
+  for (nsIMsgDBHdr* msg : messages) {
+    uint32_t uid;
+    rv = msg->GetImapUID(&uid);
+    if (NS_SUCCEEDED(rv)) uids.AppendElement(uid);
+  }
+  nsAutoCString uidsString;
+  rv = BuildUIDSet(uids, uidsString);
+  if (NS_FAILED(rv) || uidsString.IsEmpty()) return rv;
 
   nsCOMPtr<nsIImapService> imapService =
       do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = AcquireSemaphore(static_cast<nsIMsgFolder*>(this));
   if (NS_FAILED(rv)) {
     ThrowAlertMsg("operationFailedFolderBusy", window);
     return rv;
   }
-  return imapService->DownloadMessagesForOffline(messageIds, this, this,
+  return imapService->DownloadMessagesForOffline(uidsString, this, this,
                                                  window);
 }
 
 NS_IMETHODIMP nsImapMailFolder::DownloadAllForOffline(nsIUrlListener* listener,
                                                       nsIMsgWindow* msgWindow) {
   nsresult rv;
   nsCOMPtr<nsIURI> runningURI;
   bool noSelect;
   GetFlag(nsMsgFolderFlags::ImapNoselect, &noSelect);
 
   if (!noSelect) {
-    nsAutoCString messageIdsToDownload;
-    nsTArray<nsMsgKey> msgsToDownload;
-
     GetDatabase();
     m_downloadingFolderForOfflineUse = true;
 
     rv = AcquireSemaphore(static_cast<nsIMsgFolder*>(this));
     if (NS_FAILED(rv)) {
       m_downloadingFolderForOfflineUse = false;
       ThrowAlertMsg("operationFailedFolderBusy", msgWindow);
       return rv;
@@ -4300,26 +4270,26 @@ NS_IMETHODIMP nsImapMailFolder::Download
     }
   } else
     rv = NS_MSG_FOLDER_UNREADABLE;
   return rv;
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::ParseAdoptedMsgLine(const char* adoptedMessageLine,
-                                      nsMsgKey uidOfMessage,
+                                      uint32_t uidOfMessage,
                                       nsIImapUrl* aImapUrl) {
   NS_ENSURE_ARG_POINTER(aImapUrl);
   uint32_t count = 0;
   nsresult rv;
   // remember the uid of the message we're downloading.
   m_curMsgUid = uidOfMessage;
   if (!m_offlineHeader) {
-    rv = GetMessageHeader(uidOfMessage, getter_AddRefs(m_offlineHeader));
-    if (NS_SUCCEEDED(rv) && !m_offlineHeader) rv = NS_ERROR_UNEXPECTED;
+    rv = mDatabase->GetMsgHdrForUID(uidOfMessage,
+                                    getter_AddRefs(m_offlineHeader));
     NS_ENSURE_SUCCESS(rv, rv);
     rv = StartNewOfflineMessage();
     NS_ENSURE_SUCCESS(rv, rv);
   }
   // adoptedMessageLine is actually a string with a lot of message lines,
   // separated by native line terminators we need to count the number of
   // MSG_LINEBREAK's to determine how much to increment m_numOfflineMsgLines by.
   const char* nextLine = adoptedMessageLine;
@@ -4344,23 +4314,24 @@ void nsImapMailFolder::EndOfflineDownloa
     m_tempMessageStream = nullptr;
     ReleaseSemaphore(static_cast<nsIMsgFolder*>(this));
     if (mDatabase) mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   m_offlineHeader = nullptr;
 }
 
 NS_IMETHODIMP
-nsImapMailFolder::NormalEndMsgWriteStream(nsMsgKey uidOfMessage, bool markRead,
+nsImapMailFolder::NormalEndMsgWriteStream(uint32_t uidOfMessage, bool markRead,
                                           nsIImapUrl* imapUrl,
                                           int32_t updatedMessageSize) {
   if (updatedMessageSize != -1) {
     // retrieve the message header to update size, if we don't already have it
     nsCOMPtr<nsIMsgDBHdr> msgHeader = m_offlineHeader;
-    if (!msgHeader) GetMessageHeader(uidOfMessage, getter_AddRefs(msgHeader));
+    if (!msgHeader)
+      mDatabase->GetMsgHdrForUID(uidOfMessage, getter_AddRefs(msgHeader));
     if (msgHeader) {
       uint32_t msgSize;
       msgHeader->GetMessageSize(&msgSize);
       MOZ_LOG(IMAP, mozilla::LogLevel::Debug,
               ("Updating stored message size from %u, new size %d", msgSize,
                updatedMessageSize));
       msgHeader->SetMessageSize(updatedMessageSize);
       // only commit here if this isn't an offline message
@@ -4375,17 +4346,17 @@ nsImapMailFolder::NormalEndMsgWriteStrea
   if (m_offlineHeader) EndNewOfflineMessage(NS_OK);
 
   m_curMsgUid = uidOfMessage;
 
   // Apply filter now if it needed a body
   if (m_filterListRequiresBody) {
     if (m_filterList) {
       nsCOMPtr<nsIMsgDBHdr> newMsgHdr;
-      GetMessageHeader(uidOfMessage, getter_AddRefs(newMsgHdr));
+      mDatabase->GetMsgHdrForUID(uidOfMessage, getter_AddRefs(newMsgHdr));
       GetMoveCoalescer();
       nsCOMPtr<nsIMsgWindow> msgWindow;
       if (imapUrl) {
         nsresult rv;
         nsCOMPtr<nsIMsgMailNewsUrl> msgUrl;
         msgUrl = do_QueryInterface(imapUrl, &rv);
         if (msgUrl && NS_SUCCEEDED(rv))
           msgUrl->GetMsgWindow(getter_AddRefs(msgWindow));
@@ -4480,44 +4451,50 @@ NS_IMETHODIMP
 nsImapMailFolder::ReleaseUrlCacheEntry(nsIMsgMailNewsUrl* aUrl) {
   NS_ENSURE_ARG_POINTER(aUrl);
   return aUrl->SetMemCacheEntry(nullptr);
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::BeginMessageUpload() { return NS_ERROR_FAILURE; }
 
-nsresult nsImapMailFolder::HandleCustomFlags(nsMsgKey uidOfMessage,
+nsresult nsImapMailFolder::HandleCustomFlags(uint32_t uidOfMessage,
                                              nsIMsgDBHdr* dbHdr,
                                              uint16_t userFlags,
                                              nsCString& keywords) {
   nsresult rv = GetDatabase();
   NS_ENSURE_SUCCESS(rv, rv);
 
+  nsMsgKey msgKey;
+  rv = dbHdr->GetMessageKey(&msgKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   ToLowerCase(keywords);
   bool messageClassified = true;
   // ### TODO: we really should parse the keywords into space delimited keywords
   // before checking
   // Mac Mail, Yahoo uses "NotJunk"
   if (FindInReadable("NonJunk"_ns, keywords,
                      nsCaseInsensitiveCStringComparator) ||
       FindInReadable("NotJunk"_ns, keywords,
                      nsCaseInsensitiveCStringComparator)) {
     nsAutoCString msgJunkScore;
     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_HAM_SCORE);
-    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore.get());
+    mDatabase->SetStringProperty(msgKey, "junkscore", msgJunkScore.get());
   } else if (FindInReadable("Junk"_ns, keywords,
                             nsCaseInsensitiveCStringComparator)) {
     uint32_t newFlags;
     dbHdr->AndFlags(~nsMsgMessageFlags::New, &newFlags);
     nsAutoCString msgJunkScore;
     msgJunkScore.AppendInt(nsIJunkMailPlugin::IS_SPAM_SCORE);
-    mDatabase->SetStringProperty(uidOfMessage, "junkscore", msgJunkScore.get());
-  } else
+    mDatabase->SetStringProperty(msgKey, "junkscore", msgJunkScore.get());
+  } else {
     messageClassified = false;
+  }
+
   if (messageClassified) {
     // only set the junkscore origin if it wasn't set before.
     nsCString existingProperty;
     dbHdr->GetStringProperty("junkscoreorigin",
                              getter_Copies(existingProperty));
     if (existingProperty.IsEmpty())
       dbHdr->SetStringProperty("junkscoreorigin", "imapflag");
   }
@@ -4602,47 +4579,46 @@ nsresult nsImapMailFolder::SyncFlags(nsI
   uint16_t supportedUserFlags;
   flagState->GetSupportedUserFlags(&supportedUserFlags);
 
   for (int32_t flagIndex = 0; flagIndex < messageIndex; flagIndex++) {
     uint32_t uidOfMessage;
     flagState->GetUidOfMessage(flagIndex, &uidOfMessage);
     imapMessageFlagsType flags;
     flagState->GetMessageFlags(flagIndex, &flags);
-    bool containsKey;
-    rv = mDatabase->ContainsKey(uidOfMessage, &containsKey);
+    bool dbHasMsg;
+    rv = mDatabase->ContainsUID(uidOfMessage, &dbHasMsg);
     // if we don't have the header, don't diddle the flags.
     // GetMsgHdrForKey will create the header if it doesn't exist.
-    if (NS_FAILED(rv) || !containsKey) continue;
+    if (NS_FAILED(rv) || !dbHasMsg) continue;
 
     nsCOMPtr<nsIMsgDBHdr> dbHdr;
-    rv = mDatabase->GetMsgHdrForKey(uidOfMessage, getter_AddRefs(dbHdr));
+    rv = mDatabase->GetMsgHdrForUID(uidOfMessage, getter_AddRefs(dbHdr));
     if (NS_FAILED(rv)) continue;
     if (NS_SUCCEEDED(dbHdr->GetMessageSize(&messageSize)))
       newFolderSize += messageSize;
 
     nsCString keywords;
     if (NS_SUCCEEDED(
             flagState->GetCustomFlags(uidOfMessage, getter_Copies(keywords))))
       HandleCustomFlags(uidOfMessage, dbHdr, supportedUserFlags, keywords);
 
-    NotifyMessageFlagsFromHdr(dbHdr, uidOfMessage, flags);
+    NotifyMessageFlagsFromHdr(dbHdr, flags);
   }
   if (!partialUIDFetch && newFolderSize != mFolderSize) {
     int64_t oldFolderSize = mFolderSize;
     mFolderSize = newFolderSize;
     NotifyIntPropertyChanged(kFolderSize, oldFolderSize, mFolderSize);
   }
 
   return NS_OK;
 }
 
 // helper routine to sync the flags on a given header
 nsresult nsImapMailFolder::NotifyMessageFlagsFromHdr(nsIMsgDBHdr* dbHdr,
-                                                     nsMsgKey msgKey,
                                                      uint32_t flags) {
   nsresult rv = GetDatabase();
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Although it may seem strange to keep a local reference of mDatabase here,
   // the current lifetime management of databases requires that methods
   // sometimes null the database when they think they opened it. Unfortunately
   // experience shows this happens when we don't expect, so for crash protection
@@ -4650,16 +4626,18 @@ nsresult nsImapMailFolder::NotifyMessage
   // local reference when there will be complex calls in a method. See bug
   // 1312254.
   nsCOMPtr<nsIMsgDatabase> database(mDatabase);
   NS_ENSURE_STATE(database);
 
   database->MarkHdrRead(dbHdr, (flags & kImapMsgSeenFlag) != 0, nullptr);
   database->MarkHdrReplied(dbHdr, (flags & kImapMsgAnsweredFlag) != 0, nullptr);
   database->MarkHdrMarked(dbHdr, (flags & kImapMsgFlaggedFlag) != 0, nullptr);
+  nsMsgKey msgKey;
+  dbHdr->GetMessageKey(&msgKey);
   database->MarkImapDeleted(msgKey, (flags & kImapMsgDeletedFlag) != 0,
                             nullptr);
 
   uint32_t supportedFlags;
   GetSupportedUserFlags(&supportedFlags);
   if (supportedFlags & kImapMsgSupportForwardedFlag)
     database->MarkForwarded(msgKey, (flags & kImapMsgForwardedFlag) != 0,
                             nullptr);
@@ -4669,18 +4647,17 @@ nsresult nsImapMailFolder::NotifyMessage
   return NS_OK;
 }
 
 // message flags operation - this is called from the imap protocol,
 // proxied over from the imap thread to the ui thread, when a flag changes
 NS_IMETHODIMP
 nsImapMailFolder::NotifyMessageFlags(uint32_t aFlags,
                                      const nsACString& aKeywords,
-                                     nsMsgKey aMsgKey,
-                                     uint64_t aHighestModSeq) {
+                                     uint32_t msgUID, uint64_t aHighestModSeq) {
   if (NS_SUCCEEDED(GetDatabase()) && mDatabase) {
     bool msgDeleted = aFlags & kImapMsgDeletedFlag;
     if (aHighestModSeq || msgDeleted) {
       nsCOMPtr<nsIDBFolderInfo> dbFolderInfo;
       mDatabase->GetDBFolderInfo(getter_AddRefs(dbFolderInfo));
       if (dbFolderInfo) {
         if (aHighestModSeq) {
           char intStrBuf[40];
@@ -4697,55 +4674,60 @@ nsImapMailFolder::NotifyMessageFlags(uin
           dbFolderInfo->GetUint32Property(kDeletedHdrCountPropertyName, 0,
                                           &oldDeletedCount);
           dbFolderInfo->SetUint32Property(kDeletedHdrCountPropertyName,
                                           oldDeletedCount + 1);
         }
       }
     }
     nsCOMPtr<nsIMsgDBHdr> dbHdr;
-    bool containsKey;
-    nsresult rv = mDatabase->ContainsKey(aMsgKey, &containsKey);
+    bool gotMsg;
+    nsresult rv = mDatabase->ContainsUID(msgUID, &gotMsg);
     // if we don't have the header, don't diddle the flags.
     // GetMsgHdrForKey will create the header if it doesn't exist.
-    if (NS_FAILED(rv) || !containsKey) return rv;
-    rv = mDatabase->GetMsgHdrForKey(aMsgKey, getter_AddRefs(dbHdr));
+    if (NS_FAILED(rv) || !gotMsg) return rv;
+    rv = mDatabase->GetMsgHdrForUID(msgUID, getter_AddRefs(dbHdr));
     if (NS_SUCCEEDED(rv) && dbHdr) {
       uint32_t supportedUserFlags;
       GetSupportedUserFlags(&supportedUserFlags);
-      NotifyMessageFlagsFromHdr(dbHdr, aMsgKey, aFlags);
+      NotifyMessageFlagsFromHdr(dbHdr, aFlags);
       nsCString keywords(aKeywords);
-      HandleCustomFlags(aMsgKey, dbHdr, supportedUserFlags, keywords);
+      HandleCustomFlags(msgUID, dbHdr, supportedUserFlags, keywords);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::NotifyMessageDeleted(const char* onlineFolderName,
                                        bool deleteAllMsgs,
                                        const char* msgIdString) {
   if (deleteAllMsgs) return NS_OK;
 
   if (!msgIdString) return NS_OK;
 
-  nsTArray<nsMsgKey> affectedMessages;
-  ParseUidString(msgIdString, affectedMessages);
-
   if (!ShowDeletedMessages()) {
+    nsTArray<uint32_t> uids;
+    ParseUidString(msgIdString, uids);
+    nsTArray<nsMsgKey> affectedMessages;
+    nsresult rv = mDatabase->GetMsgKeysForUIDs(uids, affectedMessages);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     GetDatabase();
     NS_ENSURE_TRUE(mDatabase, NS_OK);
     if (!ShowDeletedMessages()) {
       if (!affectedMessages.IsEmpty())  // perhaps Search deleted these messages
       {
         DeleteStoreMessages(affectedMessages);
         mDatabase->DeleteMessages(affectedMessages, nullptr);
       }
-    } else  // && !imapDeleteIsMoveToTrash // TODO: can this ever be executed?
+    } else {  // && !imapDeleteIsMoveToTrash // TODO: can this ever be executed?
+      // TODO: Sort out this unreachable branch...
       SetIMAPDeletedFlag(mDatabase, affectedMessages, false);
+    }
   }
   return NS_OK;
 }
 
 bool nsImapMailFolder::ShowDeletedMessages() {
   nsresult rv;
   nsCOMPtr<nsIImapHostSessionList> hostSession =
       do_GetService(kCImapHostSessionList, &rv);
@@ -4799,19 +4781,19 @@ void nsImapMailFolder::SetIMAPDeletedFla
 NS_IMETHODIMP
 nsImapMailFolder::GetMessageSizeFromDB(const char* id, uint32_t* size) {
   NS_ENSURE_ARG_POINTER(size);
 
   *size = 0;
   nsresult rv = GetDatabase();
   NS_ENSURE_SUCCESS(rv, rv);
   if (id) {
-    nsMsgKey key = msgKeyFromInt(ParseUint64Str(id));
+    uint32_t uid = msgKeyFromInt(ParseUint64Str(id));
     nsCOMPtr<nsIMsgDBHdr> mailHdr;
-    rv = mDatabase->GetMsgHdrForKey(key, getter_AddRefs(mailHdr));
+    rv = mDatabase->GetMsgHdrForUID(uid, getter_AddRefs(mailHdr));
     if (NS_SUCCEEDED(rv) && mailHdr) rv = mailHdr->GetMessageSize(size);
   }
   return rv;
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::GetCurMoveCopyMessageInfo(nsIImapUrl* runningUrl,
                                             PRTime* aDate,
@@ -4979,20 +4961,21 @@ nsImapMailFolder::OnStopRunningUrl(nsIUR
                   rv = srcFolder->GetMsgDatabase(getter_AddRefs(srcDB));
                 if (NS_SUCCEEDED(rv) && srcDB) {
                   RefPtr<nsImapMoveCopyMsgTxn> msgTxn;
                   nsTArray<nsMsgKey> srcKeyArray;
                   if (m_copyState->m_allowUndo) {
                     msgTxn = m_copyState->m_undoMsgTxn;
                     if (msgTxn) msgTxn->GetSrcKeyArray(srcKeyArray);
                   } else {
-                    nsAutoCString messageIds;
-                    rv = BuildIdsAndKeyArray(m_copyState->m_messages,
-                                             messageIds, srcKeyArray);
-                    NS_ENSURE_SUCCESS(rv, rv);
+                    for (nsIMsgDBHdr* msg : m_copyState->m_messages) {
+                      nsMsgKey key;
+                      msg->GetMessageKey(&key);
+                      srcKeyArray.AppendElement(key);
+                    }
                   }
 
                   if (!ShowDeletedMessages()) {
                     // We only reach here for same-server operations
                     // (!m_copyState->m_isCrossServerOp in if above), so we can
                     // assume that the src is also imap that uses offline
                     // storage.
                     DeleteStoreMessages(srcKeyArray, srcFolder);
@@ -5064,53 +5047,58 @@ nsImapMailFolder::OnStopRunningUrl(nsIUR
           imapMessageFlagsType flags = 0;
           imapUrl->GetMsgFlags(&flags);
           // we need to subtract the delete flag in db only in case when we show
           // deleted msgs
           if (flags & kImapMsgDeletedFlag && ShowDeletedMessages()) {
             nsCOMPtr<nsIMsgDatabase> db;
             rv = GetMsgDatabase(getter_AddRefs(db));
             if (NS_SUCCEEDED(rv) && db) {
+              nsCString uidSet;
+              imapUrl->GetListOfMessageIds(uidSet);
+              nsTArray<uint32_t> uids;
+              ParseUidString(uidSet.get(), uids);
               nsTArray<nsMsgKey> keyArray;
-              nsCString keyString;
-              imapUrl->GetListOfMessageIds(keyString);
-              ParseUidString(keyString.get(), keyArray);
+              rv = db->GetMsgKeysForUIDs(uids, keyArray);
+              MOZ_ASSERT(NS_SUCCEEDED(rv));
               MarkMessagesImapDeleted(&keyArray, false, db);
               db->Commit(nsMsgDBCommitType::kLargeCommit);
             }
           }
         } break;
         case nsIImapUrl::nsImapAddMsgFlags: {
           imapMessageFlagsType flags = 0;
           imapUrl->GetMsgFlags(&flags);
           if (flags & kImapMsgDeletedFlag) {
             // we need to delete headers from db only when we don't show deleted
             // msgs
             if (!ShowDeletedMessages()) {
               nsCOMPtr<nsIMsgDatabase> db;
               rv = GetMsgDatabase(getter_AddRefs(db));
               if (NS_SUCCEEDED(rv) && db) {
+                // Resolve the UID set to msgHdrs (and keys).
+                nsTArray<uint32_t> uidArray;
+                nsCString uidSet;
+                imapUrl->GetListOfMessageIds(uidSet);
+                ParseUidString(uidSet.get(), uidArray);
                 nsTArray<nsMsgKey> keyArray;
-                nsCString keyString;
-                imapUrl->GetListOfMessageIds(keyString);
-                ParseUidString(keyString.get(), keyArray);
+                rv = db->GetMsgKeysForUIDs(uidArray, keyArray);
+                MOZ_ASSERT(NS_SUCCEEDED(rv));
+                nsTArray<RefPtr<nsIMsgDBHdr>> msgHdrs;
+                rv = MsgGetHeadersFromKeys(db, keyArray, msgHdrs);
+                MOZ_ASSERT(NS_SUCCEEDED(rv));
 
                 // For pluggable stores that do not support compaction, we need
                 // to delete the messages now.
                 bool supportsCompaction = false;
                 nsCOMPtr<nsIMsgPluggableStore> offlineStore;
                 (void)GetMsgStore(getter_AddRefs(offlineStore));
                 if (offlineStore)
                   offlineStore->GetSupportsCompaction(&supportsCompaction);
 
-                nsTArray<RefPtr<nsIMsgDBHdr>> msgHdrs;
-                if (notifier || !supportsCompaction) {
-                  MsgGetHeadersFromKeys(db, keyArray, msgHdrs);
-                }
-
                 // Notify listeners of delete.
                 if (notifier && !msgHdrs.IsEmpty()) {
                   // XXX Currently, the DeleteMessages below gets executed twice
                   // on deletes. Once in DeleteMessages, once here. The second
                   // time, it silently fails to delete. This is why we're also
                   // checking whether the array is empty.
                   notifier->NotifyMsgsDeleted(msgHdrs);
                 }
@@ -5337,17 +5325,17 @@ nsImapMailFolder::SetCopyResponseUid(con
         do_QueryInterface(copyState, &rv);
     if (NS_FAILED(rv)) return rv;
     if (mailCopyState->m_undoMsgTxn) msgTxn = mailCopyState->m_undoMsgTxn;
   } else if (aUrl && m_pendingOfflineMoves.Length()) {
     nsCString urlSourceMsgIds, undoTxnSourceMsgIds;
     aUrl->GetListOfMessageIds(urlSourceMsgIds);
     RefPtr<nsImapMoveCopyMsgTxn> imapUndo = m_pendingOfflineMoves[0];
     if (imapUndo) {
-      imapUndo->GetSrcMsgIds(undoTxnSourceMsgIds);
+      imapUndo->GetSrcMsgUIDSet(undoTxnSourceMsgIds);
       if (undoTxnSourceMsgIds.Equals(urlSourceMsgIds)) msgTxn = imapUndo;
       // ### we should handle batched moves, but lets keep it simple for a2.
       m_pendingOfflineMoves.Clear();
     }
   }
   if (msgTxn) msgTxn->SetCopyResponseUid(msgIdString);
   return NS_OK;
 }
@@ -5362,26 +5350,32 @@ nsImapMailFolder::StartMessage(nsIMsgMai
   if (copyState) {
     nsCOMPtr<nsICopyMessageStreamListener> listener =
         do_QueryInterface(copyState);
     if (listener) listener->StartMessage();
   }
   return NS_OK;
 }
 
+// nsIImapMailFolderSink.endMessage()
 NS_IMETHODIMP
-nsImapMailFolder::EndMessage(nsIMsgMailNewsUrl* aUrl, nsMsgKey uidOfMessage) {
+nsImapMailFolder::EndMessage(nsIMsgMailNewsUrl* aUrl, uint32_t uidOfMessage) {
   nsCOMPtr<nsIImapUrl> imapUrl(do_QueryInterface(aUrl));
   nsCOMPtr<nsISupports> copyState;
   NS_ENSURE_TRUE(imapUrl, NS_ERROR_FAILURE);
   imapUrl->GetCopyState(getter_AddRefs(copyState));
   if (copyState) {
     nsCOMPtr<nsICopyMessageStreamListener> listener =
         do_QueryInterface(copyState);
-    if (listener) listener->EndMessage(uidOfMessage);
+    if (listener) {
+      nsTArray<nsMsgKey> keys;
+      mDatabase->GetMsgKeysForUIDs({uidOfMessage}, keys);
+      MOZ_ASSERT(!keys.IsEmpty());
+      listener->EndMessage(keys[0]);
+    }
   }
   return NS_OK;
 }
 
 #define WHITESPACE " \015\012"  // token delimiter
 
 NS_IMETHODIMP
 nsImapMailFolder::NotifySearchHit(nsIMsgMailNewsUrl* aUrl,
@@ -5418,35 +5412,36 @@ nsImapMailFolder::NotifySearchHit(nsIMsg
 
       hitUidToken = NS_strtok(WHITESPACE, &currentPosition);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
-nsImapMailFolder::SetAppendMsgUid(nsMsgKey aKey, nsIImapUrl* aUrl) {
+nsImapMailFolder::SetAppendMsgUid(uint32_t uid, nsIImapUrl* aUrl) {
   nsresult rv;
   nsCOMPtr<nsISupports> copyState;
   if (aUrl) aUrl->GetCopyState(getter_AddRefs(copyState));
   if (copyState) {
     nsCOMPtr<nsImapMailCopyState> mailCopyState =
         do_QueryInterface(copyState, &rv);
     if (NS_FAILED(rv)) return rv;
 
     if (mailCopyState->m_undoMsgTxn)  // CopyMessages()
     {
       RefPtr<nsImapMoveCopyMsgTxn> msgTxn;
       msgTxn = mailCopyState->m_undoMsgTxn;
-      msgTxn->AddDstKey(aKey);
+      msgTxn->AddDstUID(uid);
     } else if (mailCopyState->m_listener)  // CopyFileMessage();
                                            // Draft/Template goes here
     {
-      mailCopyState->m_appendUID = aKey;
-      mailCopyState->m_listener->SetMessageKey(aKey);
+      mailCopyState->m_appendUID = uid;
+      MOZ_CRASH("THIS NEEDS FIXING!");
+      mailCopyState->m_listener->SetMessageKey(uid);
     }
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::GetMessageId(nsIImapUrl* aUrl, nsACString& messageId) {
   nsresult rv = NS_OK;
@@ -5498,17 +5493,20 @@ nsImapMailFolder::HeaderFetchCompleted(n
     if (m_downloadingFolderForOfflineUse || autoSyncOfflineStores ||
         autoDownloadNewHeaders) {
       nsTArray<nsMsgKey> keysToDownload;
       GetBodysToDownload(&keysToDownload);
       if (!keysToDownload.IsEmpty() &&
           (m_downloadingFolderForOfflineUse || autoDownloadNewHeaders)) {
         // this is the case when DownloadAllForOffline is called.
         notifiedBodies = true;
-        aProtocol->NotifyBodysToDownload(keysToDownload);
+        nsTArray<uint32_t> uidsToDownload(keysToDownload.Length());
+        MOZ_ASSERT(mDatabase);
+        mDatabase->GetMsgUIDsForKeys(keysToDownload, uidsToDownload);
+        aProtocol->NotifyBodysToDownload(uidsToDownload);
       } else {
         // create auto-sync state object lazily
         InitAutoSyncState();
         if (MOZ_LOG_TEST(gAutoSyncLog, mozilla::LogLevel::Debug)) {
           int32_t flags = 0;
           GetFlags((uint32_t*)&flags);
           nsString folderName;
           GetName(folderName);
@@ -5529,18 +5527,17 @@ nsImapMailFolder::HeaderFetchCompleted(n
 
         m_autoSyncStateObj->SetServerCounts(
             m_numServerTotalMessages, m_numServerRecentMessages,
             m_numServerUnseenMessages, m_nextUID);
         m_autoSyncStateObj->OnNewHeaderFetchCompleted(keysToDownload);
       }
     }
     if (!notifiedBodies) {
-      nsTArray<nsMsgKey> noBodies;
-      aProtocol->NotifyBodysToDownload(noBodies);
+      aProtocol->NotifyBodysToDownload({});
     }
 
     nsCOMPtr<nsIURI> runningUri;
     aProtocol->GetRunningUrl(getter_AddRefs(runningUri));
     if (runningUri) {
       nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(runningUri);
       if (mailnewsUrl) mailnewsUrl->GetMsgWindow(getter_AddRefs(msgWindow));
     }
@@ -6391,26 +6388,26 @@ nsresult nsImapMailFolder::CopyMessagesW
   rv = InitCopyState(srcFolder, messages, isMove, false, isCrossServerOp, 0,
                      EmptyCString(), listener, msgWindow, allowUndo);
   if (NS_FAILED(rv)) return rv;
 
   m_copyState->m_streamCopy = true;
 
   // ** jt - needs to create server to server move/copy undo msg txn
   if (m_copyState->m_allowUndo) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> srcKeyArray;
-    rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);
+    nsTArray<nsMsgKey> srcKeys(messages.Length());
+    for (nsIMsgDBHdr* msg : messages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      srcKeys.AppendElement(key);
+    }
 
     RefPtr<nsImapMoveCopyMsgTxn> undoMsgTxn = new nsImapMoveCopyMsgTxn;
-
-    if (!undoMsgTxn ||
-        NS_FAILED(undoMsgTxn->Init(srcFolder, &srcKeyArray, messageIds.get(),
-                                   this, true, isMove)))
-      return NS_ERROR_OUT_OF_MEMORY;
+    rv = undoMsgTxn->Init(srcFolder, &srcKeys, this, true, isMove);
+    NS_ENSURE_SUCCESS(rv, rv);
 
     if (isMove) {
       if (mFlags & nsMsgFolderFlags::Trash)
         undoMsgTxn->SetTransactionType(nsIMessenger::eDeleteMsg);
       else
         undoMsgTxn->SetTransactionType(nsIMessenger::eMoveMsg);
     } else
       undoMsgTxn->SetTransactionType(nsIMessenger::eCopyMsg);
@@ -6483,16 +6480,18 @@ nsresult nsImapMailFolder::GetOriginalOp
         opsDb->GetOfflineOpForKey(originalKey, false, getter_AddRefs(returnOp));
   }
   returnOp.forget(originalOp);
   return rv;
 }
 
 nsresult nsImapMailFolder::FindOpenRange(nsMsgKey& fakeBase,
                                          uint32_t srcCount) {
+  MOZ_CRASH("FindOpenRange() needs re-evaluation.");
+  // TODO: key generation should be left up to the database.
   nsresult rv = GetDatabase();
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsMsgKey newBase = fakeBase - 1;
   uint32_t freeCount = 0;
   while (freeCount != srcCount && newBase > 0) {
     bool containsKey;
     if (NS_SUCCEEDED(mDatabase->ContainsKey(newBase, &containsKey)) &&
@@ -6600,26 +6599,32 @@ nsresult nsImapMailFolder::CopyMessagesO
       }
       // N.B. We must not return out of the for loop - we need the matching
       // end notifications to be sent.
       // We don't need to acquire the semaphor since this is synchronous
       // on the UI thread but we should check if the offline store is locked.
       bool isLocked;
       GetLocked(&isLocked);
       nsTArray<nsMsgKey> addedKeys;
-      nsTArray<nsMsgKey> srcKeyArray;
       nsCOMArray<nsIMsgDBHdr> addedHdrs;
       nsCOMArray<nsIMsgDBHdr> srcMsgs;
       nsOfflineImapOperationType moveCopyOpType;
       nsOfflineImapOperationType deleteOpType =
           nsIMsgOfflineImapOperation::kDeletedMsg;
       if (!deleteToTrash)
         deleteOpType = nsIMsgOfflineImapOperation::kMsgMarkedDeleted;
-      nsCString messageIds;
-      rv = BuildIdsAndKeyArray(messages, messageIds, srcKeyArray);
+
+      // Get keys for messages.
+      nsTArray<nsMsgKey> srcKeyArray(messages.Length());
+      for (nsIMsgDBHdr* msg : messages) {
+        nsMsgKey key;
+        msg->GetMessageKey(&key);
+        srcKeyArray.AppendElement(key);
+      }
+
       // put fake message in destination db, delete source if move
       EnableNotifications(nsIMsgFolder::allMessageCountNotifications, false);
       nsCString originalSrcFolderURI;
       srcFolder->GetURI(originalSrcFolderURI);
       nsCOMPtr<nsIMsgOfflineOpsDatabase> opsDb =
           do_QueryInterface(sourceMailDB, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
       for (uint32_t sourceKeyIndex = 0;
@@ -6768,22 +6773,21 @@ nsresult nsImapMailFolder::CopyMessagesO
           if (successfulCopy) {
             // This is for both moves and copies
             msgHdrsCopied.AppendElement(mailHdr);
           }
         }
       }  // End message loop.
       EnableNotifications(nsIMsgFolder::allMessageCountNotifications, true);
       RefPtr<nsImapOfflineTxn> addHdrMsgTxn = new nsImapOfflineTxn(
-          this, &addedKeys, nullptr, this, isMove,
+          this, &addedKeys, this, isMove,
           nsIMsgOfflineImapOperation::kAddedHeader, addedHdrs);
       if (addHdrMsgTxn && txnMgr) txnMgr->DoTransaction(addHdrMsgTxn);
-      RefPtr<nsImapOfflineTxn> undoMsgTxn =
-          new nsImapOfflineTxn(srcFolder, &srcKeyArray, messageIds.get(), this,
-                               isMove, moveCopyOpType, srcMsgs);
+      RefPtr<nsImapOfflineTxn> undoMsgTxn = new nsImapOfflineTxn(
+          srcFolder, &srcKeyArray, this, isMove, moveCopyOpType, srcMsgs);
       if (undoMsgTxn) {
         if (isMove) {
           undoMsgTxn->SetTransactionType(nsIMessenger::eMoveMsg);
           nsCOMPtr<nsIMsgImapMailFolder> srcIsImap(
               do_QueryInterface(srcFolder));
           // remember this undo transaction so we can hook up the result
           // msg ids in the undo transaction.
           if (srcIsImap) {
@@ -6793,19 +6797,18 @@ nsresult nsImapMailFolder::CopyMessagesO
           }
         } else {
           undoMsgTxn->SetTransactionType(nsIMessenger::eCopyMsg);
         }
         // we're adding this undo action before the delete is successful. This
         // is evil, but 4.5 did it as well.
         if (txnMgr) txnMgr->DoTransaction(undoMsgTxn);
       }
-      undoMsgTxn =
-          new nsImapOfflineTxn(srcFolder, &srcKeyArray, messageIds.get(), this,
-                               isMove, deleteOpType, srcMsgs);
+      undoMsgTxn = new nsImapOfflineTxn(srcFolder, &srcKeyArray, this, isMove,
+                                        deleteOpType, srcMsgs);
       if (undoMsgTxn) {
         if (isMove) {
           if (mFlags & nsMsgFolderFlags::Trash) {
             undoMsgTxn->SetTransactionType(nsIMessenger::eDeleteMsg);
           } else {
             undoMsgTxn->SetTransactionType(nsIMessenger::eMoveMsg);
           }
         } else {
@@ -7067,18 +7070,18 @@ nsImapMailFolder::CopyMessages(
 
     // if the folders aren't on the same server, do a stream base copy
     if (!sameServer) {
       rv = CopyMessagesWithStream(srcFolder, sortedMsgs, isMove, true,
                                   msgWindow, listener, allowUndo);
       goto done;
     }
 
-    nsAutoCString messageIds;
-    rv = AllocateUidStringFromKeys(keyArray, messageIds);
+    nsAutoCString messageUIDSet;
+    rv = MsgKeysToUIDSet(mDatabase, keyArray, messageUIDSet);
     if (NS_FAILED(rv)) goto done;
 
     nsCOMPtr<nsIUrlListener> urlListener;
     rv =
         QueryInterface(NS_GET_IID(nsIUrlListener), getter_AddRefs(urlListener));
     rv = InitCopyState(srcSupport, sortedMsgs, isMove, true, false, 0,
                        EmptyCString(), listener, msgWindow, allowUndo);
     if (NS_FAILED(rv)) goto done;
@@ -7088,24 +7091,22 @@ nsImapMailFolder::CopyMessages(
     if (isMove)
       srcFolder->EnableNotifications(
           allMessageCountNotifications,
           false);  // disable message count notification
 
     nsCOMPtr<nsIURI> resultUrl;
     nsCOMPtr<nsISupports> copySupport = do_QueryInterface(m_copyState);
     rv = imapService->OnlineMessageCopy(
-        srcFolder, messageIds, this, true, isMove, urlListener,
+        srcFolder, messageUIDSet, this, true, isMove, urlListener,
         getter_AddRefs(resultUrl), copySupport, msgWindow);
     if (NS_SUCCEEDED(rv) && m_copyState->m_allowUndo) {
       RefPtr<nsImapMoveCopyMsgTxn> undoMsgTxn = new nsImapMoveCopyMsgTxn;
-      if (!undoMsgTxn ||
-          NS_FAILED(undoMsgTxn->Init(srcFolder, &keyArray, messageIds.get(),
-                                     this, true, isMove)))
-        return NS_ERROR_OUT_OF_MEMORY;
+      rv = undoMsgTxn->Init(srcFolder, &keyArray, this, true, isMove);
+      if (NS_FAILED(rv)) goto done;
 
       if (isMove) {
         if (mFlags & nsMsgFolderFlags::Trash)
           undoMsgTxn->SetTransactionType(nsIMessenger::eDeleteMsg);
         else
           undoMsgTxn->SetTransactionType(nsIMessenger::eMoveMsg);
       } else
         undoMsgTxn->SetTransactionType(nsIMessenger::eCopyMsg);
@@ -8326,21 +8327,23 @@ nsImapMailFolder::StoreCustomKeywords(ns
     }
     mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);  // flush offline ops
     return rv;
   }
 
   nsCOMPtr<nsIImapService> imapService(
       do_GetService("@mozilla.org/messenger/imapservice;1", &rv));
   NS_ENSURE_SUCCESS(rv, rv);
-  nsAutoCString msgIds;
-  AllocateUidStringFromKeys(aKeysToStore, msgIds);
+
+  nsAutoCString uidSet;
+  rv = MsgKeysToUIDSet(mDatabase, aKeysToStore, uidSet);
+  NS_ENSURE_SUCCESS(rv, rv);
   nsCOMPtr<nsIURI> retUri;
   rv = imapService->StoreCustomKeywords(this, aMsgWindow, aFlagsToAdd,
-                                        aFlagsToSubtract, msgIds,
+                                        aFlagsToSubtract, uidSet,
                                         getter_AddRefs(retUri));
   if (_retval) {
     retUri.forget(_retval);
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapMailFolder::NotifyIfNewMail() {
@@ -8374,20 +8377,22 @@ nsresult nsImapMailFolder::PlaybackCoale
 }
 
 NS_IMETHODIMP
 nsImapMailFolder::SetJunkScoreForMessages(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& aJunkScore) {
   nsresult rv = nsMsgDBFolder::SetJunkScoreForMessages(aMessages, aJunkScore);
   if (NS_SUCCEEDED(rv)) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> keys;
-    nsresult rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsTArray<nsMsgKey> keys(aMessages.Length());
+    for (nsIMsgDBHdr* msg : aMessages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      keys.AppendElement(key);
+    }
     StoreCustomKeywords(
         nullptr, aJunkScore.EqualsLiteral("0") ? "NonJunk"_ns : "Junk"_ns,
         aJunkScore.EqualsLiteral("0") ? "Junk"_ns : "NonJunk"_ns, keys,
         nullptr);
     if (mDatabase) mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   return rv;
 }
@@ -8564,17 +8569,17 @@ void nsImapMailFolder::GetTrashFolderNam
   imapServer->GetTrashFolderName(aFolderName);
   return;
 }
 NS_IMETHODIMP nsImapMailFolder::FetchMsgPreviewText(
     nsTArray<nsMsgKey> const& aKeysToFetch, nsIUrlListener* aUrlListener,
     bool* aAsyncResults) {
   NS_ENSURE_ARG_POINTER(aAsyncResults);
 
-  nsTArray<nsMsgKey> keysToFetchFromServer;
+  nsTArray<uint32_t> uidsToFetchFromServer;
 
   *aAsyncResults = false;
   nsresult rv = NS_OK;
 
   nsCOMPtr<nsIMsgMessageService> msgService =
       do_GetService("@mozilla.org/messenger/messageservice;1?type=imap", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -8600,25 +8605,25 @@ NS_IMETHODIMP nsImapMailFolder::FetchMsg
     uint32_t msgFlags;
     msgHdr->GetFlags(&msgFlags);
     if (msgFlags & nsMsgMessageFlags::Offline) {
       rv = GetLocalMsgStream(msgHdr, getter_AddRefs(inputStream));
       NS_ENSURE_SUCCESS(rv, rv);
       rv = GetMsgPreviewTextFromStream(msgHdr, inputStream);
       NS_ENSURE_SUCCESS(rv, rv);
     } else {
-      nsMsgKey msgKey;
-      msgHdr->GetMessageKey(&msgKey);
-      keysToFetchFromServer.AppendElement(msgKey);
-    }
-  }
-  if (!keysToFetchFromServer.IsEmpty()) {
-    uint32_t msgCount = keysToFetchFromServer.Length();
+      uint32_t uid;
+      msgHdr->GetImapUID(&uid);
+      uidsToFetchFromServer.AppendElement(uid);
+    }
+  }
+  if (!uidsToFetchFromServer.IsEmpty()) {
+    uint32_t msgCount = uidsToFetchFromServer.Length();
     nsAutoCString messageIds;
-    AllocateImapUidString(keysToFetchFromServer.Elements(), msgCount, nullptr,
+    AllocateImapUidString(uidsToFetchFromServer.Elements(), msgCount, nullptr,
                           messageIds);
     nsCOMPtr<nsIImapService> imapService =
         do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
     NS_ENSURE_SUCCESS(rv, rv);
     nsCOMPtr<nsIURI> outUri;
     rv = imapService->GetBodyStart(this, aUrlListener, messageIds, 2048,
                                    getter_AddRefs(outUri));
     *aAsyncResults = true;  // the preview text will be available async...
@@ -8626,35 +8631,39 @@ NS_IMETHODIMP nsImapMailFolder::FetchMsg
   return NS_OK;
 }
 
 NS_IMETHODIMP nsImapMailFolder::AddKeywordsToMessages(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& aKeywords) {
   nsresult rv = nsMsgDBFolder::AddKeywordsToMessages(aMessages, aKeywords);
   if (NS_SUCCEEDED(rv)) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> keys;
-    rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsTArray<nsMsgKey> keys(aMessages.Length());
+    for (nsIMsgDBHdr* msg : aMessages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      keys.AppendElement(key);
+    }
     rv = StoreCustomKeywords(nullptr, aKeywords, EmptyCString(), keys, nullptr);
     if (mDatabase) mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapMailFolder::RemoveKeywordsFromMessages(
     const nsTArray<RefPtr<nsIMsgDBHdr>>& aMessages,
     const nsACString& aKeywords) {
   nsresult rv = nsMsgDBFolder::RemoveKeywordsFromMessages(aMessages, aKeywords);
   if (NS_SUCCEEDED(rv)) {
-    nsAutoCString messageIds;
-    nsTArray<nsMsgKey> keys;
-    nsresult rv = BuildIdsAndKeyArray(aMessages, messageIds, keys);
-    NS_ENSURE_SUCCESS(rv, rv);
+    nsTArray<nsMsgKey> keys(aMessages.Length());
+    for (nsIMsgDBHdr* msg : aMessages) {
+      nsMsgKey key;
+      msg->GetMessageKey(&key);
+      keys.AppendElement(key);
+    }
     rv = StoreCustomKeywords(nullptr, EmptyCString(), aKeywords, keys, nullptr);
     if (mDatabase) mDatabase->Commit(nsMsgDBCommitType::kLargeCommit);
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapMailFolder::GetCustomIdentity(nsIMsgIdentity** aIdentity) {
   NS_ENSURE_ARG_POINTER(aIdentity);
diff --git a/mailnews/imap/src/nsImapMailFolder.h b/mailnews/imap/src/nsImapMailFolder.h
--- a/mailnews/imap/src/nsImapMailFolder.h
+++ b/mailnews/imap/src/nsImapMailFolder.h
@@ -356,55 +356,48 @@ class nsImapMailFolder : public nsMsgDBF
                                    nsIMsgDatabase* sourceDB,
                                    const nsACString& destFolder,
                                    nsIMsgFilter* filter,
                                    nsIMsgWindow* msgWindow);
 
   // send notification to copy service listener.
   nsresult OnCopyCompleted(nsISupports* srcSupport, nsresult exitCode);
 
-  static nsresult AllocateUidStringFromKeys(const nsTArray<nsMsgKey>& keys,
-                                            nsCString& msgIds);
-  static nsresult BuildIdsAndKeyArray(
-      const nsTArray<RefPtr<nsIMsgDBHdr>>& messages, nsCString& msgIds,
-      nsTArray<nsMsgKey>& keyArray);
-
   // these might end up as an nsIImapMailFolder attribute.
   nsresult SetSupportedUserFlags(uint32_t userFlags);
   nsresult GetSupportedUserFlags(uint32_t* userFlags);
 
   // Find the start of a range of msgKeys that can hold srcCount headers.
   nsresult FindOpenRange(nsMsgKey& fakeBase, uint32_t srcCount);
 
  protected:
   virtual ~nsImapMailFolder();
   // Helper methods
 
   nsresult ExpungeAndCompact(nsIUrlListener* aListener,
                              nsIMsgWindow* aMsgWindow);
   virtual nsresult CreateChildFromURI(const nsACString& uri,
                                       nsIMsgFolder** folder) override;
-  void FindKeysToAdd(const nsTArray<nsMsgKey>& existingKeys,
-                     nsTArray<nsMsgKey>& keysToFetch, uint32_t& numNewUnread,
+  void FindUIDsToAdd(const nsTArray<uint32_t>& existingUIDs,
+                     nsTArray<uint32_t>& uidsToFetch, uint32_t& numNewUnread,
                      nsIImapFlagAndUidState* flagState);
-  void FindKeysToDelete(const nsTArray<nsMsgKey>& existingKeys,
-                        nsTArray<nsMsgKey>& keysToFetch,
+  void FindUIDsToDelete(const nsTArray<uint32_t>& existingUIDs,
+                        nsTArray<uint32_t>& uidsToFetch,
                         nsIImapFlagAndUidState* flagState, uint32_t boxFlags);
   void PrepareToAddHeadersToMailDB(nsIImapProtocol* aProtocol);
   void TweakHeaderFlags(nsIImapProtocol* aProtocol, nsIMsgDBHdr* tweakMe);
 
   nsresult SyncFlags(nsIImapFlagAndUidState* flagState);
-  nsresult HandleCustomFlags(nsMsgKey uidOfMessage, nsIMsgDBHdr* dbHdr,
+  nsresult HandleCustomFlags(uint32_t uidOfMessage, nsIMsgDBHdr* dbHdr,
                              uint16_t userFlags, nsCString& keywords);
-  nsresult NotifyMessageFlagsFromHdr(nsIMsgDBHdr* dbHdr, nsMsgKey msgKey,
-                                     uint32_t flags);
+  nsresult NotifyMessageFlagsFromHdr(nsIMsgDBHdr* dbHdr, uint32_t flags);
 
   nsresult SetupHeaderParseStream(uint32_t size, const nsACString& content_type,
                                   nsIMailboxSpec* boxSpec);
-  nsresult ParseAdoptedHeaderLine(const char* messageLine, nsMsgKey msgKey);
+  nsresult ParseAdoptedHeaderLine(const char* messageLine, uint32_t msgUID);
   nsresult NormalEndHeaderParseStream(nsIImapProtocol* aProtocol,
                                       nsIImapUrl* imapUrl);
 
   void EndOfflineDownload();
 
   /**
    * At the end of a file-to-folder copy operation, copy the file to the
    * offline store and/or add to the message database, (if needed).
@@ -503,17 +496,17 @@ class nsImapMailFolder : public nsMsgDBF
   bool m_msgMovedByFilter;
   RefPtr<nsImapMoveCoalescer>
       m_moveCoalescer;  // strictly owned by the nsImapMailFolder
   nsTArray<RefPtr<nsIMsgDBHdr>> m_junkMessagesToMarkAsRead;
   /// list of keys to be moved to the junk folder
   nsTArray<nsMsgKey> mSpamKeysToMove;
   /// the junk destination folder
   nsCOMPtr<nsIMsgFolder> mSpamFolder;
-  nsMsgKey m_curMsgUid;
+  uint32_t m_curMsgUid;
   uint32_t m_uidValidity;
 
   // These three vars are used to store counts from STATUS or SELECT command
   // They include deleted messages, so they can differ from the generic
   // folder total and unread counts.
   int32_t m_numServerRecentMessages;
   int32_t m_numServerUnseenMessages;
   int32_t m_numServerTotalMessages;
@@ -567,18 +560,18 @@ class nsImapMailFolder : public nsMsgDBF
   // Pseudo-Offline Playback support
   nsPlaybackRequest* m_pendingPlaybackReq;
   nsCOMPtr<nsITimer> m_playbackTimer;
   nsTArray<RefPtr<nsImapMoveCopyMsgTxn>> m_pendingOfflineMoves;
   // hash table of mapping between messageids and message keys
   // for pseudo hdrs.
   nsTHashMap<nsCStringHashKey, nsMsgKey> m_pseudoHdrs;
 
-  nsTArray<nsMsgKey> m_keysToFetch;
-  uint32_t m_totalKeysToFetch;
+  nsTArray<uint32_t> m_uidsToFetch;
+  uint32_t m_totalUIDsToFetch;
 
   /**
    * delete if appropriate local storage for messages in this folder
    *
    * @parm aMessages array (of nsIMsgDBHdr) of messages to delete
    *       (or an array of message keys)
    * @parm aSrcFolder the folder containing the messages (optional)
    */
diff --git a/mailnews/imap/src/nsImapOfflineSync.cpp b/mailnews/imap/src/nsImapOfflineSync.cpp
--- a/mailnews/imap/src/nsImapOfflineSync.cpp
+++ b/mailnews/imap/src/nsImapOfflineSync.cpp
@@ -28,17 +28,17 @@ nsImapOfflineSync::nsImapOfflineSync() {
   m_singleFolderToUpdate = nullptr;
   m_window = nullptr;
   mCurrentPlaybackOpType = nsIMsgOfflineImapOperation::kFlagsChanged;
   m_mailboxupdatesStarted = false;
   m_mailboxupdatesFinished = false;
   m_createdOfflineFolders = false;
   m_pseudoOffline = false;
   m_KeyIndex = 0;
-  mCurrentUIDValidity = nsMsgKey_None;
+  mCurrentUIDValidity = -1;
   m_listener = nullptr;
 }
 
 NS_IMETHODIMP
 nsImapOfflineSync::Init(nsIMsgWindow* window, nsIUrlListener* listener,
                         nsIMsgFolder* singleFolderOnly, bool isPseudoOffline) {
   m_window = window;
   m_listener = listener;
@@ -230,38 +230,42 @@ void nsImapOfflineSync::ProcessFlagOpera
       currentOp->GetFlagOperation(&flagOperation);
       currentOp->GetNewFlags(&newFlags);
     }
     flagsMatch = (flagOperation & nsIMsgOfflineImapOperation::kFlagsChanged) &&
                  (newFlags == matchingFlags);
   } while (currentOp);
 
   if (!matchingFlagKeys.IsEmpty()) {
-    nsAutoCString uids;
-    nsImapMailFolder::AllocateUidStringFromKeys(matchingFlagKeys, uids);
+    nsAutoCString uidSet;
+    nsCOMPtr<nsIMsgDatabase> db;
+    if (NS_SUCCEEDED(m_currentFolder->GetMsgDatabase(getter_AddRefs(db)))) {
+      MsgKeysToUIDSet(db, matchingFlagKeys, uidSet);
+    }
     uint32_t curFolderFlags;
     m_currentFolder->GetFlags(&curFolderFlags);
 
-    if (uids.get() && (curFolderFlags & nsMsgFolderFlags::ImapBox)) {
+    if (!uidSet.IsEmpty() && (curFolderFlags & nsMsgFolderFlags::ImapBox)) {
       nsresult rv = NS_OK;
       nsCOMPtr<nsIMsgImapMailFolder> imapFolder =
           do_QueryInterface(m_currentFolder);
       nsCOMPtr<nsIURI> uriToSetFlags;
       if (imapFolder) {
-        rv = imapFolder->SetImapFlags(uids.get(), matchingFlags,
+        rv = imapFolder->SetImapFlags(uidSet.get(), matchingFlags,
                                       getter_AddRefs(uriToSetFlags));
         if (NS_SUCCEEDED(rv) && uriToSetFlags) {
           nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl =
               do_QueryInterface(uriToSetFlags);
           if (mailnewsUrl) mailnewsUrl->RegisterListener(this);
         }
       }
     }
-  } else
+  } else {
     ProcessNextOperation();
+  }
 }
 
 void nsImapOfflineSync::ProcessKeywordOperation(
     nsIMsgOfflineImapOperation* op) {
   nsCOMPtr<nsIMsgOfflineImapOperation> currentOp = op;
   nsTArray<nsMsgKey> matchingKeywordKeys;
   uint32_t currentKeyIndex = m_KeyIndex;
 
diff --git a/mailnews/imap/src/nsImapProtocol.cpp b/mailnews/imap/src/nsImapProtocol.cpp
--- a/mailnews/imap/src/nsImapProtocol.cpp
+++ b/mailnews/imap/src/nsImapProtocol.cpp
@@ -191,17 +191,17 @@ void nsMsgImapHdrXferInfo::ReleaseAll() 
   m_nextFreeHdrInfo = 0;
 }
 
 NS_IMPL_ISUPPORTS(nsMsgImapLineDownloadCache, nsIImapHeaderInfo)
 
 // **** helper class for downloading line ****
 nsMsgImapLineDownloadCache::nsMsgImapLineDownloadCache() {
   fLineInfo = (msg_line_info*)PR_CALLOC(sizeof(msg_line_info));
-  fLineInfo->uidOfMessage = nsMsgKey_None;
+  fLineInfo->uidOfMessage = 0;
   m_msgSize = 0;
 }
 
 nsMsgImapLineDownloadCache::~nsMsgImapLineDownloadCache() {
   PR_Free(fLineInfo);
 }
 
 uint32_t nsMsgImapLineDownloadCache::CurrentUID() {
@@ -228,22 +228,22 @@ NS_IMETHODIMP nsMsgImapLineDownloadCache
 bool nsMsgImapLineDownloadCache::CacheEmpty() { return m_bufferPos == 0; }
 
 NS_IMETHODIMP nsMsgImapLineDownloadCache::CacheLine(const char* line,
                                                     uint32_t uid) {
   fLineInfo->uidOfMessage = uid;
   return AppendString(line);
 }
 
-/* attribute nsMsgKey msgUid; */
-NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgUid(nsMsgKey* aMsgUid) {
+/* attribute unsigned long msgUid; */
+NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgUid(uint32_t* aMsgUid) {
   *aMsgUid = fLineInfo->uidOfMessage;
   return NS_OK;
 }
-NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgUid(nsMsgKey aMsgUid) {
+NS_IMETHODIMP nsMsgImapLineDownloadCache::SetMsgUid(uint32_t aMsgUid) {
   fLineInfo->uidOfMessage = aMsgUid;
   return NS_OK;
 }
 
 /* attribute long msgSize; */
 NS_IMETHODIMP nsMsgImapLineDownloadCache::GetMsgSize(int32_t* aMsgSize) {
   *aMsgSize = m_msgSize;
   return NS_OK;
@@ -2309,18 +2309,26 @@ bool nsImapProtocol::TryToRunUrlLocally(
   if (!messageIdString.IsEmpty() &&
       !HandlingMultipleMessages(messageIdString)) {
     nsImapAction action;
     imapUrl->GetImapAction(&action);
     nsCOMPtr<nsIMsgFolder> folder;
     mailnewsUrl->GetFolder(getter_AddRefs(folder));
     NS_ENSURE_TRUE(folder, false);
 
-    folder->HasMsgOffline(strtoul(messageIdString.get(), nullptr, 10),
-                          &useLocalCache);
+    // Use UID to look up msgKey in db
+    nsCOMPtr<nsIMsgDatabase> db;
+    rv = folder->GetMsgDatabase(getter_AddRefs(db));
+    NS_ENSURE_SUCCESS(rv, false);
+    uint32_t msgUID = strtoul(messageIdString.get(), nullptr, 10);
+    nsTArray<nsMsgKey> keys;
+    rv = db->GetMsgKeysForUIDs({msgUID}, keys);
+    NS_ENSURE_SUCCESS(rv, false);
+    rv = folder->HasMsgOffline(keys[0], &useLocalCache);
+    NS_ENSURE_SUCCESS(rv, false);
     mailnewsUrl->SetMsgIsInLocalCache(useLocalCache);
     // We're downloading a single message for offline use, and it's
     // already offline. So we shouldn't do anything, but we do
     // need to notify the url listener.
     if (useLocalCache && action == nsIImapUrl::nsImapMsgDownloadForOffline) {
       nsCOMPtr<nsIRunnable> event =
           new UrlListenerNotifierEvent(mailnewsUrl, this);
       // Post this as an event because it can lead to re-entrant calls to
@@ -2730,17 +2738,17 @@ void nsImapProtocol::ProcessSelectedStat
                       .GetSelectedMailboxName()) {  // why are we in the
                                                     // selected state with no
                                                     // box name?
         SelectMailbox(mailboxName.get());
         selectIssued = true;
       } else if (moreHeadersToDownload &&
                  m_imapMailFolderSink)  // we need to fetch older headers
       {
-        nsTArray<nsMsgKey> msgIdList;
+        nsTArray<uint32_t> msgIdList;
         bool more;
         m_imapMailFolderSink->GetMsgHdrsToDownload(
             &more, &m_progressExpectedNumber, msgIdList);
         if (msgIdList.Length() > 0) {
           FolderHeaderDump(msgIdList.Elements(), msgIdList.Length());
           m_runningUrl->SetMoreHeadersToDownload(more);
           // We're going to be re-running this url.
           if (more) m_runningUrl->SetRerunningUrl(true);
@@ -4159,17 +4167,17 @@ void nsImapProtocol::ProcessMailboxUpdat
                   ("numToCheck=%" PRIu32, numToCheck));
           if (numToCheck && mFolderHighestUID) {
             uint32_t uid;
             int32_t topIndex;
             m_flagState->GetNumberOfMessages(&topIndex);
             do {
               topIndex--;
               m_flagState->GetUidOfMessage(topIndex, &uid);
-              if (uid && uid != nsMsgKey_None) {
+              if (uid) {
                 if (uid > mFolderHighestUID) {
                   numNewUIDs++;
                   MOZ_LOG(IMAP_CS, LogLevel::Debug,
                           ("numNewUIDs=%" PRIu32 ", Added new UID=%" PRIu32,
                            numNewUIDs, uid));
                   numToCheck--;
                 } else {
                   // Just a flag change on an existing UID. No more new UIDs
@@ -4230,34 +4238,34 @@ void nsImapProtocol::ProcessMailboxUpdat
       uint32_t highestRecordedUID = GetServerStateParser().HighestRecordedUID();
       // if we're using CONDSTORE, and the parser hasn't seen any UIDs, use
       // the highest UID previously seen and saved for the folder instead.
       if (useCS && !highestRecordedUID) highestRecordedUID = mFolderHighestUID;
       // clang-format off
       MOZ_LOG(IMAP_CS, LogLevel::Debug,
               ("Check for new messages above UID=%" PRIu32, highestRecordedUID));
       // clang-format on
-      AppendUid(fetchStr, highestRecordedUID + 1);
+      fetchStr.AppendInt(highestRecordedUID + 1);
       fetchStr.AppendLiteral(":*");
       FetchMessage(fetchStr, kFlags);  // only new messages please
     }
   } else if (GetServerStateParser().LastCommandSuccessful()) {
     GetServerStateParser().ResetFlagInfo();
     // the flag state is empty, but not partial.
     m_flagState->SetPartialUIDFetch(false);
   }
 
   if (GetServerStateParser().LastCommandSuccessful()) {
     nsImapAction imapAction;
     nsresult res = m_runningUrl->GetImapAction(&imapAction);
     if (NS_SUCCEEDED(res) && imapAction == nsIImapUrl::nsImapLiteSelectFolder)
       return;
   }
 
-  nsTArray<nsMsgKey> msgIdList;
+  nsTArray<uint32_t> msgIdList;
 
   if (GetServerStateParser().LastCommandSuccessful()) {
     ReentrantMonitorAutoEnter mon(m_waitForBodyIdsMonitor);
     RefPtr<nsImapMailboxSpec> new_spec =
         GetServerStateParser().CreateCurrentMailboxSpec();
     nsImapAction imapAction;
     nsresult res = m_runningUrl->GetImapAction(&imapAction);
     if (NS_SUCCEEDED(res) && imapAction == nsIImapUrl::nsImapExpungeFolder)
@@ -4284,17 +4292,17 @@ void nsImapProtocol::ProcessMailboxUpdat
     }
     HeaderFetchCompleted();
     // this might be bogus, how are we going to do pane notification and stuff
     // when we fetch bodies without headers!
   }
 
   // wait for a list of bodies to fetch.
   if (GetServerStateParser().LastCommandSuccessful()) {
-    nsTArray<nsMsgKey> msgIds;
+    nsTArray<uint32_t> msgIds;
     WaitForPotentialListOfBodysToFetch(msgIds);
     if (msgIds.Length() > 0 && GetServerStateParser().LastCommandSuccessful()) {
       // Tell the url that it should store the msg fetch results offline,
       // while we're dumping the messages, and then restore the setting.
       bool wasStoringOffline;
       m_runningUrl->GetStoreResultsOffline(&wasStoringOffline);
       m_runningUrl->SetStoreResultsOffline(true);
       // Assert that either it's empty string OR it must be message string.
@@ -4330,33 +4338,33 @@ void nsImapProtocol::FolderMsgDump(uint3
   }
 
   FolderMsgDumpLoop(msgUids, msgCount, fields);
 
   SetProgressString(IMAP_EMPTY_STRING_INDEX);
 }
 
 void nsImapProtocol::WaitForPotentialListOfBodysToFetch(
-    nsTArray<nsMsgKey>& msgIdList) {
+    nsTArray<uint32_t>& msgUIDs) {
   PRIntervalTime sleepTime = kImapSleepTime;
 
   ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);
   while (!m_fetchBodyListIsNew && !DeathSignalReceived())
     fetchListMon.Wait(sleepTime);
   m_fetchBodyListIsNew = false;
 
-  msgIdList = m_fetchBodyIdList.Clone();
+  msgUIDs = m_fetchBodyUIDList.Clone();
 }
 
 // libmsg uses this to notify a running imap url about message bodies it should
 // download. why not just have libmsg explicitly download the message bodies?
 NS_IMETHODIMP nsImapProtocol::NotifyBodysToDownload(
-    const nsTArray<nsMsgKey>& keys) {
+    const nsTArray<uint32_t>& uids) {
   ReentrantMonitorAutoEnter fetchListMon(m_fetchBodyListMonitor);
-  m_fetchBodyIdList = keys.Clone();
+  m_fetchBodyUIDList = uids.Clone();
   m_fetchBodyListIsNew = true;
   fetchListMon.Notify();
   return NS_OK;
 }
 
 NS_IMETHODIMP nsImapProtocol::GetFlagsForUID(uint32_t uid, bool* foundIt,
                                              imapMessageFlagsType* resultFlags,
                                              char** customFlags) {
@@ -4431,17 +4439,17 @@ void nsImapProtocol::PeriodicBiff() {
       deleted = m_flagState->NumberOfDeletedMessages();
       added = numMessages;
       if (!added || (added == deleted))  // empty keys, get them all
         id = 1;
 
       // sprintf(fetchStr, "%ld:%ld", id, id +
       // GetServerStateParser().NumberOfMessages() -
       // fFlagState->GetNumberOfMessages());
-      AppendUid(fetchStr, id);
+      fetchStr.AppendInt(id);
       fetchStr.AppendLiteral(":*");
       FetchMessage(fetchStr, kFlags);
       if (((uint32_t)m_flagState->GetHighestNonDeletedUID() >= id) &&
           m_flagState->IsLastMessageUnseen())
         m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NewMail;
       else
         m_currentBiffState = nsIMsgFolder::nsMsgBiffState_NoMail;
     } else
@@ -4858,24 +4866,24 @@ void nsImapProtocol::SetConnectionStatus
   MOZ_LOG(
       IMAP, NS_SUCCEEDED(status) ? LogLevel::Verbose : LogLevel::Debug,
       ("SetConnectionStatus(0x%" PRIx32 ")", static_cast<uint32_t>(status)));
   m_connectionStatus = status;
 }
 
 void nsImapProtocol::NotifyMessageFlags(imapMessageFlagsType flags,
                                         const nsACString& keywords,
-                                        nsMsgKey key, uint64_t highestModSeq) {
+                                        uint32_t uid, uint64_t highestModSeq) {
   if (m_imapMessageSink) {
     // if we're selecting the folder, don't need to report the flags; we've
     // already fetched them.
     if (m_imapAction != nsIImapUrl::nsImapSelectFolder &&
         (m_imapAction != nsIImapUrl::nsImapMsgFetch ||
          (flags & ~kImapMsgRecentFlag) != kImapMsgSeenFlag))
-      m_imapMessageSink->NotifyMessageFlags(flags, keywords, key,
+      m_imapMessageSink->NotifyMessageFlags(flags, keywords, uid,
                                             highestModSeq);
   }
 }
 
 void nsImapProtocol::NotifySearchHit(const char* hitLine) {
   nsresult rv;
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl =
       do_QueryInterface(m_runningUrl, &rv);
@@ -5204,30 +5212,31 @@ void nsImapProtocol::PercentProgressUpda
 }
 
 // imap commands issued by the parser
 void nsImapProtocol::Store(const nsCString& messageList,
                            const char* messageData, bool idsAreUid) {
   // turn messageList back into key array and then back into a message id list,
   // but use the flag state to handle ranges correctly.
   nsCString messageIdList;
-  nsTArray<nsMsgKey> msgKeys;
-  if (idsAreUid) ParseUidString(messageList.get(), msgKeys);
-
-  int32_t msgCountLeft = msgKeys.Length();
+  nsTArray<uint32_t> msgIDs;
+  if (idsAreUid) ParseUidString(messageList.get(), msgIDs);
+
+  int32_t msgCountLeft = msgIDs.Length();
   uint32_t msgsHandled = 0;
   do {
     nsCString idString;
 
     uint32_t msgsToHandle = msgCountLeft;
-    if (idsAreUid)
-      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle,
+    if (idsAreUid) {
+      AllocateImapUidString(msgIDs.Elements() + msgsHandled, msgsToHandle,
                             m_flagState, idString);  // 20 * 200
-    else
+    } else {
       idString.Assign(messageList);
+    }
 
     msgsHandled += msgsToHandle;
     msgCountLeft -= msgsToHandle;
 
     IncrementCommandTagNumber();
     const char* formatString;
     if (idsAreUid)
       formatString = "%s uid store %s %s\015\012";
@@ -5304,19 +5313,19 @@ void nsImapProtocol::Expunge() {
   ProgressEventFunctionUsingName("imapStatusExpungingMailbox");
 
   if (gCheckDeletedBeforeExpunge) {
     GetServerStateParser().ResetSearchResultSequence();
     Search("SEARCH DELETED", false, false);
     if (GetServerStateParser().LastCommandSuccessful()) {
       nsImapSearchResultIterator* search =
           GetServerStateParser().CreateSearchResultIterator();
-      nsMsgKey key = search->GetNextMessageNumber();
+      uint32_t uid = (uint32_t)search->GetNextMessageNumber();
       delete search;
-      if (key == 0) return;  // no deleted messages to expunge (bug 235004)
+      if (uid == 0) return;  // no deleted messages to expunge (bug 235004)
     }
   }
 
   IncrementCommandTagNumber();
   nsAutoCString command(GetServerCommandTag());
   command.AppendLiteral(" expunge" CRLF);
 
   nsresult rv = SendData(command.get());
@@ -6142,19 +6151,19 @@ void nsImapProtocol::UploadMessageFromFi
       urlOk = true;
 
       nsImapAction imapAction;
       m_runningUrl->GetImapAction(&imapAction);
 
       if (imapAction == nsIImapUrl::nsImapAppendDraftFromFile ||
           imapAction == nsIImapUrl::nsImapAppendMsgFromFile) {
         if (GetServerStateParser().GetCapabilityFlag() & kUidplusCapability) {
-          nsMsgKey newKey = GetServerStateParser().CurrentResponseUID();
+          uint32_t newUID = GetServerStateParser().CurrentResponseUID();
           if (m_imapMailFolderSink)
-            m_imapMailFolderSink->SetAppendMsgUid(newKey, m_runningUrl);
+            m_imapMailFolderSink->SetAppendMsgUid(newUID, m_runningUrl);
 
           // Courier imap server seems to have problems with recently
           // appended messages. Noop seems to clear its confusion.
           if (FolderIsSelected(mailboxName)) Noop();
 
           nsCString oldMsgId;
           rv = m_runningUrl->GetListOfMessageIds(oldMsgId);
           if (NS_SUCCEEDED(rv) && !oldMsgId.IsEmpty()) {
@@ -6191,23 +6200,23 @@ void nsImapProtocol::UploadMessageFromFi
               command = "SEARCH UNDELETED HEADER Message-ID ";
               command.Append(messageId);
 
               // Clean up result sequence before issuing the cmd.
               GetServerStateParser().ResetSearchResultSequence();
 
               Search(command.get(), true, false);
               if (GetServerStateParser().LastCommandSuccessful()) {
-                nsMsgKey newkey = nsMsgKey_None;
                 nsImapSearchResultIterator* searchResult =
                     GetServerStateParser().CreateSearchResultIterator();
-                newkey = searchResult->GetNextMessageNumber();
+                uint32_t newUID =
+                    (uint32_t)searchResult->GetNextMessageNumber();
                 delete searchResult;
-                if (newkey != nsMsgKey_None)
-                  m_imapMailFolderSink->SetAppendMsgUid(newkey, m_runningUrl);
+                if (newUID)
+                  m_imapMailFolderSink->SetAppendMsgUid(newUID, m_runningUrl);
               } else
                 urlOk = false;
             } else
               urlOk = false;
           }
         }
       }
     }
@@ -7789,28 +7798,28 @@ void nsImapProtocol::Copy(const char* me
   IncrementCommandTagNumber();
 
   nsCString escapedDestination;
   CreateEscapedMailboxName(destinationMailbox, escapedDestination);
 
   // turn messageList back into key array and then back into a message id list,
   // but use the flag state to handle ranges correctly.
   nsCString messageIdList;
-  nsTArray<nsMsgKey> msgKeys;
-  if (idsAreUid) ParseUidString(messageList, msgKeys);
-
-  int32_t msgCountLeft = msgKeys.Length();
+  nsTArray<uint32_t> msgIDs;
+  if (idsAreUid) ParseUidString(messageList, msgIDs);
+
+  int32_t msgCountLeft = msgIDs.Length();
   uint32_t msgsHandled = 0;
 
   do {
     nsCString idString;
 
     uint32_t msgsToHandle = msgCountLeft;
     if (idsAreUid)
-      AllocateImapUidString(msgKeys.Elements() + msgsHandled, msgsToHandle,
+      AllocateImapUidString(msgIDs.Elements() + msgsHandled, msgsToHandle,
                             m_flagState, idString);
     else
       idString.Assign(messageList);
 
     msgsHandled += msgsToHandle;
     msgCountLeft -= msgsToHandle;
 
     IncrementCommandTagNumber();
@@ -8099,25 +8108,25 @@ void nsImapProtocol::ProcessStoreFlags(c
   {
     // replace the final space with ')'
     flagString.SetCharAt(')', flagString.Length() - 1);
 
     Store(messageIdsString, flagString.get(), idsAreUids);
     if (m_runningUrl && idsAreUids) {
       nsCString messageIdString;
       m_runningUrl->GetListOfMessageIds(messageIdString);
-      nsTArray<nsMsgKey> msgKeys;
-      ParseUidString(messageIdString.get(), msgKeys);
-
-      int32_t msgCount = msgKeys.Length();
+      nsTArray<uint32_t> msgUIDs;
+      ParseUidString(messageIdString.get(), msgUIDs);
+
+      int32_t msgCount = msgUIDs.Length();
       for (int32_t i = 0; i < msgCount; i++) {
         bool found;
         imapMessageFlagsType resultFlags;
         // check if the flags were added/removed, and if the uid really exists.
-        nsresult rv = GetFlagsForUID(msgKeys[i], &found, &resultFlags, nullptr);
+        nsresult rv = GetFlagsForUID(msgUIDs[i], &found, &resultFlags, nullptr);
         if (NS_FAILED(rv) || !found ||
             (addFlags && ((flags & resultFlags) != flags)) ||
             (!addFlags && ((flags & resultFlags) != 0))) {
           m_runningUrl->SetExtraStatus(nsIImapUrl::ImapStatusFlagChangeFailed);
           break;
         }
       }
     }
@@ -9470,19 +9479,22 @@ bool nsImapMockChannel::ReadFromLocalCac
   imapUrl->GetListOfMessageIds(messageIdString);
   nsCOMPtr<nsIMsgFolder> folder;
   rv = mailnewsUrl->GetFolder(getter_AddRefs(folder));
   NS_ENSURE_SUCCESS(rv, false);
   if (!folder) {
     return false;
   }
   // we want to create a file channel and read the msg from there.
-  nsMsgKey msgKey = strtoul(messageIdString.get(), nullptr, 10);
+  uint32_t msgUID = strtoul(messageIdString.get(), nullptr, 10);
+  nsCOMPtr<nsIMsgDatabase> db;
+  rv = folder->GetMsgDatabase(getter_AddRefs(db));
+  NS_ENSURE_SUCCESS(rv, false);
   nsCOMPtr<nsIMsgDBHdr> hdr;
-  rv = folder->GetMessageHeader(msgKey, getter_AddRefs(hdr));
+  rv = db->GetMsgHdrForUID(msgUID, getter_AddRefs(hdr));
   NS_ENSURE_SUCCESS(rv, false);
   nsCOMPtr<nsIInputStream> msgStream;
   rv = folder->GetLocalMsgStream(hdr, getter_AddRefs(msgStream));
   NS_ENSURE_SUCCESS(rv, false);
   // dougt - This may break the ablity to "cancel" a read from offline
   // mail reading. fileChannel->SetLoadGroup(m_loadGroup);
   RefPtr<nsImapCacheStreamListener> cacheListener =
       new nsImapCacheStreamListener();
diff --git a/mailnews/imap/src/nsImapProtocol.h b/mailnews/imap/src/nsImapProtocol.h
--- a/mailnews/imap/src/nsImapProtocol.h
+++ b/mailnews/imap/src/nsImapProtocol.h
@@ -283,17 +283,17 @@ class nsImapProtocol : public nsIImapPro
   GetImapHostName();  // return the host name from the url for the
   // current connection
   const nsCString& GetImapUserName();  // return the user name from the identity
   const char*
   GetImapServerKey();  // return the user name from the incoming server;
 
   // state set by the imap parser...
   void NotifyMessageFlags(imapMessageFlagsType flags,
-                          const nsACString& keywords, nsMsgKey key,
+                          const nsACString& keywords, uint32_t uid,
                           uint64_t highestModSeq);
   void NotifySearchHit(const char* hitLine);
 
   // Event handlers for the imap parser.
   void DiscoverMailboxSpec(nsImapMailboxSpec* adoptedBoxSpec);
   void AlertUserEventUsingName(const char* aMessageId);
   void AlertUserEvent(const char* message);
   void AlertUserEventFromServer(const char* aServerEvent,
@@ -475,30 +475,30 @@ class nsImapProtocol : public nsIImapPro
   void SendSetBiffIndicatorEvent(nsMsgBiffState newState);
 
   // folder opening and listing header functions
   void FolderHeaderDump(uint32_t* msgUids, uint32_t msgCount);
   void FolderMsgDump(uint32_t* msgUids, uint32_t msgCount,
                      nsIMAPeFetchFields fields);
   void FolderMsgDumpLoop(uint32_t* msgUids, uint32_t msgCount,
                          nsIMAPeFetchFields fields);
-  void WaitForPotentialListOfBodysToFetch(nsTArray<nsMsgKey>& msgIdList);
+  void WaitForPotentialListOfBodysToFetch(nsTArray<uint32_t>& msgUIDs);
   void HeaderFetchCompleted();
   void UploadMessageFromFile(nsIFile* file, const char* mailboxName,
                              PRTime date, imapMessageFlagsType flags,
                              nsCString& keywords);
 
   // mailbox name utilities.
   void CreateEscapedMailboxName(const char* rawName, nsCString& escapedName);
   void SetupMessageFlagsString(nsCString& flagString,
                                imapMessageFlagsType flags, uint16_t userFlags);
 
   // body fetching listing data
   bool m_fetchBodyListIsNew;
-  nsTArray<nsMsgKey> m_fetchBodyIdList;
+  nsTArray<uint32_t> m_fetchBodyUIDList;
 
   // initialization function given a new url and transport layer
   nsresult SetupWithUrl(nsIURI* aURL, nsISupports* aConsumer);
   nsresult SetupWithUrlCallback(nsIProxyInfo* proxyInfo);
   void ReleaseUrlState(bool rerunningUrl);  // release any state that is stored
                                             // on a per action basis.
   /**
    * Last ditch effort to run the url without using an imap connection.
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -233,16 +233,26 @@ NS_IMETHODIMP nsImapService::GetUrlForUr
 
   if (messageURI.Find("&type=application/x-message-display"_ns) != kNotFound)
     return NS_NewURI(aURL, aMessageURI);
 
   nsCOMPtr<nsIMsgFolder> folder;
   nsMsgKey msgKey;
   nsresult rv = DecomposeImapURI(messageURI, getter_AddRefs(folder), &msgKey);
   if (NS_SUCCEEDED(rv)) {
+    // Message URIs use msgdb keys, IMAP protocol urls use UIDs.
+    nsCOMPtr<nsIMsgDatabase> db;
+    rv = folder->GetMsgDatabase(getter_AddRefs(db));
+    NS_ENSURE_SUCCESS(rv, rv);
+    nsTArray<uint32_t> uids;
+    rv = db->GetMsgUIDsForKeys({msgKey}, uids);
+    NS_ENSURE_SUCCESS(rv, rv);
+    MOZ_ASSERT(!uids.IsEmpty());
+    uint32_t msgUID = uids[0];
+
     nsCOMPtr<nsIImapUrl> imapUrl;
     nsAutoCString urlSpec;
     char hierarchyDelimiter = GetHierarchyDelimiter(folder);
     rv = CreateStartOfImapUrl(messageURI, getter_AddRefs(imapUrl), folder,
                               nullptr, urlSpec, hierarchyDelimiter);
     NS_ENSURE_SUCCESS(rv, rv);
     rv = SetImapUrlSink(folder, imapUrl);
     NS_ENSURE_SUCCESS(rv, rv);
@@ -256,17 +266,17 @@ NS_IMETHODIMP nsImapService::GetUrlForUr
     NS_ENSURE_SUCCESS(rv, rv);
     urlSpec.AppendLiteral("fetch>UID>");
     urlSpec.Append(hierarchyDelimiter);
 
     nsAutoCString folderName;
     GetFolderName(folder, folderName);
     urlSpec.Append(folderName);
     urlSpec.Append('>');
-    urlSpec.AppendInt(msgKey);
+    urlSpec.AppendInt(msgUID);
     rv = mailnewsUrl->SetSpecInternal(urlSpec);
     imapUrl->QueryInterface(NS_GET_IID(nsIURI), (void**)aURL);
   }
 
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::FetchMimePart(
@@ -360,19 +370,20 @@ NS_IMETHODIMP nsImapService::LoadMessage
       char hierarchyDelimiter = GetHierarchyDelimiter(folder);
       rv = CreateStartOfImapUrl(messageURI, getter_AddRefs(imapUrl), folder,
                                 aUrlListener, urlSpec, hierarchyDelimiter);
       NS_ENSURE_SUCCESS(rv, rv);
       if (!mimePart.IsEmpty()) {
         nsresult rv;
         nsCOMPtr<nsIMsgMailNewsUrl> mailnewsurl = do_QueryInterface(imapUrl);
 
-        nsAutoCString msgKey;
-        msgKey.AppendInt(key);
-        rv = AddImapFetchToUrl(mailnewsurl, folder, msgKey + mimePart,
+        nsAutoCString uidStr;
+        rv = MsgKeysToUIDSet(folder, {key}, uidStr);
+        NS_ENSURE_SUCCESS(rv, rv);
+        rv = AddImapFetchToUrl(mailnewsurl, folder, uidStr + mimePart,
                                EmptyCString());
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsIURI> dummyURI;
         return FetchMimePart(imapUrl, folder, imapMessageSink,
                              getter_AddRefs(dummyURI), aDisplayConsumer, key,
                              mimePart);
       }
@@ -410,23 +421,24 @@ NS_IMETHODIMP nsImapService::LoadMessage
         bool markReadDelay = false;
         prefBranch->GetBoolPref("mailnews.mark_message_read.delay",
                                 &markReadDelay);
         forcePeek = (!markReadAuto || markReadDelay ||
                      (dontMarkAsReadPos != kNotFound));
       }
 
       nsCOMPtr<nsIURI> dummyURI;
-      nsAutoCString msgKey;
-      msgKey.AppendInt(key);
+      nsAutoCString uidStr;
+      rv = MsgKeysToUIDSet(folder, {key}, uidStr);
+      NS_ENSURE_SUCCESS(rv, rv);
       rv = FetchMessage(imapUrl,
                         forcePeek ? nsIImapUrl::nsImapMsgFetchPeek
                                   : nsIImapUrl::nsImapMsgFetch,
                         folder, imapMessageSink, aMsgWindow, aDisplayConsumer,
-                        msgKey, false, getter_AddRefs(dummyURI));
+                        uidStr, false, getter_AddRefs(dummyURI));
     }
   }
   return rv;
 }
 
 nsresult nsImapService::FetchMimePart(nsIImapUrl* aImapUrl,
                                       nsIMsgFolder* aImapMailFolder,
                                       nsIImapMessageSink* aImapMessage,
@@ -561,21 +573,22 @@ NS_IMETHODIMP nsImapService::CopyMessage
         nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(imapUrl));
         folder->HasMsgOffline(key, &hasMsgOffline);
         if (msgurl) msgurl->SetMsgIsInLocalCache(hasMsgOffline);
       }
       // now try to download the message
       nsImapAction imapAction = nsIImapUrl::nsImapOnlineToOfflineCopy;
       if (moveMessage) imapAction = nsIImapUrl::nsImapOnlineToOfflineMove;
       nsCOMPtr<nsIURI> dummyURI;
-      nsAutoCString msgKey;
-      msgKey.AppendInt(key);
+      nsAutoCString uidStr;
+      rv = MsgKeysToUIDSet(folder, {key}, uidStr);
+      NS_ENSURE_SUCCESS(rv, rv);
       rv =
           FetchMessage(imapUrl, imapAction, folder, imapMessageSink, aMsgWindow,
-                       aMailboxCopy, msgKey, false, getter_AddRefs(dummyURI));
+                       aMailboxCopy, uidStr, false, getter_AddRefs(dummyURI));
     }  // if we got an imap message sink
   }    // if we decomposed the imap message
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::CopyMessages(
     const nsTArray<nsMsgKey>& aKeys, nsIMsgFolder* srcFolder,
     nsIStreamListener* aMailboxCopy, bool moveMessage,
@@ -588,36 +601,34 @@ NS_IMETHODIMP nsImapService::CopyMessage
   nsCOMPtr<nsIImapMessageSink> imapMessageSink(do_QueryInterface(folder, &rv));
   if (NS_SUCCEEDED(rv)) {
     // we generate the uri for the first message so that way on down the line,
     // GetMessage in nsCopyMessageStreamListener will get an unescaped
     // username and be able to find the msg hdr. See bug 259656 for details
     nsCString uri;
     srcFolder->GenerateMessageURI(aKeys[0], uri);
 
-    nsCString messageIds;
-    // TODO: AllocateImapUidString() maxes out at 950 keys or so... it
-    // updates the numKeys passed in, but here the resulting value is
-    // ignored. Does this need sorting out?
-    uint32_t numKeys = aKeys.Length();
-    AllocateImapUidString(aKeys.Elements(), numKeys, nullptr, messageIds);
+    nsAutoCString messageUIDs;
+    rv = MsgKeysToUIDSet(folder, aKeys, messageUIDs);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     nsCOMPtr<nsIImapUrl> imapUrl;
     nsAutoCString urlSpec;
     char hierarchyDelimiter = GetHierarchyDelimiter(folder);
     rv = CreateStartOfImapUrl(uri, getter_AddRefs(imapUrl), folder,
                               aUrlListener, urlSpec, hierarchyDelimiter);
     nsImapAction action;
     if (moveMessage)  // don't use ?: syntax here, it seems to break the Mac.
       action = nsIImapUrl::nsImapOnlineToOfflineMove;
     else
       action = nsIImapUrl::nsImapOnlineToOfflineCopy;
     imapUrl->SetCopyState(aMailboxCopy);
     // now try to display the message
     rv = FetchMessage(imapUrl, action, folder, imapMessageSink, aMsgWindow,
-                      aMailboxCopy, messageIds, false, aURL);
+                      aMailboxCopy, messageUIDs, false, aURL);
     // ### end of copy operation should know how to do the delete.if this is a
     // move
 
   }  // if we got an imap message sink
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::Search(nsIMsgSearchSession* aSearchSession,
@@ -718,22 +729,22 @@ NS_IMETHODIMP nsImapService::SaveMessage
 
     nsCOMPtr<nsIMsgMailNewsUrl> mailnewsUrl = do_QueryInterface(msgUrl);
     if (mailnewsUrl) mailnewsUrl->SetMsgIsInLocalCache(hasMsgOffline);
 
     nsCOMPtr<nsIStreamListener> saveAsListener;
     mailnewsUrl->GetSaveAsListener(aAddDummyEnvelope, aFile,
                                    getter_AddRefs(saveAsListener));
 
-    // IMAP code uses UID as msgkey.
-    nsAutoCString uid;
-    uid.AppendInt(msgKey);
+    nsAutoCString uidStr;
+    rv = MsgKeysToUIDSet(folder, {msgKey}, uidStr);
+    NS_ENSURE_SUCCESS(rv, rv);
     return FetchMessage(imapUrl, nsIImapUrl::nsImapSaveMessageToDisk, folder,
-                        imapMessageSink, aMsgWindow, saveAsListener, uid, false,
-                        aURL);
+                        imapMessageSink, aMsgWindow, saveAsListener, uidStr,
+                        false, aURL);
   }
   return rv;
 }
 
 /* fetching RFC822 messages */
 /* imap4://HOST>fetch>UID>MAILBOXPATH>x */
 /*   'x' is the message UID */
 /* will set the 'SEEN' flag */
@@ -967,19 +978,20 @@ NS_IMETHODIMP nsImapService::StreamMessa
 
   // This option is used by the JS Mime Emitter, in case we want a cheap
   // streaming, for example, if we just want a quick look at some header,
   // without having to download all the attachments...
 
   // We need to add the fetch command here for the cache lookup to behave
   // correctly
   nsAutoCString additionalHeader(aAdditionalHeader);
-  nsAutoCString msgKey;
-  msgKey.AppendInt(key);
-  rv = AddImapFetchToUrl(mailnewsurl, folder, msgKey, additionalHeader);
+  nsAutoCString uidStr;
+  rv = MsgKeysToUIDSet(folder, {key}, uidStr);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = AddImapFetchToUrl(mailnewsurl, folder, uidStr, additionalHeader);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIMsgIncomingServer> aMsgIncomingServer;
 
   mailnewsurl->SetMsgWindow(aMsgWindow);
   rv = mailnewsurl->GetServer(getter_AddRefs(aMsgIncomingServer));
 
   // Try to check if the message is offline
@@ -2286,23 +2298,37 @@ nsresult nsImapService::NewURI(const nsA
     // isn't found is common when folders are renamed or moved.
     // We also ignore return statuses here.
     if (folder) {
       nsCOMPtr<nsIImapMessageSink> msgSink = do_QueryInterface(folder);
       (void)aImapUrl->SetImapMessageSink(msgSink);
 
       (void)SetImapUrlSink(folder, aImapUrl);
 
-      nsCString messageIdString;
-      aImapUrl->GetListOfMessageIds(messageIdString);
-      if (!messageIdString.IsEmpty()) {
+      // Figure out if we've got a local copy of the message.
+      nsCString uidSet;
+      aImapUrl->GetListOfMessageIds(uidSet);
+      if (!uidSet.IsEmpty()) {
         bool useLocalCache = false;
-        folder->HasMsgOffline(strtoul(messageIdString.get(), nullptr, 10),
-                              &useLocalCache);
-        mailnewsUrl->SetMsgIsInLocalCache(useLocalCache);
+        nsTArray<uint32_t> uids;
+        ParseUidString(uidSet.get(), uids);
+        if (uids.Length() != 1) {
+          NS_WARNING("Expected a single UID");
+        } else {
+          nsCOMPtr<nsIMsgDatabase> db;
+          rv = folder->GetMsgDatabase(getter_AddRefs(db));
+          if (NS_SUCCEEDED(rv)) {
+            nsTArray<nsMsgKey> keys(1);
+            rv = db->GetMsgKeysForUIDs(uids, keys);
+            if (NS_SUCCEEDED(rv)) {
+              folder->HasMsgOffline(keys[0], &useLocalCache);
+              mailnewsUrl->SetMsgIsInLocalCache(useLocalCache);
+            }
+          }
+        }
       }
     }
   }
 
   // we got an imap url, so be sure to return it...
   nsCOMPtr<nsIURI> imapUri = do_QueryInterface(aImapUrl);
 
   imapUri.forget(aRetVal);
diff --git a/mailnews/imap/src/nsImapService.h b/mailnews/imap/src/nsImapService.h
--- a/mailnews/imap/src/nsImapService.h
+++ b/mailnews/imap/src/nsImapService.h
@@ -76,21 +76,19 @@ class nsImapService : public nsIImapServ
       char& hierarchyDelimiter);
 
   nsresult GetImapConnectionAndLoadUrl(nsIImapUrl* aImapUrl,
                                        nsISupports* aConsumer, nsIURI** aURL);
 
   static nsresult SetImapUrlSink(nsIMsgFolder* aMsgFolder,
                                  nsIImapUrl* aImapUrl);
 
-  nsresult FetchMimePart(nsIImapUrl* aImapUrl, nsImapAction aImapAction,
-                         nsIMsgFolder* aImapMailFolder,
+  nsresult FetchMimePart(nsIImapUrl* aImapUrl, nsIMsgFolder* aImapMailFolder,
                          nsIImapMessageSink* aImapMessage, nsIURI** aURL,
-                         nsISupports* aDisplayConsumer,
-                         const nsACString& messageIdentifierList,
+                         nsISupports* aDisplayConsumer, nsMsgKey msgKey,
                          const nsACString& mimePart);
 
   nsresult FolderCommand(nsIMsgFolder* imapMailFolder,
                          nsIUrlListener* urlListener, const char* aCommand,
                          nsImapAction imapAction, nsIMsgWindow* msgWindow,
                          nsIURI** url);
 
   nsresult ChangeFolderSubscription(nsIMsgFolder* folder,
diff --git a/mailnews/imap/src/nsImapUndoTxn.cpp b/mailnews/imap/src/nsImapUndoTxn.cpp
--- a/mailnews/imap/src/nsImapUndoTxn.cpp
+++ b/mailnews/imap/src/nsImapUndoTxn.cpp
@@ -1,35 +1,34 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "msgCore.h"  // for precompiled headers
 #include "nsIMsgHdr.h"
 #include "nsImapUndoTxn.h"
+#include "nsImapUtils.h"
 #include "nsIMsgIncomingServer.h"
 #include "nsImapMailFolder.h"
 #include "nsIImapService.h"
 #include "nsIDBFolderInfo.h"
 #include "nsIMsgDatabase.h"
 #include "nsMsgUtils.h"
 #include "nsThreadUtils.h"
 #include "nsServiceManagerUtils.h"
 #include "nsComponentManagerUtils.h"
 
 nsImapMoveCopyMsgTxn::nsImapMoveCopyMsgTxn()
     : m_idsAreUids(false), m_isMove(false), m_srcIsPop3(false) {}
 
 nsresult nsImapMoveCopyMsgTxn::Init(nsIMsgFolder* srcFolder,
                                     nsTArray<nsMsgKey>* srcKeyArray,
-                                    const char* srcMsgIdString,
                                     nsIMsgFolder* dstFolder, bool idsAreUids,
                                     bool isMove) {
-  m_srcMsgIdString = srcMsgIdString;
   m_idsAreUids = idsAreUids;
   m_isMove = isMove;
   m_srcFolder = do_GetWeakReference(srcFolder);
   m_dstFolder = do_GetWeakReference(dstFolder);
   m_srcKeyArray = srcKeyArray->Clone();
   m_dupKeyArray = srcKeyArray->Clone();
   nsCString uri;
   nsresult rv = srcFolder->GetURI(uri);
@@ -62,16 +61,19 @@ nsresult nsImapMoveCopyMsgTxn::Init(nsIM
           }
           m_dupKeyArray[i] = pseudoKey;
         }
       }
       srcHdr->GetMessageId(getter_Copies(messageId));
       m_srcMessageIds.AppendElement(messageId);
     }
   }
+  // Find the UIDs for the src messages.
+  rv = MsgKeysToUIDSet(srcDB, m_srcKeyArray, m_srcMsgUIDSet);
+  NS_ENSURE_SUCCESS(rv, rv);
   return nsMsgTxn::Init();
 }
 
 nsImapMoveCopyMsgTxn::~nsImapMoveCopyMsgTxn() {}
 
 NS_IMPL_ISUPPORTS_INHERITED(nsImapMoveCopyMsgTxn, nsMsgTxn, nsIUrlListener)
 
 NS_IMETHODIMP
@@ -104,36 +106,36 @@ nsImapMoveCopyMsgTxn::UndoTransaction(vo
       nsMsgImapDeleteModel deleteModel;
       rv = GetImapDeleteModel(srcFolder, &deleteModel);
 
       // protect against a bogus undo txn without any source keys
       // see bug #179856 for details
       NS_ASSERTION(!m_srcKeyArray.IsEmpty(), "no source keys");
       if (m_srcKeyArray.IsEmpty()) return NS_ERROR_UNEXPECTED;
 
-      if (!m_srcMsgIdString.IsEmpty()) {
+      if (!m_srcMsgUIDSet.IsEmpty()) {
         if (NS_SUCCEEDED(rv) &&
             deleteModel == nsMsgImapDeleteModels::IMAPDelete)
           CheckForToggleDelete(srcFolder, m_srcKeyArray[0], &deletedMsgs);
 
         if (deletedMsgs)
           rv = imapService->SubtractMessageFlags(
-              srcFolder, this, m_srcMsgIdString, kImapMsgDeletedFlag,
+              srcFolder, this, m_srcMsgUIDSet, kImapMsgDeletedFlag,
               m_idsAreUids);
         else
           rv = imapService->AddMessageFlags(srcFolder, srcListener,
-                                            m_srcMsgIdString,
-                                            kImapMsgDeletedFlag, m_idsAreUids);
+                                            m_srcMsgUIDSet, kImapMsgDeletedFlag,
+                                            m_idsAreUids);
         if (NS_FAILED(rv)) return rv;
 
         finishInOnStopRunningUrl = true;
         if (deleteModel != nsMsgImapDeleteModels::IMAPDelete)
           nsCOMPtr<nsIURI> outUri;
         rv = imapService->GetHeaders(srcFolder, srcListener,
-                                     getter_AddRefs(outUri), m_srcMsgIdString,
+                                     getter_AddRefs(outUri), m_srcMsgUIDSet,
                                      true);
       }
     }
   }
   if (!finishInOnStopRunningUrl && !m_dstMsgIdString.IsEmpty()) {
     nsCOMPtr<nsIMsgFolder> dstFolder = do_QueryReferent(m_dstFolder, &rv);
     if (NS_FAILED(rv) || !dstFolder) return rv;
 
@@ -159,17 +161,17 @@ nsImapMoveCopyMsgTxn::RedoTransaction(vo
   nsCOMPtr<nsIImapService> imapService =
       do_GetService("@mozilla.org/messenger/imapservice;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (m_isMove || !m_dstFolder) {
     if (m_srcIsPop3) {
       rv = RedoMailboxDelete();
       if (NS_FAILED(rv)) return rv;
-    } else if (!m_srcMsgIdString.IsEmpty()) {
+    } else if (!m_srcMsgUIDSet.IsEmpty()) {
       nsCOMPtr<nsIMsgFolder> srcFolder = do_QueryReferent(m_srcFolder, &rv);
       if (NS_FAILED(rv) || !srcFolder) return rv;
       nsCOMPtr<nsIUrlListener> srcListener = do_QueryInterface(srcFolder, &rv);
       NS_ENSURE_SUCCESS(rv, rv);
 
       bool deletedMsgs = false;  // default will be false unless
                                  // imapDeleteModel;
       nsMsgImapDeleteModel deleteModel;
@@ -186,22 +188,22 @@ nsImapMoveCopyMsgTxn::RedoTransaction(vo
       // Make sure we are in the selected state; use lite select
       // folder so performance won't suffer.
       nsCOMPtr<nsIURI> outUri;
       rv = imapService->LiteSelectFolder(srcFolder, srcListener, nullptr,
                                          getter_AddRefs(outUri));
       NS_ENSURE_SUCCESS(rv, rv);
       if (deletedMsgs) {
         rv = imapService->SubtractMessageFlags(
-            srcFolder, srcListener, m_srcMsgIdString, kImapMsgDeletedFlag,
+            srcFolder, srcListener, m_srcMsgUIDSet, kImapMsgDeletedFlag,
             m_idsAreUids);
       } else {
-        rv = imapService->AddMessageFlags(srcFolder, srcListener,
-                                          m_srcMsgIdString, kImapMsgDeletedFlag,
-                                          m_idsAreUids);
+        rv =
+            imapService->AddMessageFlags(srcFolder, srcListener, m_srcMsgUIDSet,
+                                         kImapMsgDeletedFlag, m_idsAreUids);
       }
     }
   }
   if (!m_dstMsgIdString.IsEmpty()) {
     nsCOMPtr<nsIMsgFolder> dstFolder = do_QueryReferent(m_dstFolder, &rv);
     if (NS_FAILED(rv) || !dstFolder) return rv;
 
     nsCOMPtr<nsIUrlListener> dstListener;
@@ -238,19 +240,19 @@ nsresult nsImapMoveCopyMsgTxn::SetCopyRe
   return NS_OK;
 }
 
 nsresult nsImapMoveCopyMsgTxn::GetSrcKeyArray(nsTArray<nsMsgKey>& srcKeyArray) {
   srcKeyArray = m_srcKeyArray.Clone();
   return NS_OK;
 }
 
-nsresult nsImapMoveCopyMsgTxn::AddDstKey(nsMsgKey aKey) {
+nsresult nsImapMoveCopyMsgTxn::AddDstUID(uint32_t uid) {
   if (!m_dstMsgIdString.IsEmpty()) m_dstMsgIdString.Append(',');
-  m_dstMsgIdString.AppendInt((int32_t)aKey);
+  m_dstMsgIdString.AppendInt(uid);
   return NS_OK;
 }
 
 nsresult nsImapMoveCopyMsgTxn::UndoMailboxDelete() {
   nsresult rv = NS_ERROR_FAILURE;
   // ** jt -- only do this for mailbox protocol
   if (m_srcIsPop3) {
     nsCOMPtr<nsIMsgFolder> srcFolder = do_QueryReferent(m_srcFolder, &rv);
@@ -372,51 +374,50 @@ NS_IMETHODIMP nsImapMoveCopyMsgTxn::OnSt
                                           m_dstMsgIdString, kImapMsgDeletedFlag,
                                           m_idsAreUids);
       }
     } else if (imapAction == nsIImapUrl::nsImapSelectFolder) {
       // Now we should have the headers from the dest folder.
       // Look them up and move them back to the source folder.
       uint32_t count = m_srcMessageIds.Length();
       uint32_t i;
-      nsCString messageId;
-      nsTArray<nsMsgKey> dstKeys;
+      nsTArray<uint32_t> dstUIDs;
       nsCOMPtr<nsIMsgDatabase> destDB;
       nsCOMPtr<nsIMsgDBHdr> dstHdr;
 
       rv = dstFolder->GetMsgDatabase(getter_AddRefs(destDB));
       NS_ENSURE_SUCCESS(rv, rv);
       for (i = 0; i < count; i++) {
         rv = destDB->GetMsgHdrForMessageID(m_srcMessageIds[i].get(),
                                            getter_AddRefs(dstHdr));
         if (NS_SUCCEEDED(rv) && dstHdr) {
-          nsMsgKey dstKey;
-          dstHdr->GetMessageKey(&dstKey);
-          dstKeys.AppendElement(dstKey);
+          uint32_t uid;
+          dstHdr->GetImapUID(&uid);
+          dstUIDs.AppendElement(uid);
         }
       }
-      if (dstKeys.Length()) {
-        nsAutoCString uids;
-        nsImapMailFolder::AllocateUidStringFromKeys(dstKeys, uids);
-        rv = imapService->OnlineMessageCopy(dstFolder, uids, srcFolder, true,
-                                            true, nullptr, nullptr, nullptr,
-                                            nullptr);
+      if (!dstUIDs.IsEmpty()) {
+        nsAutoCString dstUIDSet;
+        rv = BuildUIDSet(dstUIDs, dstUIDSet);
+        NS_ENSURE_SUCCESS(rv, rv);
+        rv = imapService->OnlineMessageCopy(dstFolder, dstUIDSet, srcFolder,
+                                            true, true, nullptr, nullptr,
+                                            nullptr, nullptr);
       }
     }
   }
   return NS_OK;
 }
 
 nsImapOfflineTxn::nsImapOfflineTxn(nsIMsgFolder* srcFolder,
                                    nsTArray<nsMsgKey>* srcKeyArray,
-                                   const char* srcMsgIdString,
                                    nsIMsgFolder* dstFolder, bool isMove,
                                    nsOfflineImapOperationType opType,
                                    nsCOMArray<nsIMsgDBHdr>& srcHdrs) {
-  Init(srcFolder, srcKeyArray, srcMsgIdString, dstFolder, true, isMove);
+  Init(srcFolder, srcKeyArray, dstFolder, true, isMove);
 
   m_opType = opType;
   m_flags = 0;
   m_addFlags = false;
   if (opType == nsIMsgOfflineImapOperation::kDeletedMsg) {
     nsCOMPtr<nsIMsgDatabase> srcDB;
     nsCOMPtr<nsIDBFolderInfo> folderInfo;
 
diff --git a/mailnews/imap/src/nsImapUndoTxn.h b/mailnews/imap/src/nsImapUndoTxn.h
--- a/mailnews/imap/src/nsImapUndoTxn.h
+++ b/mailnews/imap/src/nsImapUndoTxn.h
@@ -16,46 +16,42 @@
 #include "nsIMsgOfflineImapOperation.h"
 #include "nsCOMPtr.h"
 #include "nsIWeakReferenceUtils.h"
 #include "nsCOMArray.h"
 
 class nsImapMoveCopyMsgTxn : public nsMsgTxn, nsIUrlListener {
  public:
   nsImapMoveCopyMsgTxn();
-  nsImapMoveCopyMsgTxn(nsIMsgFolder* srcFolder, nsTArray<nsMsgKey>* srcKeyArray,
-                       const char* srcMsgIdString, nsIMsgFolder* dstFolder,
-                       bool isMove);
 
   NS_DECL_ISUPPORTS_INHERITED
   NS_DECL_NSIURLLISTENER
 
   NS_IMETHOD UndoTransaction(void) override;
   NS_IMETHOD RedoTransaction(void) override;
 
   // helper
   nsresult SetCopyResponseUid(const char* msgIdString);
   nsresult GetSrcKeyArray(nsTArray<nsMsgKey>& srcKeyArray);
-  void GetSrcMsgIds(nsCString& srcMsgIds) { srcMsgIds = m_srcMsgIdString; }
-  nsresult AddDstKey(nsMsgKey aKey);
+  void GetSrcMsgUIDSet(nsCString& set) { set = m_srcMsgUIDSet; }
+  nsresult AddDstUID(uint32_t uid);
   nsresult UndoMailboxDelete();
   nsresult RedoMailboxDelete();
   nsresult Init(nsIMsgFolder* srcFolder, nsTArray<nsMsgKey>* srcKeyArray,
-                const char* srcMsgIdString, nsIMsgFolder* dstFolder,
-                bool idsAreUids, bool isMove);
+                nsIMsgFolder* dstFolder, bool idsAreUids, bool isMove);
 
  protected:
   virtual ~nsImapMoveCopyMsgTxn();
 
   nsWeakPtr m_srcFolder;
   nsCOMArray<nsIMsgDBHdr> m_srcHdrs;
   nsTArray<nsMsgKey> m_dupKeyArray;
   nsTArray<nsMsgKey> m_srcKeyArray;
   nsTArray<nsCString> m_srcMessageIds;
-  nsCString m_srcMsgIdString;
+  nsCString m_srcMsgUIDSet;
   nsWeakPtr m_dstFolder;
   nsCString m_dstMsgIdString;
   bool m_idsAreUids;
   bool m_isMove;
   bool m_srcIsPop3;
   nsTArray<uint32_t> m_srcSizeArray;
   // this is used when we chain urls for imap undo, since "this" needs
   // to be the listener, but the folder may need to also be notified.
@@ -63,18 +59,18 @@ class nsImapMoveCopyMsgTxn : public nsMs
 
   nsresult GetImapDeleteModel(nsIMsgFolder* aFolder,
                               nsMsgImapDeleteModel* aDeleteModel);
 };
 
 class nsImapOfflineTxn : public nsImapMoveCopyMsgTxn {
  public:
   nsImapOfflineTxn(nsIMsgFolder* srcFolder, nsTArray<nsMsgKey>* srcKeyArray,
-                   const char* srcMsgIdString, nsIMsgFolder* dstFolder,
-                   bool isMove, nsOfflineImapOperationType opType,
+                   nsIMsgFolder* dstFolder, bool isMove,
+                   nsOfflineImapOperationType opType,
                    nsCOMArray<nsIMsgDBHdr>& srcHdrs);
 
   NS_IMETHOD UndoTransaction(void) override;
   NS_IMETHOD RedoTransaction(void) override;
   void SetAddFlags(bool addFlags) { m_addFlags = addFlags; }
   void SetFlags(uint32_t flags) { m_flags = flags; }
 
  protected:
diff --git a/mailnews/imap/src/nsImapUrl.cpp b/mailnews/imap/src/nsImapUrl.cpp
--- a/mailnews/imap/src/nsImapUrl.cpp
+++ b/mailnews/imap/src/nsImapUrl.cpp
@@ -16,16 +16,17 @@
 #include "nsCOMPtr.h"
 #include "nsImapUtils.h"
 #include "nsIImapMockChannel.h"
 #include "nsIImapMailFolderSink.h"
 #include "nsIImapMessageSink.h"
 #include "nsIImapServerSink.h"
 #include "nsImapNamespace.h"
 #include "nsICacheEntry.h"
+#include "nsIMsgDatabase.h"  // Ugh. For GetUri().
 #include "nsIMsgFolder.h"
 #include "nsMsgUtils.h"
 #include "nsIMsgHdr.h"
 #include "nsServiceManagerUtils.h"
 #include "mozilla/Logging.h"
 
 using namespace mozilla;
 extern LazyLogModule IMAPCache;  // defined in nsImapProtocol.cpp
@@ -979,39 +980,62 @@ NS_IMETHODIMP nsImapUrl::GetNormalizedSp
 
 NS_IMETHODIMP nsImapUrl::SetUri(const nsACString& aURI) {
   mURI = aURI;
   return NS_OK;
 }
 
 NS_IMETHODIMP nsImapUrl::GetUri(nsACString& aURI) {
   nsresult rv = NS_OK;
-  if (!mURI.IsEmpty())
+  if (!mURI.IsEmpty()) {
     aURI = mURI;
-  else {
-    uint32_t key =
-        m_listOfMessageIds ? strtoul(m_listOfMessageIds, nullptr, 10) : 0;
-    nsCString canonicalPath;
-    AllocateCanonicalPath(m_sourceCanonicalFolderPathSubString,
-                          m_onlineSubDirSeparator,
-                          (getter_Copies(canonicalPath)));
-    nsCString fullFolderPath("/");
-    fullFolderPath.Append(m_userName);
-    nsAutoCString hostName;
-    rv = GetHost(hostName);
-    fullFolderPath.Append('@');
-    fullFolderPath.Append(hostName);
-    fullFolderPath.Append('/');
-    fullFolderPath.Append(canonicalPath);
+    return NS_OK;
+  }
+
+  // The IMAP URL will refer to a UID, but we need to map that to a nsMsgKey
+  // for the message URI. Which means looking it up in the DB.
+  nsCOMPtr<nsIMsgFolder> folder;
+  rv = GetFolder(getter_AddRefs(folder));
+  NS_ENSURE_SUCCESS(rv, rv);
+  // If we're trying to get a message URI from this url, then there _must_ be
+  // a folder, right?
+  MOZ_ASSERT(folder);
+  nsCOMPtr<nsIMsgDatabase> db;
+  rv = folder->GetMsgDatabase(getter_AddRefs(db));
+  NS_ENSURE_SUCCESS(rv, rv);
 
-    nsCString baseMessageURI;
-    nsCreateImapBaseMessageURI(fullFolderPath, baseMessageURI);
-    rv = nsBuildImapMessageURI(baseMessageURI.get(), key, aURI);
+  nsTArray<uint32_t> uids;
+  ParseUidString(m_listOfMessageIds, uids);
+  if (uids.Length() != 1) {
+    NS_WARNING("Expected a single UID");
+    return NS_ERROR_UNEXPECTED;
   }
-  return rv;
+  nsTArray<nsMsgKey> keys(1);
+  rv = db->GetMsgKeysForUIDs(uids, keys);
+  NS_ENSURE_SUCCESS(rv, rv);
+
+  nsCString canonicalPath;
+  AllocateCanonicalPath(m_sourceCanonicalFolderPathSubString,
+                        m_onlineSubDirSeparator,
+                        (getter_Copies(canonicalPath)));
+  nsCString fullFolderPath("/");
+  fullFolderPath.Append(m_userName);
+  nsAutoCString hostName;
+  rv = GetHost(hostName);
+  NS_ENSURE_SUCCESS(rv, rv);
+  fullFolderPath.Append('@');
+  fullFolderPath.Append(hostName);
+  fullFolderPath.Append('/');
+  fullFolderPath.Append(canonicalPath);
+
+  nsCString baseMessageURI;
+  nsCreateImapBaseMessageURI(fullFolderPath, baseMessageURI);
+  rv = nsBuildImapMessageURI(baseMessageURI.get(), keys[0], aURI);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
 }
 
 NS_IMPL_GETSET(nsImapUrl, AddDummyEnvelope, bool, m_addDummyEnvelope)
 NS_IMPL_GETSET(nsImapUrl, CanonicalLineEnding, bool, m_canonicalLineEnding)
 NS_IMETHODIMP nsImapUrl::GetMsgLoadingFromCache(bool* result) {
   NS_ENSURE_ARG_POINTER(result);
   *result = m_msgLoadingFromCache;
   return NS_OK;
diff --git a/mailnews/imap/src/nsImapUtils.cpp b/mailnews/imap/src/nsImapUtils.cpp
--- a/mailnews/imap/src/nsImapUtils.cpp
+++ b/mailnews/imap/src/nsImapUtils.cpp
@@ -1,15 +1,17 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "msgCore.h"
 #include "nsImapUtils.h"
+#include "nsIMsgDatabase.h"
+#include "nsIMsgFolder.h"
 #include "nsCOMPtr.h"
 #include "prsystem.h"
 #include "prprf.h"
 #include "nsNetCID.h"
 
 #include "nsMsgUtils.h"
 #include "nsImapFlagAndUidState.h"
 #include "nsImapNamespace.h"
@@ -297,17 +299,17 @@ void AllocateImapUidString(const uint32_
       break;
     }
     // If we are not the last item then we need to add the comma
     // but it's important we do it here, after the length check
     if (!lastKey) returnString += ',';
   }
 }
 
-void ParseUidString(const char* uidString, nsTArray<nsMsgKey>& keys) {
+void ParseUidString(const char* uidString, nsTArray<uint32_t>& uids) {
   // This is in the form <id>,<id>, or <id1>:<id2>
   if (!uidString) return;
 
   char curChar = *uidString;
   bool isRange = false;
   uint32_t curToken;
   uint32_t saveStartToken = 0;
 
@@ -316,21 +318,80 @@ void ParseUidString(const char* uidStrin
     curChar = *curCharPtr;
     while (curChar != ':' && curChar != ',' && curChar != '\0')
       curChar = *curCharPtr++;
 
     // we don't need to null terminate currentKeyToken because strtoul
     // stops at non-numeric chars.
     curToken = strtoul(currentKeyToken, nullptr, 10);
     if (isRange) {
-      while (saveStartToken < curToken) keys.AppendElement(saveStartToken++);
+      while (saveStartToken < curToken) uids.AppendElement(saveStartToken++);
     }
-    keys.AppendElement(curToken);
+    uids.AppendElement(curToken);
     isRange = (curChar == ':');
     if (isRange) saveStartToken = curToken + 1;
   }
 }
 
-void AppendUid(nsCString& msgIds, uint32_t uid) {
-  char buf[20];
-  PR_snprintf(buf, sizeof(buf), "%u", uid);
-  msgIds.Append(buf);
+// Build an IMAP UID set string containing given UIDs.
+// Coalesces UIDs into ranges where it can.
+// eg [3,2,1,42,100,101,102,103,104,105] => "1:3,42,100-105"
+nsresult BuildUIDSet(const nsTArray<uint32_t>& uids, nsACString& uidSet) {
+  uidSet.Truncate();
+  if (uids.IsEmpty()) return NS_ERROR_INVALID_ARG;
+  uint32_t startSequence;
+  startSequence = uids[0];
+  uint32_t curSequenceEnd = startSequence;
+  uint32_t total = uids.Length();
+  // sort uids and then generate ranges instead of singletons!
+  nsTArray<nsMsgKey> sorted(uids.Clone());
+  sorted.Sort();
+  for (uint32_t keyIndex = 0; keyIndex < total; keyIndex++) {
+    uint32_t curKey = sorted[keyIndex];
+    uint32_t nextKey =
+        (keyIndex + 1 < total) ? sorted[keyIndex + 1] : 0xFFFFFFFF;
+    bool lastKey = (nextKey == 0xFFFFFFFF);
+
+    if (lastKey) curSequenceEnd = curKey;
+    if (nextKey == (uint32_t)curSequenceEnd + 1 && !lastKey) {
+      curSequenceEnd = nextKey;
+      continue;
+    }
+    if (curSequenceEnd > startSequence) {
+      uidSet.AppendInt(startSequence);
+      uidSet += ':';
+      uidSet.AppendInt(curSequenceEnd);
+      if (!lastKey) uidSet += ',';
+      startSequence = nextKey;
+      curSequenceEnd = startSequence;
+    } else {
+      startSequence = nextKey;
+      curSequenceEnd = startSequence;
+      uidSet.AppendInt(sorted[keyIndex]);
+      if (!lastKey) uidSet += ',';
+    }
+  }
+  return NS_OK;
 }
+
+// Helper function to build UID sets for IMAP messages.
+// NOTE: with global msgkeys, we don't even need the db param. Left in for
+// now for transition.
+nsresult MsgKeysToUIDSet(nsIMsgDatabase* db, nsTArray<nsMsgKey> const& keys,
+                         nsACString& uidSet) {
+  nsTArray<uint32_t> uids(keys.Length());
+  nsresult rv = db->GetMsgUIDsForKeys(keys, uids);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = BuildUIDSet(uids, uidSet);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return NS_OK;
+}
+
+// Helper function to build UID sets for IMAP messages.
+// NOTE: with global msgkeys, we don't even need the folder param. Left in for
+// now for transition.
+nsresult MsgKeysToUIDSet(nsIMsgFolder* folder, nsTArray<nsMsgKey> const& keys,
+                         nsACString& uidSet) {
+  nsCOMPtr<nsIMsgDatabase> db;
+  nsresult rv = folder->GetMsgDatabase(getter_AddRefs(db));
+  NS_ENSURE_SUCCESS(rv, rv);
+  return MsgKeysToUIDSet(db, keys, uidSet);
+}
diff --git a/mailnews/imap/src/nsImapUtils.h b/mailnews/imap/src/nsImapUtils.h
--- a/mailnews/imap/src/nsImapUtils.h
+++ b/mailnews/imap/src/nsImapUtils.h
@@ -9,16 +9,18 @@
 #include "nsString.h"
 #include "MailNewsTypes.h"
 #include "nsTArray.h"
 #include "nsIMailboxSpec.h"
 #include "nsCOMPtr.h"
 
 class nsImapFlagAndUidState;
 class nsImapProtocol;
+class nsIMsgFolder;
+class nsIMsgDatabase;
 
 static const char kImapRootURI[] = "imap:/";
 static const char kImapMessageRootURI[] = "imap-message:/";
 static const char kModSeqPropertyName[] = "highestModSeq";
 static const char kHighestRecordedUIDPropertyName[] = "highestRecordedUID";
 static const char kDeletedHdrCountPropertyName[] = "numDeletedHeaders";
 
 extern nsresult nsImapURI2FullName(const char* rootURI, const char* hostname,
@@ -32,18 +34,17 @@ extern nsresult nsBuildImapMessageURI(co
                                       nsACString& uri);
 
 extern nsresult nsCreateImapBaseMessageURI(const nsACString& baseURI,
                                            nsCString& baseMessageURI);
 
 void AllocateImapUidString(const uint32_t* msgUids, uint32_t& msgCount,
                            nsImapFlagAndUidState* flagState,
                            nsCString& returnString);
-void ParseUidString(const char* uidString, nsTArray<nsMsgKey>& keys);
-void AppendUid(nsCString& msgIds, uint32_t uid);
+void ParseUidString(const char* uidString, nsTArray<uint32_t>& uids);
 
 class nsImapMailboxSpec : public nsIMailboxSpec {
  public:
   nsImapMailboxSpec();
 
   NS_DECL_THREADSAFE_ISUPPORTS
   NS_DECL_NSIMAILBOXSPEC
 
@@ -69,9 +70,20 @@ class nsImapMailboxSpec : public nsIMail
   bool mOnlineVerified;
 
   nsImapProtocol* mConnection;  // do we need this? It seems evil
 
  private:
   virtual ~nsImapMailboxSpec();
 };
 
+// Build an IMAP UID set string containing given UIDs.
+// Coalesces UIDs into ranges where it can.
+// eg [3,2,1,42,100,101,102,103,104,105] => "1:3,42,100-105"
+nsresult BuildUIDSet(const nsTArray<uint32_t>& uids, nsACString& uidSet);
+
+// Helpers for looking up UIDs of IMAP messages in db.
+nsresult MsgKeysToUIDSet(nsIMsgDatabase* db, nsTArray<nsMsgKey> const& keys,
+                         nsACString& uidSet);
+nsresult MsgKeysToUIDSet(nsIMsgFolder* folder, nsTArray<nsMsgKey> const& keys,
+                         nsACString& uidSet);
+
 #endif  // NS_IMAPUTILS_H
diff --git a/mailnews/imap/src/nsSyncRunnableHelpers.cpp b/mailnews/imap/src/nsSyncRunnableHelpers.cpp
--- a/mailnews/imap/src/nsSyncRunnableHelpers.cpp
+++ b/mailnews/imap/src/nsSyncRunnableHelpers.cpp
@@ -365,17 +365,17 @@ NS_SYNCRUNNABLEMETHOD1(ImapMailFolderSin
 NS_SYNCRUNNABLEMETHOD1(ImapMailFolderSink, SetBiffStateAndUpdate, int32_t)
 NS_SYNCRUNNABLEMETHOD3(ImapMailFolderSink, ProgressStatusString,
                        nsIImapProtocol*, const char*, const char16_t*)
 NS_SYNCRUNNABLEMETHOD5(ImapMailFolderSink, PercentProgress, nsIImapProtocol*,
                        nsACString const&, nsAString const&, int64_t, int64_t)
 NS_SYNCRUNNABLEMETHOD0(ImapMailFolderSink, ClearFolderRights)
 NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, SetCopyResponseUid, const char*,
                        nsIImapUrl*)
-NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, SetAppendMsgUid, nsMsgKey,
+NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, SetAppendMsgUid, uint32_t,
                        nsIImapUrl*)
 NS_SYNCRUNNABLEMETHOD2(ImapMailFolderSink, GetMessageId, nsIImapUrl*,
                        nsACString&)
 
 NS_SYNCRUNNABLEMETHOD2(ImapMessageSink, SetupMsgWriteStream, nsIFile*, bool)
 NS_SYNCRUNNABLEMETHOD3(ImapMessageSink, ParseAdoptedMsgLine, const char*,
                        nsMsgKey, nsIImapUrl*)
 NS_SYNCRUNNABLEMETHOD4(ImapMessageSink, NormalEndMsgWriteStream, nsMsgKey, bool,
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1686096897 -43200
#      Wed Jun 07 12:14:57 2023 +1200
# Node ID 84e5e1eff52eecd7f9d086cbb34d16ea6debdeb3
# Parent  8356188d476e3984042a178f7842ca20f435e0be
Use local dovecot server UID knowledge to check for bogus msgKeys! BenC local hack.

diff --git a/mailnews/db/msgdb/src/nsMsgHdr2.cpp b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
--- a/mailnews/db/msgdb/src/nsMsgHdr2.cpp
+++ b/mailnews/db/msgdb/src/nsMsgHdr2.cpp
@@ -18,17 +18,21 @@
 NS_IMPL_ISUPPORTS(nsMsgHdr2, nsIMsgDBHdr)
 
 #define FLAGS_INITED 0x1
 #define CACHED_VALUES_INITED 0x2
 #define REFERENCES_INITED 0x4
 #define THREAD_PARENT_INITED 0x8
 
 nsMsgHdr2::nsMsgHdr2(nsMsgDatabase2* folderDB, nsMsgKey key)
-    : mFolderDB(folderDB), mKey(key) {}
+    : mFolderDB(folderDB), mKey(key) {
+  // My local dovecot setup has UIDS > 10000, so this is an temporary test
+  // to catch any uses of UIDs as keys!
+  MOZ_ASSERT(key < 10000);
+}
 
 nsMsgHdr2::~nsMsgHdr2() {}
 
 NS_IMETHODIMP nsMsgHdr2::GetMessageKey(nsMsgKey* result) {
   *result = mKey;
   return NS_OK;
 }
 
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1686097002 -43200
#      Wed Jun 07 12:16:42 2023 +1200
# Node ID 4191e48da5a60826471fb4b5229d9f34d092140d
# Parent  84e5e1eff52eecd7f9d086cbb34d16ea6debdeb3
Fix folder creation (don't rely on dbs being files!)

diff --git a/mailnews/imap/src/nsImapMailFolder.cpp b/mailnews/imap/src/nsImapMailFolder.cpp
--- a/mailnews/imap/src/nsImapMailFolder.cpp
+++ b/mailnews/imap/src/nsImapMailFolder.cpp
@@ -921,34 +921,33 @@ NS_IMETHODIMP nsImapMailFolder::CreateCl
 
   // Create an empty database for this mail folder, set its name from the user
   nsCOMPtr<nsIMsgDatabase> mailDBFactory;
   nsCOMPtr<nsIMsgFolder> child;
 
   nsCOMPtr<nsIMsgDBService> msgDBService =
       do_GetService("@mozilla.org/msgDatabase/msgDBService;1", &rv);
   NS_ENSURE_SUCCESS(rv, rv);
-  nsCOMPtr<nsIMsgDatabase> unusedDB;
   nsCOMPtr<nsIFile> dbFile;
 
   // warning, path will be changed
   rv = CreateFileForDB(folderNameStr, path, getter_AddRefs(dbFile));
   NS_ENSURE_SUCCESS(rv, rv);
 
   // Now let's create the actual new folder
   rv = AddSubfolderWithPath(folderNameStr, dbFile, getter_AddRefs(child), true);
   NS_ENSURE_SUCCESS(rv, rv);
-  rv = msgDBService->OpenMailDBFromFile(dbFile, child, true, true,
-                                        getter_AddRefs(unusedDB));
+  nsCOMPtr<nsIMsgDatabase> childDB;
+  rv = msgDBService->OpenFolderDB(child, false, getter_AddRefs(childDB));
   if (rv == NS_MSG_ERROR_FOLDER_SUMMARY_MISSING) rv = NS_OK;
 
-  if (NS_SUCCEEDED(rv) && unusedDB) {
+  if (NS_SUCCEEDED(rv) && childDB) {
     // need to set the folder name
     nsCOMPtr<nsIDBFolderInfo> folderInfo;
-    rv = unusedDB->GetDBFolderInfo(getter_AddRefs(folderInfo));
+    rv = childDB->GetDBFolderInfo(getter_AddRefs(folderInfo));
     nsCOMPtr<nsIMsgImapMailFolder> imapFolder = do_QueryInterface(child, &rv);
     if (NS_SUCCEEDED(rv)) {
       nsAutoCString onlineName(m_onlineFolderName);
       if (!onlineName.IsEmpty()) onlineName.Append(hierarchyDelimiter);
       onlineName.Append(NS_ConvertUTF16toUTF8(folderNameStr));
       imapFolder->SetVerifiedAsOnlineFolder(true);
       imapFolder->SetOnlineName(onlineName);
       imapFolder->SetHierarchyDelimiter(hierarchyDelimiter);
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1686097046 -43200
#      Wed Jun 07 12:17:26 2023 +1200
# Node ID 11c211101e2773f707de6fb61a55b4622110929c
# Parent  4191e48da5a60826471fb4b5229d9f34d092140d
don't run changed-UIDVALIDITY actions on new folders.

diff --git a/mailnews/imap/src/nsImapCore.h b/mailnews/imap/src/nsImapCore.h
--- a/mailnews/imap/src/nsImapCore.h
+++ b/mailnews/imap/src/nsImapCore.h
@@ -62,17 +62,18 @@ typedef uint16_t imapMessageFlagsType;
 * piggying back the server support user flag info.
 */
 
 /* if a url creator does not know the hierarchyDelimiter, use this */
 #define kOnlineHierarchySeparatorUnknown '^'
 #define kOnlineHierarchySeparatorNil '|'
 
 #define IMAP_URL_TOKEN_SEPARATOR ">"
-#define kUidUnknown -1
+// UID and UIDVALIDITY are non-zero 32bit unsigned ints.
+#define kUidUnknown 0
 // Special initial value meaning ACLs need to be loaded from DB.
 #define kAclInvalid ((uint32_t) -1)
 
 // this has to do with Mime Parts on Demand. It used to live in net.h
 // I'm not sure where this will live, but here is OK temporarily
 typedef enum {
   IMAP_CONTENT_NOT_MODIFIED = 0,
   IMAP_CONTENT_MODIFIED_VIEW_INLINE,
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1686353968 -43200
#      Sat Jun 10 11:39:28 2023 +1200
# Node ID 4e7a5739d44f540b10fd672b95e37a58d4411229
# Parent  11c211101e2773f707de6fb61a55b4622110929c
globaldb: disregard unset UIDs when looking up by msgkey

diff --git a/mailnews/db/msgdb/src/GlobalDB.cpp b/mailnews/db/msgdb/src/GlobalDB.cpp
--- a/mailnews/db/msgdb/src/GlobalDB.cpp
+++ b/mailnews/db/msgdb/src/GlobalDB.cpp
@@ -2055,19 +2055,21 @@ nsresult GlobalDB::FolderGetKeysForUIDs(
 nsresult GlobalDB::FolderGetUIDsForKeys(nsFolderKey folderKey,
                                         nsTArray<nsMsgKey> const& keys,
                                         nsTArray<nsMsgKey>& uids) {
   const auto toCString = [](nsACString& dest, nsMsgKey key) {
     dest.AppendInt(key);
   };
   nsAutoCString keyList = StringJoin(","_ns, keys, toCString);
 
+  // NOTE: UIDs should be in separate table and JOINed in this query.
+  // But for now... just filter out unset UIDs.
   nsCOMPtr<mozIStorageStatement> stmt = Stmt(
       "SELECT m.imapUID FROM msg m INNER JOIN msg_folder f ON "
-      "m.id = f.msg_id WHERE f.folder_id = :folderKey AND m.id IN ("_ns +
+      "m.id = f.msg_id WHERE f.folder_id = :folderKey AND m.imapUID != 0 AND m.id IN ("_ns +
       keyList + ")"_ns);
   NS_ENSURE_STATE(stmt);
 
   mozStorageStatementScoper scoper(stmt);
   nsresult rv = stmt->BindInt64ByName("folderKey"_ns, (int64_t)folderKey);
   NS_ENSURE_SUCCESS(rv, rv);
 
   uids.Clear();
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1686354199 -43200
#      Sat Jun 10 11:43:19 2023 +1200
# Node ID 212c2a0e1e99a2252a1c8da305c1d80621ed41fc
# Parent  4e7a5739d44f540b10fd672b95e37a58d4411229
Fix up imap nsAutoSyncState borkage when no messages to download.

diff --git a/mailnews/imap/src/nsAutoSyncState.cpp b/mailnews/imap/src/nsAutoSyncState.cpp
--- a/mailnews/imap/src/nsAutoSyncState.cpp
+++ b/mailnews/imap/src/nsAutoSyncState.cpp
@@ -678,19 +678,16 @@ NS_IMETHODIMP nsAutoSyncState::DownloadM
     }
     if (uids.IsEmpty()) {
       return NS_OK;
     }
 
     rv = BuildUIDSet(uids, messageIds);
     NS_ENSURE_SUCCESS(rv, rv);
   }
-  if (messageIds.IsEmpty()) {
-    return NS_OK;
-  }
 
   // acquire semaphore for offline store. If it fails, we won't download
   nsCOMPtr<nsIMsgFolder> folder = do_QueryReferent(mOwnerFolder, &rv);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = folder->AcquireSemaphore(folder);
   NS_ENSURE_SUCCESS(rv, rv);
 
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1687139683 -43200
#      Mon Jun 19 13:54:43 2023 +1200
# Node ID c0ed2d1df4b6a6166491dfa3ea8d03a67bf8df8f
# Parent  212c2a0e1e99a2252a1c8da305c1d80621ed41fc
Bug ????? - Remove nsIImapService::fetchMessage() from public interface.

nsImapService::FetchMessage() is only ever called from within nsImapService,
so we can make it private.

diff --git a/mailnews/imap/public/nsIImapService.idl b/mailnews/imap/public/nsIImapService.idl
--- a/mailnews/imap/public/nsIImapService.idl
+++ b/mailnews/imap/public/nsIImapService.idl
@@ -47,26 +47,16 @@ interface nsIImapService : nsISupports
    * @param aMsgWindow          msg window url is running in, can be null
    *
    * @returns the url created to run the lite select in.
    */
   nsIURI liteSelectFolder(in nsIMsgFolder aImapMailFolder,
                           in nsIUrlListener aUrlListener,
                           in nsIMsgWindow aMsgWindow);
 
-  void fetchMessage(in nsIImapUrl aUrl,
-                    in nsImapState aImapAction,
-                    in nsIMsgFolder aImapMailFolder,
-                    in nsIImapMessageSink aImapMessageSink,
-                    in nsIMsgWindow aMsgWindow,
-                    in nsISupports aConsumer,
-                    in ACString aMessageIdentifierList,
-                    in boolean convertDataToText,
-                    out nsIURI aOutURL);
-
   void noop(in nsIMsgFolder aImapMailFolder,
             in nsIUrlListener aUrlListener,
             out nsIURI aURL);
 
   void getHeaders(in nsIMsgFolder aImapMailFolder,
                   in nsIUrlListener aUrlListener,
                   out nsIURI aURL,
                   in ACString aMessageIdentifierList,
diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -773,22 +773,24 @@ nsresult nsImapService::AddImapFetchToUr
   if (!aAdditionalHeader.IsEmpty()) {
     urlSpec.AppendLiteral("?header=");
     urlSpec.Append(aAdditionalHeader);
   }
 
   return aUrl->SetSpecInternal(urlSpec);
 }
 
-NS_IMETHODIMP nsImapService::FetchMessage(
-    nsIImapUrl* aImapUrl, nsImapAction aImapAction,
-    nsIMsgFolder* aImapMailFolder, nsIImapMessageSink* aImapMessage,
-    nsIMsgWindow* aMsgWindow, nsISupports* aDisplayConsumer,
-    const nsACString& messageIdentifierList, bool aConvertDataToText,
-    nsIURI** aURL) {
+nsresult nsImapService::FetchMessage(nsIImapUrl* aImapUrl,
+                                     nsImapAction aImapAction,
+                                     nsIMsgFolder* aImapMailFolder,
+                                     nsIImapMessageSink* aImapMessage,
+                                     nsIMsgWindow* aMsgWindow,
+                                     nsISupports* aDisplayConsumer,
+                                     const nsACString& messageIdentifierList,
+                                     bool aConvertDataToText, nsIURI** aURL) {
   NS_ENSURE_ARG_POINTER(aImapUrl);
   NS_ENSURE_ARG_POINTER(aImapMailFolder);
   NS_ENSURE_ARG_POINTER(aImapMessage);
 
   nsresult rv;
   nsCOMPtr<nsIMsgMailNewsUrl> mailnewsurl = do_QueryInterface(aImapUrl);
 
   rv = AddImapFetchToUrl(mailnewsurl, aImapMailFolder, messageIdentifierList,
diff --git a/mailnews/imap/src/nsImapService.h b/mailnews/imap/src/nsImapService.h
--- a/mailnews/imap/src/nsImapService.h
+++ b/mailnews/imap/src/nsImapService.h
@@ -48,16 +48,23 @@ class nsImapService : public nsIImapServ
   NS_DECL_NSIPROTOCOLHANDLER
   NS_DECL_NSIMSGMESSAGEFETCHPARTSERVICE
   NS_DECL_NSICONTENTHANDLER
 
  protected:
   virtual ~nsImapService();
   char GetHierarchyDelimiter(nsIMsgFolder* aMsgFolder);
 
+  nsresult FetchMessage(nsIImapUrl* aImapUrl, nsImapAction aImapAction,
+                        nsIMsgFolder* aImapMailFolder,
+                        nsIImapMessageSink* aImapMessage,
+                        nsIMsgWindow* aMsgWindow, nsISupports* aDisplayConsumer,
+                        const nsACString& messageIdentifierList,
+                        bool aConvertDataToText, nsIURI** aURL);
+
   nsresult AddImapFetchToUrl(nsIMsgMailNewsUrl* aUrl,
                              nsIMsgFolder* aImapMailFolder,
                              const nsACString& aMessageIdentifierList,
                              const nsACString& aAdditionalHeader);
 
   nsresult GetFolderName(nsIMsgFolder* aImapFolder, nsACString& aFolderName);
 
   // This is called by both FetchMessage and StreamMessage
# HG changeset patch
# User Ben Campbell <benc@thunderbird.net>
# Date 1687735494 -43200
#      Mon Jun 26 11:24:54 2023 +1200
# Node ID c518192a5e0595ac1233d91124c9f893567ac554
# Parent  c0ed2d1df4b6a6166491dfa3ea8d03a67bf8df8f
FetchMimePart -> FetchMimePartInternal

diff --git a/mailnews/imap/src/nsImapService.cpp b/mailnews/imap/src/nsImapService.cpp
--- a/mailnews/imap/src/nsImapService.cpp
+++ b/mailnews/imap/src/nsImapService.cpp
@@ -299,18 +299,18 @@ NS_IMETHODIMP nsImapService::FetchMimePa
       nsCOMPtr<nsIImapUrl> imapUrl = do_QueryInterface(aURI);
       nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(aURI, &rv));
       NS_ENSURE_SUCCESS(rv, rv);
 
       msgurl->SetMsgWindow(aMsgWindow);
       msgurl->RegisterListener(aUrlListener);
 
       if (!mimePart.IsEmpty()) {
-        return FetchMimePart(imapUrl, folder, imapMessageSink, aURL,
-                             aDisplayConsumer, key, mimePart);
+        return FetchMimePartInternal(imapUrl, folder, imapMessageSink, aURL,
+                                     aDisplayConsumer, key, mimePart);
       }
     }
   }
   return rv;
 }
 
 NS_IMETHODIMP nsImapService::LoadMessage(const nsACString& aMessageURI,
                                          nsISupports* aDisplayConsumer,
@@ -378,19 +378,19 @@ NS_IMETHODIMP nsImapService::LoadMessage
         nsAutoCString uidStr;
         rv = MsgKeysToUIDSet(folder, {key}, uidStr);
         NS_ENSURE_SUCCESS(rv, rv);
         rv = AddImapFetchToUrl(mailnewsurl, folder, uidStr + mimePart,
                                EmptyCString());
         NS_ENSURE_SUCCESS(rv, rv);
 
         nsCOMPtr<nsIURI> dummyURI;
-        return FetchMimePart(imapUrl, folder, imapMessageSink,
-                             getter_AddRefs(dummyURI), aDisplayConsumer, key,
-                             mimePart);
+        return FetchMimePartInternal(imapUrl, folder, imapMessageSink,
+                                     getter_AddRefs(dummyURI), aDisplayConsumer,
+                                     key, mimePart);
       }
 
       nsCOMPtr<nsIMsgMailNewsUrl> msgurl(do_QueryInterface(imapUrl));
       nsCOMPtr<nsIMsgI18NUrl> i18nurl(do_QueryInterface(imapUrl));
       i18nurl->SetAutodetectCharset(aAutodetectCharset);
 
       bool shouldStoreMsgOffline = false;
       bool hasMsgOffline = false;
@@ -434,23 +434,23 @@ NS_IMETHODIMP nsImapService::LoadMessage
                                   : nsIImapUrl::nsImapMsgFetch,
                         folder, imapMessageSink, aMsgWindow, aDisplayConsumer,
                         uidStr, false, getter_AddRefs(dummyURI));
     }
   }
   return rv;
 }
 
-nsresult nsImapService::FetchMimePart(nsIImapUrl* aImapUrl,
-                                      nsIMsgFolder* aImapMailFolder,
-                                      nsIImapMessageSink* aImapMessage,
-                                      nsIURI** aURL,
-                                      nsISupports* aDisplayConsumer,
-                                      nsMsgKey msgKey,
-                                      const nsACString& mimePart) {
+nsresult nsImapService::FetchMimePartInternal(nsIImapUrl* aImapUrl,
+                                              nsIMsgFolder* aImapMailFolder,
+                                              nsIImapMessageSink* aImapMessage,
+                                              nsIURI** aURL,
+                                              nsISupports* aDisplayConsumer,
+                                              nsMsgKey msgKey,
+                                              const nsACString& mimePart) {
   NS_ENSURE_ARG_POINTER(aImapUrl);
   NS_ENSURE_ARG_POINTER(aImapMailFolder);
   NS_ENSURE_ARG_POINTER(aImapMessage);
   MOZ_ASSERT(msgKey != nsMsgKey_None);
 
   // create a protocol instance to handle the request.
   // NOTE: once we start working with multiple connections, this step will be
   // much more complicated...but for now just create a connection and process
diff --git a/mailnews/imap/src/nsImapService.h b/mailnews/imap/src/nsImapService.h
--- a/mailnews/imap/src/nsImapService.h
+++ b/mailnews/imap/src/nsImapService.h
@@ -83,20 +83,21 @@ class nsImapService : public nsIImapServ
       char& hierarchyDelimiter);
 
   nsresult GetImapConnectionAndLoadUrl(nsIImapUrl* aImapUrl,
                                        nsISupports* aConsumer, nsIURI** aURL);
 
   static nsresult SetImapUrlSink(nsIMsgFolder* aMsgFolder,
                                  nsIImapUrl* aImapUrl);
 
-  nsresult FetchMimePart(nsIImapUrl* aImapUrl, nsIMsgFolder* aImapMailFolder,
-                         nsIImapMessageSink* aImapMessage, nsIURI** aURL,
-                         nsISupports* aDisplayConsumer, nsMsgKey msgKey,
-                         const nsACString& mimePart);
+  nsresult FetchMimePartInternal(nsIImapUrl* aImapUrl,
+                                 nsIMsgFolder* aImapMailFolder,
+                                 nsIImapMessageSink* aImapMessage,
+                                 nsIURI** aURL, nsISupports* aDisplayConsumer,
+                                 nsMsgKey msgKey, const nsACString& mimePart);
 
   nsresult FolderCommand(nsIMsgFolder* imapMailFolder,
                          nsIUrlListener* urlListener, const char* aCommand,
                          nsImapAction imapAction, nsIMsgWindow* msgWindow,
                          nsIURI** url);
 
   nsresult ChangeFolderSubscription(nsIMsgFolder* folder,
                                     const nsAString& folderName,
